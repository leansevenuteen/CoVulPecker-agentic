[
    {
        "pre_patch": "  void VerifyDailyContentLengthPrefLists(\n       const int64* original_values, size_t original_count,\n       const int64* received_values, size_t received_count,\n       const int64* original_with_data_reduction_proxy_enabled_values,\n      size_t original_with_data_reduction_proxy_enabled_count,\n      const int64* received_with_data_reduction_proxy_enabled_values,\n      size_t received_with_data_reduction_proxy_count,\n      const int64* original_via_data_reduction_proxy_values,\n      size_t original_via_data_reduction_proxy_count,\n      const int64* received_via_data_reduction_proxy_values,\n      size_t received_via_data_reduction_proxy_count) {\n    VerifyPrefList(prefs::kDailyHttpOriginalContentLength,\n                   original_values, original_count);\n    VerifyPrefList(prefs::kDailyHttpReceivedContentLength,\n                   received_values, received_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled,\n        original_with_data_reduction_proxy_enabled_values,\n        original_with_data_reduction_proxy_enabled_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthWithDataReductionProxyEnabled,\n        received_with_data_reduction_proxy_enabled_values,\n        received_with_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthViaDataReductionProxy,\n        original_via_data_reduction_proxy_values,\n        original_via_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthViaDataReductionProxy,\n        received_via_data_reduction_proxy_values,\n         received_via_data_reduction_proxy_count);\n   }\n",
        "post_patch": "  void VerifyDailyContentLengthPrefLists(\n  // Verify all daily data saving pref list values.\n  void VerifyDailyDataSavingContentLengthPrefLists(\n       const int64* original_values, size_t original_count,\n       const int64* received_values, size_t received_count,\n       const int64* original_with_data_reduction_proxy_enabled_values,\n      size_t original_with_data_reduction_proxy_enabled_count,\n      const int64* received_with_data_reduction_proxy_enabled_values,\n      size_t received_with_data_reduction_proxy_count,\n      const int64* original_via_data_reduction_proxy_values,\n      size_t original_via_data_reduction_proxy_count,\n      const int64* received_via_data_reduction_proxy_values,\n      size_t received_via_data_reduction_proxy_count) {\n    VerifyPrefList(prefs::kDailyHttpOriginalContentLength,\n                   original_values, original_count);\n    VerifyPrefList(prefs::kDailyHttpReceivedContentLength,\n                   received_values, received_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled,\n        original_with_data_reduction_proxy_enabled_values,\n        original_with_data_reduction_proxy_enabled_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthWithDataReductionProxyEnabled,\n        received_with_data_reduction_proxy_enabled_values,\n        received_with_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthViaDataReductionProxy,\n        original_via_data_reduction_proxy_values,\n        original_via_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthViaDataReductionProxy,\n        received_via_data_reduction_proxy_values,\n         received_via_data_reduction_proxy_count);\n   }\n",
        "post_patch_with_fix": "  void VerifyDailyContentLengthPrefLists(\n//fix_flaw_line_below:\n//  // Verify all daily data saving pref list values.\n//fix_flaw_line_below:\n//  void VerifyDailyDataSavingContentLengthPrefLists(\n       const int64* original_values, size_t original_count,\n       const int64* received_values, size_t received_count,\n       const int64* original_with_data_reduction_proxy_enabled_values,\n      size_t original_with_data_reduction_proxy_enabled_count,\n      const int64* received_with_data_reduction_proxy_enabled_values,\n      size_t received_with_data_reduction_proxy_count,\n      const int64* original_via_data_reduction_proxy_values,\n      size_t original_via_data_reduction_proxy_count,\n      const int64* received_via_data_reduction_proxy_values,\n      size_t received_via_data_reduction_proxy_count) {\n    VerifyPrefList(prefs::kDailyHttpOriginalContentLength,\n                   original_values, original_count);\n    VerifyPrefList(prefs::kDailyHttpReceivedContentLength,\n                   received_values, received_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled,\n        original_with_data_reduction_proxy_enabled_values,\n        original_with_data_reduction_proxy_enabled_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthWithDataReductionProxyEnabled,\n        received_with_data_reduction_proxy_enabled_values,\n        received_with_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthViaDataReductionProxy,\n        original_via_data_reduction_proxy_values,\n        original_via_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthViaDataReductionProxy,\n        received_via_data_reduction_proxy_values,\n         received_via_data_reduction_proxy_count);\n   }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n     }\n   }\n }\n",
        "post_patch": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n  mrb_value nil;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n     }\n   }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n }\n",
        "post_patch_with_fix": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n//fix_flaw_line_below:\n//  mrb_value nil;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n//flaw_line_below:\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n//flaw_line_below:\n        c->stbase[i] = mrb_nil_value();\n//flaw_line_below:\n      }\n//flaw_line_below:\n      else {\n//flaw_line_below:\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n//flaw_line_below:\n      }\n//fix_flaw_line_below:\n//      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n     }\n   }\n//fix_flaw_line_below:\n//  e = c->stend - c->stbase;\n//fix_flaw_line_below:\n//  nil = mrb_nil_value();\n//fix_flaw_line_below:\n//  for (; i<e; i++) {\n//fix_flaw_line_below:\n//    c->stbase[i] = nil;\n//fix_flaw_line_below:\n//  }\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n }\n",
        "post_patch": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n }\n",
        "post_patch_with_fix": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n//flaw_line_below:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n//fix_flaw_line_below:\n//\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static void lo_release(struct gendisk *disk, fmode_t mode)\n {\n\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n",
        "post_patch": "static void lo_release(struct gendisk *disk, fmode_t mode)\nstatic void __lo_release(struct loop_device *lo)\n {\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n",
        "post_patch_with_fix": "static void lo_release(struct gendisk *disk, fmode_t mode)\n//fix_flaw_line_below:\n//static void __lo_release(struct loop_device *lo)\n {\n//flaw_line_below:\n\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n\t\t\t\t int chunks)\n{\n\tary->wc_discrim = xdr_one;\n\tary->wc_nchunks = cpu_to_be32(chunks);\n}\n",
        "post_patch": "void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n",
        "post_patch_with_fix": "void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n//flaw_line_below:\n\t\t\t\t int chunks)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tary->wc_discrim = xdr_one;\n//flaw_line_below:\n\tary->wc_nchunks = cpu_to_be32(chunks);\n//flaw_line_below:\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": " void RenderFrameImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  if (!external_popup_menu_)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n  external_popup_menu_.reset();\n }\n",
        "post_patch": " void RenderFrameImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  if (!external_popup_menu_)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  // We need to reset |external_popup_menu_| before calling DidSelectItems(),\n  // which might delete |this|.\n  // See ExternalPopupMenuRemoveTest.RemoveFrameOnChange\n  std::unique_ptr<ExternalPopupMenu> popup;\n  popup.swap(external_popup_menu_);\n  popup->DidSelectItems(canceled, selected_indices);\n }\n",
        "post_patch_with_fix": " void RenderFrameImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  // It is possible to receive more than one of these calls if the user presses\n  // a select faster than it takes for the show-select-popup IPC message to make\n  // it to the browser UI thread. Ignore the extra-messages.\n  // TODO(jcivelli): http:/b/5793321 Implement a better fix, as detailed in bug.\n  if (!external_popup_menu_)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n//flaw_line_below:\n  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n//flaw_line_below:\n  external_popup_menu_.reset();\n//fix_flaw_line_below:\n//  // We need to reset |external_popup_menu_| before calling DidSelectItems(),\n//fix_flaw_line_below:\n//  // which might delete |this|.\n//fix_flaw_line_below:\n//  // See ExternalPopupMenuRemoveTest.RemoveFrameOnChange\n//fix_flaw_line_below:\n//  std::unique_ptr<ExternalPopupMenu> popup;\n//fix_flaw_line_below:\n//  popup.swap(external_popup_menu_);\n//fix_flaw_line_below:\n//  popup->DidSelectItems(canceled, selected_indices);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n \n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n\t\treturn res;\n \n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\n \n \treturn res;\n }\n",
        "post_patch": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n \n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n\t\tgoto err_add_port;\n \n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\nerr_add_port:\n\thsr_del_node(&hsr->self_node_db);\n \n \treturn res;\n }\n",
        "post_patch_with_fix": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n \n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n//flaw_line_below:\n\t\treturn res;\n//fix_flaw_line_below:\n//\t\tgoto err_add_port;\n \n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\n//fix_flaw_line_below:\n//err_add_port:\n//fix_flaw_line_below:\n//\thsr_del_node(&hsr->self_node_db);\n \n \treturn res;\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n\tif (!int_port || !ext_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n",
        "post_patch": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n",
        "post_patch_with_fix": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n//flaw_line_below:\n\tif (!int_port || !ext_port || !protocol)\n//fix_flaw_line_below:\n//\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n \t\t * Get a reference to this pipe buffer,\n \t\t * so we can copy the contents over.\n \t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n \n \t\tobuf = opipe->bufs + nbuf;\n \t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tpipe_buf_mark_unmergeable(obuf);\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}\n",
        "post_patch": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n \t\t * Get a reference to this pipe buffer,\n \t\t * so we can copy the contents over.\n \t\t */\n\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n \t\tobuf = opipe->bufs + nbuf;\n \t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tpipe_buf_mark_unmergeable(obuf);\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}\n",
        "post_patch_with_fix": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n \t\t * Get a reference to this pipe buffer,\n \t\t * so we can copy the contents over.\n \t\t */\n//flaw_line_below:\n\t\tpipe_buf_get(ipipe, ibuf);\n//fix_flaw_line_below:\n//\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n//fix_flaw_line_below:\n//\t\t\tif (ret == 0)\n//fix_flaw_line_below:\n//\t\t\t\tret = -EFAULT;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\t\t}\n \n \t\tobuf = opipe->bufs + nbuf;\n \t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tpipe_buf_mark_unmergeable(obuf);\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static int packet_do_bind(struct sock *sk, const char *name, int ifindex,\n\t\t\t  __be16 proto)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct net_device *dev_curr;\n\t__be16 proto_curr;\n\tbool need_rehook;\n\tstruct net_device *dev = NULL;\n \tint ret = 0;\n \tbool unlisted = false;\n \n\tif (po->fanout)\n\t\treturn -EINVAL;\n \tlock_sock(sk);\n \tspin_lock(&po->bind_lock);\n \trcu_read_lock();\n \n \tif (name) {\n \t\tdev = dev_get_by_name_rcu(sock_net(sk), name);\n \t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (ifindex) {\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tdev_hold(dev);\n\n\tproto_curr = po->prot_hook.type;\n\tdev_curr = po->prot_hook.dev;\n\n\tneed_rehook = proto_curr != proto || dev_curr != dev;\n\n\tif (need_rehook) {\n\t\tif (po->running) {\n\t\t\trcu_read_unlock();\n\t\t\t__unregister_prot_hook(sk, true);\n\t\t\trcu_read_lock();\n\t\t\tdev_curr = po->prot_hook.dev;\n\t\t\tif (dev)\n\t\t\t\tunlisted = !dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t\t\t dev->ifindex);\n\t\t}\n\n\t\tpo->num = proto;\n\t\tpo->prot_hook.type = proto;\n\n\t\tif (unlikely(unlisted)) {\n\t\t\tdev_put(dev);\n\t\t\tpo->prot_hook.dev = NULL;\n\t\t\tpo->ifindex = -1;\n\t\t\tpacket_cached_dev_reset(po);\n\t\t} else {\n\t\t\tpo->prot_hook.dev = dev;\n\t\t\tpo->ifindex = dev ? dev->ifindex : 0;\n\t\t\tpacket_cached_dev_assign(po, dev);\n\t\t}\n\t}\n\tif (dev_curr)\n\t\tdev_put(dev_curr);\n\n\tif (proto == 0 || !need_rehook)\n\t\tgoto out_unlock;\n\n\tif (!unlisted && (!dev || (dev->flags & IFF_UP))) {\n\t\tregister_prot_hook(sk);\n\t} else {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_error_report(sk);\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\tspin_unlock(&po->bind_lock);\n\trelease_sock(sk);\n\treturn ret;\n}\n",
        "post_patch": "static int packet_do_bind(struct sock *sk, const char *name, int ifindex,\n\t\t\t  __be16 proto)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct net_device *dev_curr;\n\t__be16 proto_curr;\n\tbool need_rehook;\n\tstruct net_device *dev = NULL;\n \tint ret = 0;\n \tbool unlisted = false;\n \n \tlock_sock(sk);\n \tspin_lock(&po->bind_lock);\n \trcu_read_lock();\n \n\tif (po->fanout) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n \tif (name) {\n \t\tdev = dev_get_by_name_rcu(sock_net(sk), name);\n \t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (ifindex) {\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tdev_hold(dev);\n\n\tproto_curr = po->prot_hook.type;\n\tdev_curr = po->prot_hook.dev;\n\n\tneed_rehook = proto_curr != proto || dev_curr != dev;\n\n\tif (need_rehook) {\n\t\tif (po->running) {\n\t\t\trcu_read_unlock();\n\t\t\t__unregister_prot_hook(sk, true);\n\t\t\trcu_read_lock();\n\t\t\tdev_curr = po->prot_hook.dev;\n\t\t\tif (dev)\n\t\t\t\tunlisted = !dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t\t\t dev->ifindex);\n\t\t}\n\n\t\tpo->num = proto;\n\t\tpo->prot_hook.type = proto;\n\n\t\tif (unlikely(unlisted)) {\n\t\t\tdev_put(dev);\n\t\t\tpo->prot_hook.dev = NULL;\n\t\t\tpo->ifindex = -1;\n\t\t\tpacket_cached_dev_reset(po);\n\t\t} else {\n\t\t\tpo->prot_hook.dev = dev;\n\t\t\tpo->ifindex = dev ? dev->ifindex : 0;\n\t\t\tpacket_cached_dev_assign(po, dev);\n\t\t}\n\t}\n\tif (dev_curr)\n\t\tdev_put(dev_curr);\n\n\tif (proto == 0 || !need_rehook)\n\t\tgoto out_unlock;\n\n\tif (!unlisted && (!dev || (dev->flags & IFF_UP))) {\n\t\tregister_prot_hook(sk);\n\t} else {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_error_report(sk);\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\tspin_unlock(&po->bind_lock);\n\trelease_sock(sk);\n\treturn ret;\n}\n",
        "post_patch_with_fix": "static int packet_do_bind(struct sock *sk, const char *name, int ifindex,\n\t\t\t  __be16 proto)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct net_device *dev_curr;\n\t__be16 proto_curr;\n\tbool need_rehook;\n\tstruct net_device *dev = NULL;\n \tint ret = 0;\n \tbool unlisted = false;\n \n//flaw_line_below:\n\tif (po->fanout)\n//flaw_line_below:\n\t\treturn -EINVAL;\n//flaw_line_below:\n\n \tlock_sock(sk);\n \tspin_lock(&po->bind_lock);\n \trcu_read_lock();\n \n//fix_flaw_line_below:\n//\tif (po->fanout) {\n//fix_flaw_line_below:\n//\t\tret = -EINVAL;\n//fix_flaw_line_below:\n//\t\tgoto out_unlock;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \tif (name) {\n \t\tdev = dev_get_by_name_rcu(sock_net(sk), name);\n \t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (ifindex) {\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), ifindex);\n\t\tif (!dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tdev_hold(dev);\n\n\tproto_curr = po->prot_hook.type;\n\tdev_curr = po->prot_hook.dev;\n\n\tneed_rehook = proto_curr != proto || dev_curr != dev;\n\n\tif (need_rehook) {\n\t\tif (po->running) {\n\t\t\trcu_read_unlock();\n\t\t\t__unregister_prot_hook(sk, true);\n\t\t\trcu_read_lock();\n\t\t\tdev_curr = po->prot_hook.dev;\n\t\t\tif (dev)\n\t\t\t\tunlisted = !dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t\t\t dev->ifindex);\n\t\t}\n\n\t\tpo->num = proto;\n\t\tpo->prot_hook.type = proto;\n\n\t\tif (unlikely(unlisted)) {\n\t\t\tdev_put(dev);\n\t\t\tpo->prot_hook.dev = NULL;\n\t\t\tpo->ifindex = -1;\n\t\t\tpacket_cached_dev_reset(po);\n\t\t} else {\n\t\t\tpo->prot_hook.dev = dev;\n\t\t\tpo->ifindex = dev ? dev->ifindex : 0;\n\t\t\tpacket_cached_dev_assign(po, dev);\n\t\t}\n\t}\n\tif (dev_curr)\n\t\tdev_put(dev_curr);\n\n\tif (proto == 0 || !need_rehook)\n\t\tgoto out_unlock;\n\n\tif (!unlisted && (!dev || (dev->flags & IFF_UP))) {\n\t\tregister_prot_hook(sk);\n\t} else {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_error_report(sk);\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\tspin_unlock(&po->bind_lock);\n\trelease_sock(sk);\n\treturn ret;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n\n    setScrollOffset(toIntSize(newScrollOffset));\n\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n\n    RefPtr<FrameView> frameView = box().frameView();\n\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    InspectorInstrumentation::willScrollLayer(&box());\n\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n\n    if (!frameView->isInPerformLayout()) {\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         frameView->updateAnnotatedRegions();\n        frameView->updateWidgetPositions();\n        RELEASE_ASSERT(frameView->renderView());\n         updateCompositingLayersAfterScroll();\n     }\n \n    frame->selection().setCaretRectNeedsUpdate();\n\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n\n    bool requiresPaintInvalidation = true;\n\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n\n    InspectorInstrumentation::didScrollLayer(&box());\n}\n",
        "post_patch": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n\n    setScrollOffset(toIntSize(newScrollOffset));\n\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n\n    RefPtr<FrameView> frameView = box().frameView();\n\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    InspectorInstrumentation::willScrollLayer(&box());\n\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n\n    if (!frameView->isInPerformLayout()) {\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         frameView->updateAnnotatedRegions();\n        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n \n    frame->selection().setCaretRectNeedsUpdate();\n\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n\n    bool requiresPaintInvalidation = true;\n\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n\n    InspectorInstrumentation::didScrollLayer(&box());\n}\n",
        "post_patch_with_fix": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n\n    setScrollOffset(toIntSize(newScrollOffset));\n\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n\n    RefPtr<FrameView> frameView = box().frameView();\n\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.\n    InspectorInstrumentation::willScrollLayer(&box());\n\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n\n    // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).\n    // We don't update compositing layers, because we need to do a deep update from the compositing ancestor.\n    if (!frameView->isInPerformLayout()) {\n        // If we're in the middle of layout, we'll just update layers once layout has finished.\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         // Update regions, scrolling may change the clip of a particular region.\n         frameView->updateAnnotatedRegions();\n//flaw_line_below:\n        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,\n//flaw_line_below:\n        // for now we just crash to avoid allowing an attacker to use after free.\n//flaw_line_below:\n        frameView->updateWidgetPositions();\n//flaw_line_below:\n        RELEASE_ASSERT(frameView->renderView());\n//fix_flaw_line_below:\n//        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n \n    // The caret rect needs to be invalidated after scrolling\n    frame->selection().setCaretRectNeedsUpdate();\n\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n\n    bool requiresPaintInvalidation = true;\n\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        // Hits in virtual/gpu/fast/canvas/canvas-scroll-path-into-view.html.\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n\n    // Just schedule a full paint invalidation of our object.\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n\n    // Schedule the scroll DOM event.\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n\n    InspectorInstrumentation::didScrollLayer(&box());\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n",
        "post_patch": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n",
        "post_patch_with_fix": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n//fix_flaw_line_below:\n//\t    if (l == NULL)\n//fix_flaw_line_below:\n//\t\tbreak;\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n",
        "post_patch": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n      rar->filename_must_match = 1;\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n      rar->filename_must_match = 0;\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n",
        "post_patch_with_fix": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n//fix_flaw_line_below:\n//      rar->filename_must_match = 1;\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n//fix_flaw_line_below:\n//      rar->filename_must_match = 0;\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": " double ConvolverNode::latencyTime() const\n {\n    return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n }\n",
        "post_patch": " double ConvolverNode::latencyTime() const\n {\n    MutexTryLocker tryLocker(m_processLock);\n    if (tryLocker.locked())\n        return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n    // Since we don't want to block the Audio Device thread, we return a large value\n    // instead of trying to acquire the lock.\n    return std::numeric_limits<double>::infinity();\n }\n",
        "post_patch_with_fix": " double ConvolverNode::latencyTime() const\n {\n//flaw_line_below:\n    return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n//fix_flaw_line_below:\n//    MutexTryLocker tryLocker(m_processLock);\n//fix_flaw_line_below:\n//    if (tryLocker.locked())\n//fix_flaw_line_below:\n//        return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n//fix_flaw_line_below:\n//    // Since we don't want to block the Audio Device thread, we return a large value\n//fix_flaw_line_below:\n//    // instead of trying to acquire the lock.\n//fix_flaw_line_below:\n//    return std::numeric_limits<double>::infinity();\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n",
        "post_patch": "gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n",
        "post_patch_with_fix": "gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n//fix_flaw_line_below:\n//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n//fix_flaw_line_below:\n//\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "ChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else if (!base::FeatureList::IsEnabled(\n                   features::kDesktopPWAsStayInWindow)) {\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n   if (base::FeatureList::IsEnabled(\n           features::kMimeHandlerViewInCrossProcessFrame)) {\n     auto plugin_frame_attach_throttle =\n        extensions::ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n            handle);\n     if (plugin_frame_attach_throttle)\n       throttles.push_back(std::move(plugin_frame_attach_throttle));\n   }\n#endif\n\n#if defined(OS_CHROMEOS)\n  if (handle->IsInMainFrame()) {\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n\n  std::unique_ptr<content::NavigationThrottle> user_script_throttle =\n      extensions::ExtensionsBrowserClient::Get()\n          ->GetUserScriptListener()\n          ->CreateNavigationThrottle(handle);\n  if (user_script_throttle)\n    throttles.push_back(std::move(user_script_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::FeatureList::IsEnabled(features::kSSLCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n\n  std::unique_ptr<content::NavigationThrottle>\n      google_password_manager_throttle =\n          GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n  if (google_password_manager_throttle)\n    throttles.push_back(std::move(google_password_manager_throttle));\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> previews_lite_page_throttle =\n      PreviewsLitePageDecider::MaybeCreateThrottleFor(handle);\n  if (previews_lite_page_throttle)\n    throttles.push_back(std::move(previews_lite_page_throttle));\n  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {\n    throttles.push_back(\n        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(\n            handle));\n  }\n\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  std::unique_ptr<content::NavigationThrottle> browser_switcher_throttle =\n      browser_switcher::BrowserSwitcherNavigationThrottle ::\n          MaybeCreateThrottleFor(handle);\n  if (browser_switcher_throttle)\n    throttles.push_back(std::move(browser_switcher_throttle));\n#endif\n\n  return throttles;\n}\n",
        "post_patch": "ChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else if (!base::FeatureList::IsEnabled(\n                   features::kDesktopPWAsStayInWindow)) {\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n   if (base::FeatureList::IsEnabled(\n           features::kMimeHandlerViewInCrossProcessFrame)) {\n     auto plugin_frame_attach_throttle =\n        extensions::MimeHandlerViewAttachHelper::MaybeCreateThrottle(handle);\n     if (plugin_frame_attach_throttle)\n       throttles.push_back(std::move(plugin_frame_attach_throttle));\n   }\n#endif\n\n#if defined(OS_CHROMEOS)\n  if (handle->IsInMainFrame()) {\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n\n  std::unique_ptr<content::NavigationThrottle> user_script_throttle =\n      extensions::ExtensionsBrowserClient::Get()\n          ->GetUserScriptListener()\n          ->CreateNavigationThrottle(handle);\n  if (user_script_throttle)\n    throttles.push_back(std::move(user_script_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::FeatureList::IsEnabled(features::kSSLCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n\n  std::unique_ptr<content::NavigationThrottle>\n      google_password_manager_throttle =\n          GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n  if (google_password_manager_throttle)\n    throttles.push_back(std::move(google_password_manager_throttle));\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> previews_lite_page_throttle =\n      PreviewsLitePageDecider::MaybeCreateThrottleFor(handle);\n  if (previews_lite_page_throttle)\n    throttles.push_back(std::move(previews_lite_page_throttle));\n  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {\n    throttles.push_back(\n        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(\n            handle));\n  }\n\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  std::unique_ptr<content::NavigationThrottle> browser_switcher_throttle =\n      browser_switcher::BrowserSwitcherNavigationThrottle ::\n          MaybeCreateThrottleFor(handle);\n  if (browser_switcher_throttle)\n    throttles.push_back(std::move(browser_switcher_throttle));\n#endif\n\n  return throttles;\n}\n",
        "post_patch_with_fix": "ChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  // MetricsNavigationThrottle requires that it runs before NavigationThrottles\n  // that may delay or cancel navigations, so only NavigationThrottles that\n  // don't delay or cancel navigations (e.g. throttles that are only observing\n  // callbacks without affecting navigation behavior) should be added before\n  // MetricsNavigationThrottle.\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  // TODO(davidben): This is insufficient to integrate with prerender properly.\n  // https://crbug.com/370595\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    // Redirect some navigations to apps that have registered matching URL\n    // handlers ('url_handlers' in the manifest).\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else if (!base::FeatureList::IsEnabled(\n                   features::kDesktopPWAsStayInWindow)) {\n      // Only add the bookmark app navigation throttle if the stay in\n      // window flag is not set, as the navigation throttle controls\n      // opening out of scope links in the browser.\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n   if (base::FeatureList::IsEnabled(\n           features::kMimeHandlerViewInCrossProcessFrame)) {\n     auto plugin_frame_attach_throttle =\n//flaw_line_below:\n        extensions::ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n//flaw_line_below:\n            handle);\n//fix_flaw_line_below:\n//        extensions::MimeHandlerViewAttachHelper::MaybeCreateThrottle(handle);\n     if (plugin_frame_attach_throttle)\n       throttles.push_back(std::move(plugin_frame_attach_throttle));\n   }\n#endif\n\n#if defined(OS_CHROMEOS)\n  // Check if we need to add merge session throttle. This throttle will postpone\n  // loading of main frames.\n  if (handle->IsInMainFrame()) {\n    // Add interstitial page while merge session process (cookie reconstruction\n    // from OAuth2 refresh token in ChromeOS login) is still in progress while\n    // we are attempting to load a google property.\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n\n  std::unique_ptr<content::NavigationThrottle> user_script_throttle =\n      extensions::ExtensionsBrowserClient::Get()\n          ->GetUserScriptListener()\n          ->CreateNavigationThrottle(handle);\n  if (user_script_throttle)\n    throttles.push_back(std::move(user_script_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  // BackgroundTabNavigationThrottle is used by TabManager, which is only\n  // enabled on non-Android platforms.\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::FeatureList::IsEnabled(features::kSSLCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n\n  std::unique_ptr<content::NavigationThrottle>\n      google_password_manager_throttle =\n          GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n  if (google_password_manager_throttle)\n    throttles.push_back(std::move(google_password_manager_throttle));\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> previews_lite_page_throttle =\n      PreviewsLitePageDecider::MaybeCreateThrottleFor(handle);\n  if (previews_lite_page_throttle)\n    throttles.push_back(std::move(previews_lite_page_throttle));\n  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {\n    throttles.push_back(\n        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(\n            handle));\n  }\n\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  std::unique_ptr<content::NavigationThrottle> browser_switcher_throttle =\n      browser_switcher::BrowserSwitcherNavigationThrottle ::\n          MaybeCreateThrottleFor(handle);\n  if (browser_switcher_throttle)\n    throttles.push_back(std::move(browser_switcher_throttle));\n#endif\n\n  return throttles;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)\n{\n\tconst unsigned char *cursor, *limit, *marker, *start;\n\tzval *rval_ref;\n\n\tlimit = max;\n\tcursor = *p;\n\n\tif (YYCURSOR >= YYLIMIT) {\n\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n \tstart = cursor;\n \n \n#line 585 \"ext/standard/var_unserializer.c\"\n {\n \tYYCTYPE yych;\n \tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t128, 128,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n \tyych = *YYCURSOR;\n \tswitch (yych) {\n \tcase 'C':\n\tcase 'O':\tgoto yy13;\n \tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy2;\n\tcase 'S':\tgoto yy10;\n\tcase 'a':\tgoto yy11;\n\tcase 'b':\tgoto yy6;\n\tcase 'd':\tgoto yy8;\n\tcase 'i':\tgoto yy7;\n \tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy4;\n\tcase 's':\tgoto yy9;\n\tcase '}':\tgoto yy14;\n\tdefault:\tgoto yy16;\n \t}\n yy2:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy95;\n yy3:\n#line 962 \"ext/standard/var_unserializer.re\"\n \t{ return 0; }\n#line 646 \"ext/standard/var_unserializer.c\"\n yy4:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy89;\n \tgoto yy3;\n yy5:\n \tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy87;\n \tgoto yy3;\n yy6:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy83;\n \tgoto yy3;\n yy7:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy77;\n \tgoto yy3;\n yy8:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy53;\n \tgoto yy3;\n yy9:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy46;\n \tgoto yy3;\n yy10:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy39;\n \tgoto yy3;\n yy11:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy32;\n \tgoto yy3;\n yy12:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n \tgoto yy3;\n yy13:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n \tgoto yy3;\n yy14:\n \t++YYCURSOR;\n#line 956 \"ext/standard/var_unserializer.re\"\n \t{\n \t/* this is the case where we have less data than planned */\n \tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n \treturn 0; /* not sure if it should be 0 or 1 here? */\n }\n#line 695 \"ext/standard/var_unserializer.c\"\nyy16:\n\tyych = *++YYCURSOR;\n\tgoto yy3;\n yy17:\n \tyych = *++YYCURSOR;\n \tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n \t}\n\tif (yych == '+') goto yy19;\n yy18:\n \tYYCURSOR = YYMARKER;\n \tgoto yy3;\n yy19:\n \tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n \t}\n \tgoto yy18;\nyy20:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 804 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\tzend_class_entry *ce;\n\tint incomplete_class = 0;\n\tint custom_object = 0;\n\tzval user_func;\n\tzval retval;\n\tzval args[1];\n    if (!var_hash) return 0;\n\tif (*start == 'C') {\n\t\tcustom_object = 1;\n\t}\n\tlen2 = len = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len || len == 0) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\tstr = (char*)YYCURSOR;\n\tYYCURSOR += len;\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR+1) != ':') {\n\t\t*p = YYCURSOR+1;\n\t\treturn 0;\n\t}\n\tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");\n\tif (len3 != len)\n\t{\n\t\t*p = YYCURSOR + len3 - len;\n\t\treturn 0;\n\t}\n\tclass_name = zend_string_init(str, len, 0);\n\tdo {\n\t\tif(!unserialize_allowed_class(class_name, classes)) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\t\t/* Try to find class directly */\n\t\tBG(serialize_lock)++;\n\t\tce = zend_lookup_class(class_name);\n\t\tif (ce) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Check for unserialize callback */\n\t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\t\t/* Call unserialize callback */\n\t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));\n\t\tZVAL_STR_COPY(&args[0], class_name);\n\t\tBG(serialize_lock)++;\n\t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\tzval_ptr_dtor(&user_func);\n\t\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\t\tzval_ptr_dtor(&retval);\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\treturn 0;\n\t\t}\n\t\t/* The callback function may have defined the class */\n\t\tBG(serialize_lock)++;\n\t\tif ((ce = zend_lookup_class(class_name)) == NULL) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n \t\t}\n\t\tBG(serialize_lock)--;\n\t\tzval_ptr_dtor(&user_func);\n\t\tzval_ptr_dtor(&args[0]);\n\t\tbreak;\n\t} while (1);\n\t*p = YYCURSOR;\n\tif (custom_object) {\n\t\tint ret;\n\t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);\n\t\tif (ret && incomplete_class) {\n\t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n \t\t}\n\t\tzend_string_release(class_name);\n\t\treturn ret;\n \t}\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n\tif (elements < 0) {\n\t   zend_string_release(class_name);\n\t   return 0;\n \t}\n\tif (incomplete_class) {\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n \t}\n\tzend_string_release(class_name);\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 878 \"ext/standard/var_unserializer.c\"\nyy25:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy26;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy27;\n \t\tgoto yy18;\n \t}\nyy26:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy27:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy27;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n#line 793 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 914 \"ext/standard/var_unserializer.c\"\nyy32:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy33;\n \tif (yych <= '/') goto yy18;\n \tif (yych <= '9') goto yy34;\n \tgoto yy18;\nyy33:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy34:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '{') goto yy18;\n \t++YYCURSOR;\n#line 769 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t/* use iv() not uiv() in order to check data range */\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\tarray_init_size(rval, elements);\n\tif (elements) {\n\t\t/* we can't convert from packed to hash during unserialization, because\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n \t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n\t\treturn 0;\n \t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 959 \"ext/standard/var_unserializer.c\"\nyy39:\n \tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy40;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n \tgoto yy18;\nyy40:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy41:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n#line 735 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 1014 \"ext/standard/var_unserializer.c\"\nyy46:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy47;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n \tgoto yy18;\nyy47:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy48:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n#line 703 \"ext/standard/var_unserializer.re\"\n \t{\n\tsize_t len, maxlen;\n\tchar *str;\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\tstr = (char*)YYCURSOR;\n \n\tYYCURSOR += len;\n \n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n \t\treturn 0;\n \t}\n \n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n \t\treturn 0;\n \t}\n \n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n \n\tZVAL_STRINGL(rval, str, len);\n \treturn 1;\n }\n#line 1067 \"ext/standard/var_unserializer.c\"\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy57;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy55;\n\t\t\tif (yych <= '.') goto yy60;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy56;\n\t\t} else {\n\t\t\tif (yych != 'N') goto yy18;\n\t\t}\n\t}\n \tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy76;\n \tgoto yy18;\nyy55:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych == '.') goto yy60;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy58;\n\t\tif (yych != 'I') goto yy18;\n\t}\nyy56:\n \tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy72;\n \tgoto yy18;\nyy57:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy60;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy58:\n \t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy70;\n\t\t} else {\n\t\t\tif (yych <= '/') goto yy18;\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy63;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy60:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy61:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n \tyych = *YYCURSOR;\n \tif (yych <= ';') {\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy61;\n \t\tif (yych <= ':') goto yy18;\n \t} else {\n \t\tif (yych <= 'E') {\n \t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n \t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n \t\t\tgoto yy18;\n \t\t}\n \t}\nyy63:\n \t++YYCURSOR;\n#line 694 \"ext/standard/var_unserializer.re\"\n \t{\n #if SIZEOF_ZEND_LONG == 4\n use_double:\n#endif\n\t*p = YYCURSOR;\n \tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n \treturn 1;\n }\n#line 1164 \"ext/standard/var_unserializer.c\"\nyy65:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy66;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy67;\n \t\tgoto yy18;\n \t}\nyy66:\n \tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy69;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy69;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy67:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tif (yych == ';') goto yy63;\n \tgoto yy18;\nyy69:\n \tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n \tgoto yy18;\nyy70:\n \t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy70;\n\t\tif (yych <= ':') goto yy18;\n\t\tgoto yy63;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n \t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n \t\t}\n \t}\nyy72:\n\tyych = *++YYCURSOR;\n\tif (yych != 'F') goto yy18;\nyy73:\n \tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n#line 678 \"ext/standard/var_unserializer.re\"\n \t{\n\t*p = YYCURSOR;\n \n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n\t} else {\n\t\tZVAL_NULL(rval);\n \t}\n \n \treturn 1;\n }\n#line 1239 \"ext/standard/var_unserializer.c\"\nyy76:\n \tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy73;\n \tgoto yy18;\nyy77:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy78;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy79;\n\t\tgoto yy18;\n\t}\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy79:\n \t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy79;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 652 \"ext/standard/var_unserializer.re\"\n \t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n \n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n \t}\n \n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n \n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n \t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n \t\t}\n\t}\n#endif\n \t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n }\n#line 1292 \"ext/standard/var_unserializer.c\"\nyy83:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= '2') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n#line 646 \"ext/standard/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n \treturn 1;\n }\n#line 1306 \"ext/standard/var_unserializer.c\"\nyy87:\n \t++YYCURSOR;\n#line 640 \"ext/standard/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n }\n#line 1315 \"ext/standard/var_unserializer.c\"\nyy89:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy90;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy91;\n\t\tgoto yy18;\n \t}\nyy90:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy91:\n \t++YYCURSOR;\n \tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy91;\n\tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n#line 615 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long id;\n \n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n \n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n \t\treturn 0;\n \t}\n \n\tif (rval_ref == rval) {\n \t\treturn 0;\n \t}\n \n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n \t}\n \n\tZVAL_COPY(rval, rval_ref);\n \n \treturn 1;\n }\n#line 1363 \"ext/standard/var_unserializer.c\"\nyy95:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy97;\n\t\tgoto yy18;\n\t}\n yy96:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\n yy97:\n \t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy97;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 589 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long id;\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n \n\tzval_ptr_dtor(rval);\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n \t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n \t}\n \n \treturn 1;\n }\n#line 1412 \"ext/standard/var_unserializer.c\"\n }\n#line 964 \"ext/standard/var_unserializer.re\"\n \n \n \treturn 0;\n}\n",
        "post_patch": "static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)\n{\n\tconst unsigned char *cursor, *limit, *marker, *start;\n\tzval *rval_ref;\n\n\tlimit = max;\n\tcursor = *p;\n\n\tif (YYCURSOR >= YYLIMIT) {\n\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n \tstart = cursor;\n \n \n#line 576 \"ext/standard/var_unserializer.c\"\n {\n \tYYCTYPE yych;\n \tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t128, 128,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n \tyych = *YYCURSOR;\n \tswitch (yych) {\n \tcase 'C':\n\tcase 'O':\tgoto yy4;\n \tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy6;\n\tcase 'S':\tgoto yy7;\n\tcase 'a':\tgoto yy8;\n\tcase 'b':\tgoto yy9;\n\tcase 'd':\tgoto yy10;\n\tcase 'i':\tgoto yy11;\n \tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy13;\n\tcase 's':\tgoto yy14;\n\tcase '}':\tgoto yy15;\n\tdefault:\tgoto yy2;\n \t}\n yy2:\n\t++YYCURSOR;\n yy3:\n#line 951 \"ext/standard/var_unserializer.re\"\n \t{ return 0; }\n#line 636 \"ext/standard/var_unserializer.c\"\n yy4:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n \tgoto yy3;\n yy5:\n \tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy19;\n \tgoto yy3;\n yy6:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy21;\n \tgoto yy3;\n yy7:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy22;\n \tgoto yy3;\n yy8:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy23;\n \tgoto yy3;\n yy9:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy24;\n \tgoto yy3;\n yy10:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n \tgoto yy3;\n yy11:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy26;\n \tgoto yy3;\n yy12:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy27;\n \tgoto yy3;\n yy13:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy28;\n \tgoto yy3;\n yy14:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy29;\n\tgoto yy3;\nyy15:\n \t++YYCURSOR;\n#line 945 \"ext/standard/var_unserializer.re\"\n \t{\n \t/* this is the case where we have less data than planned */\n \tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n \treturn 0; /* not sure if it should be 0 or 1 here? */\n }\n#line 689 \"ext/standard/var_unserializer.c\"\n yy17:\n \tyych = *++YYCURSOR;\n \tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n \t}\n\tif (yych == '+') goto yy30;\n yy18:\n \tYYCURSOR = YYMARKER;\n \tgoto yy3;\n yy19:\n\t++YYCURSOR;\n#line 629 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n}\n#line 707 \"ext/standard/var_unserializer.c\"\nyy21:\n \tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy33;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy33;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy34;\n\t\tgoto yy18;\n \t}\nyy22:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy36;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy37;\n \tgoto yy18;\nyy23:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy39;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy40;\n\tgoto yy18;\nyy24:\n \tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '1') goto yy42;\n\tgoto yy18;\nyy25:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy43;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy44;\n\t\t\tif (yych <= '.') goto yy45;\n\t\t\tgoto yy18;\n \t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy46;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy48;\n\t\t} else {\n\t\t\tif (yych == 'N') goto yy49;\n\t\t\tgoto yy18;\n \t\t}\n \t}\nyy26:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy50;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy50;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy51;\n\t\tgoto yy18;\n \t}\nyy27:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy53;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy53;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy54;\n\t\tgoto yy18;\n \t}\nyy28:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych == '+') goto yy56;\n\t\tgoto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy56;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy57;\n \t\tgoto yy18;\n \t}\nyy29:\n \tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy59;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy60;\n\tgoto yy18;\nyy30:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tgoto yy18;\nyy31:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n \tif (yych <= '/') goto yy18;\n\tif (yych <= ':') goto yy62;\n\tgoto yy18;\nyy33:\n \tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy34:\n \t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych <= '9') goto yy34;\n\tif (yych == ';') goto yy63;\n \tgoto yy18;\nyy36:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy37:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy37;\n\tif (yych <= ':') goto yy65;\n\tgoto yy18;\nyy39:\n \tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy40:\n \t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy40;\n\tif (yych <= ':') goto yy66;\n\tgoto yy18;\nyy42:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy67;\n\tgoto yy18;\nyy43:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy45;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy46;\n\tgoto yy18;\nyy44:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych != '.') goto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy46;\n\t\tif (yych == 'I') goto yy48;\n\t\tgoto yy18;\n \t}\nyy45:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy69;\n\tgoto yy18;\nyy46:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy69;\n\t\t} else {\n\t\t\tif (yych <= '/') goto yy18;\n\t\t\tif (yych <= '9') goto yy46;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy71;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy73;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy73;\n\t\t\tgoto yy18;\n\t\t}\n \t}\nyy48:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy74;\n\tgoto yy18;\nyy49:\n\tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy75;\n\tgoto yy18;\nyy50:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy51:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy51;\n\tif (yych == ';') goto yy76;\n \tgoto yy18;\nyy53:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy54:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy54;\n\tif (yych <= ':') goto yy78;\n\tgoto yy18;\nyy56:\n \tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy57:\n \t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy57;\n\tif (yych == ';') goto yy79;\n \tgoto yy18;\nyy59:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy60:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy60;\n\tif (yych <= ':') goto yy81;\n\tgoto yy18;\nyy62:\n \tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy82;\n\tgoto yy18;\nyy63:\n \t++YYCURSOR;\n#line 580 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long id;\n \n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n \n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n \t\treturn 0;\n \t}\n \n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n \t\treturn 0;\n \t}\n \n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n\t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n\t}\n \n \treturn 1;\n }\n#line 982 \"ext/standard/var_unserializer.c\"\nyy65:\n \tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy84;\n \tgoto yy18;\nyy66:\n \tyych = *++YYCURSOR;\n\tif (yych == '{') goto yy86;\n \tgoto yy18;\nyy67:\n \t++YYCURSOR;\n#line 635 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 999 \"ext/standard/var_unserializer.c\"\nyy69:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n \tyych = *YYCURSOR;\n \tif (yych <= ';') {\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy69;\n \t\tif (yych <= ':') goto yy18;\n \t} else {\n \t\tif (yych <= 'E') {\n \t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy73;\n \t\t} else {\n\t\t\tif (yych == 'e') goto yy73;\n \t\t\tgoto yy18;\n \t\t}\n \t}\nyy71:\n \t++YYCURSOR;\n#line 683 \"ext/standard/var_unserializer.re\"\n \t{\n #if SIZEOF_ZEND_LONG == 4\n use_double:\n#endif\n\t*p = YYCURSOR;\n \tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n \treturn 1;\n }\n#line 1028 \"ext/standard/var_unserializer.c\"\nyy73:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych == '+') goto yy88;\n\t\tgoto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy88;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy89;\n \t\tgoto yy18;\n \t}\nyy74:\n \tyych = *++YYCURSOR;\n\tif (yych == 'F') goto yy91;\n \tgoto yy18;\nyy75:\n \tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy91;\n \tgoto yy18;\nyy76:\n \t++YYCURSOR;\n#line 641 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n\n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n\t}\n\n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n\t\t\t}\n \t\t} else {\n\t\t\tgoto use_double;\n \t\t}\n \t}\n#endif\n\t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1076 \"ext/standard/var_unserializer.c\"\nyy78:\n \tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy92;\n\tgoto yy18;\nyy79:\n \t++YYCURSOR;\n#line 605 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long id;\n \n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (rval_ref == rval) {\n\t\treturn 0;\n \t}\n \n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\treturn 0;\n\t}\n\n\tZVAL_COPY(rval, rval_ref);\n\n \treturn 1;\n }\n#line 1107 \"ext/standard/var_unserializer.c\"\nyy81:\n \tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy94;\n \tgoto yy18;\nyy82:\n \t++YYCURSOR;\n#line 793 \"ext/standard/var_unserializer.re\"\n \t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\tzend_class_entry *ce;\n\tint incomplete_class = 0;\n \n\tint custom_object = 0;\n\n\tzval user_func;\n\tzval retval;\n\tzval args[1];\n\n    if (!var_hash) return 0;\n\tif (*start == 'C') {\n\t\tcustom_object = 1;\n \t}\n \n\tlen2 = len = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len || len == 0) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n \n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR+1) != ':') {\n\t\t*p = YYCURSOR+1;\n\t\treturn 0;\n\t}\n\n\tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");\n\tif (len3 != len)\n\t{\n\t\t*p = YYCURSOR + len3 - len;\n\t\treturn 0;\n\t}\n\n\tclass_name = zend_string_init(str, len, 0);\n\n\tdo {\n\t\tif(!unserialize_allowed_class(class_name, classes)) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Try to find class directly */\n\t\tBG(serialize_lock)++;\n\t\tce = zend_lookup_class(class_name);\n\t\tif (ce) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\treturn 0;\n \t\t\t}\n\t\t\tbreak;\n \t\t}\n\t\tBG(serialize_lock)--;\n\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Check for unserialize callback */\n\t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Call unserialize callback */\n\t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));\n\n\t\tZVAL_STR_COPY(&args[0], class_name);\n\t\tBG(serialize_lock)++;\n\t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\tzval_ptr_dtor(&user_func);\n\t\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\t\tzval_ptr_dtor(&retval);\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* The callback function may have defined the class */\n\t\tBG(serialize_lock)++;\n\t\tif ((ce = zend_lookup_class(class_name)) == NULL) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t}\n\t\tBG(serialize_lock)--;\n\n\t\tzval_ptr_dtor(&user_func);\n\t\tzval_ptr_dtor(&args[0]);\n\t\tbreak;\n\t} while (1);\n\n \t*p = YYCURSOR;\n\n\tif (custom_object) {\n\t\tint ret;\n\n\t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);\n\n\t\tif (ret && incomplete_class) {\n\t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n\t\t}\n\t\tzend_string_release(class_name);\n\t\treturn ret;\n\t}\n\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n\n\tif (elements < 0) {\n\t   zend_string_release(class_name);\n\t   return 0;\n\t}\n\n\tif (incomplete_class) {\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n\t}\n\tzend_string_release(class_name);\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n }\n#line 1266 \"ext/standard/var_unserializer.c\"\nyy84:\n \t++YYCURSOR;\n#line 724 \"ext/standard/var_unserializer.re\"\n \t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n \t*p = YYCURSOR;\n\n\tZVAL_STR(rval, str);\n \treturn 1;\n }\n#line 1303 \"ext/standard/var_unserializer.c\"\nyy86:\n \t++YYCURSOR;\n#line 758 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long elements = parse_iv(start + 2);\n\t/* use iv() not uiv() in order to check data range */\n \t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\n\tarray_init_size(rval, elements);\n\tif (elements) {\n\t\t/* we can't convert from packed to hash during unserialization, because\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n }\n#line 1330 \"ext/standard/var_unserializer.c\"\nyy88:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych == '+') goto yy96;\n\t\tgoto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy96;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n \t}\nyy89:\n \t++YYCURSOR;\n \tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy89;\n\tif (yych == ';') goto yy71;\n\tgoto yy18;\nyy91:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy97;\n\tgoto yy18;\nyy92:\n \t++YYCURSOR;\n#line 782 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n \n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 1366 \"ext/standard/var_unserializer.c\"\nyy94:\n\t++YYCURSOR;\n#line 692 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tchar *str;\n \n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n \t\treturn 0;\n \t}\n \n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n \t\treturn 0;\n \t}\n \n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n \t}\n \n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n \n\tZVAL_STRINGL(rval, str, len);\n \treturn 1;\n }\n#line 1401 \"ext/standard/var_unserializer.c\"\n yy96:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy89;\n\tgoto yy18;\n yy97:\n \t++YYCURSOR;\n#line 667 \"ext/standard/var_unserializer.re\"\n \t{\n\t*p = YYCURSOR;\n \n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n \t} else {\n\t\tZVAL_NULL(rval);\n \t}\n \n \treturn 1;\n }\n#line 1425 \"ext/standard/var_unserializer.c\"\n }\n#line 953 \"ext/standard/var_unserializer.re\"\n \n \n \treturn 0;\n}\n",
        "post_patch_with_fix": "static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)\n{\n\tconst unsigned char *cursor, *limit, *marker, *start;\n\tzval *rval_ref;\n\n\tlimit = max;\n\tcursor = *p;\n\n\tif (YYCURSOR >= YYLIMIT) {\n\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n \tstart = cursor;\n \n \n//flaw_line_below:\n#line 585 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//#line 576 \"ext/standard/var_unserializer.c\"\n {\n \tYYCTYPE yych;\n \tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t128, 128,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n \tyych = *YYCURSOR;\n \tswitch (yych) {\n \tcase 'C':\n//flaw_line_below:\n\tcase 'O':\tgoto yy13;\n//fix_flaw_line_below:\n//\tcase 'O':\tgoto yy4;\n \tcase 'N':\tgoto yy5;\n//flaw_line_below:\n\tcase 'R':\tgoto yy2;\n//flaw_line_below:\n\tcase 'S':\tgoto yy10;\n//flaw_line_below:\n\tcase 'a':\tgoto yy11;\n//flaw_line_below:\n\tcase 'b':\tgoto yy6;\n//flaw_line_below:\n\tcase 'd':\tgoto yy8;\n//flaw_line_below:\n\tcase 'i':\tgoto yy7;\n//fix_flaw_line_below:\n//\tcase 'R':\tgoto yy6;\n//fix_flaw_line_below:\n//\tcase 'S':\tgoto yy7;\n//fix_flaw_line_below:\n//\tcase 'a':\tgoto yy8;\n//fix_flaw_line_below:\n//\tcase 'b':\tgoto yy9;\n//fix_flaw_line_below:\n//\tcase 'd':\tgoto yy10;\n//fix_flaw_line_below:\n//\tcase 'i':\tgoto yy11;\n \tcase 'o':\tgoto yy12;\n//flaw_line_below:\n\tcase 'r':\tgoto yy4;\n//flaw_line_below:\n\tcase 's':\tgoto yy9;\n//flaw_line_below:\n\tcase '}':\tgoto yy14;\n//flaw_line_below:\n\tdefault:\tgoto yy16;\n//fix_flaw_line_below:\n//\tcase 'r':\tgoto yy13;\n//fix_flaw_line_below:\n//\tcase 's':\tgoto yy14;\n//fix_flaw_line_below:\n//\tcase '}':\tgoto yy15;\n//fix_flaw_line_below:\n//\tdefault:\tgoto yy2;\n \t}\n yy2:\n//flaw_line_below:\n\tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy95;\n//fix_flaw_line_below:\n//\t++YYCURSOR;\n yy3:\n//flaw_line_below:\n#line 962 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 951 \"ext/standard/var_unserializer.re\"\n \t{ return 0; }\n//flaw_line_below:\n#line 646 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//#line 636 \"ext/standard/var_unserializer.c\"\n yy4:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy89;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy17;\n \tgoto yy3;\n yy5:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == ';') goto yy87;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy19;\n \tgoto yy3;\n yy6:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy83;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy21;\n \tgoto yy3;\n yy7:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy77;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy22;\n \tgoto yy3;\n yy8:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy53;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy23;\n \tgoto yy3;\n yy9:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy46;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy24;\n \tgoto yy3;\n yy10:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy39;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy25;\n \tgoto yy3;\n yy11:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy32;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy26;\n \tgoto yy3;\n yy12:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy25;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy27;\n \tgoto yy3;\n yy13:\n \tyych = *(YYMARKER = ++YYCURSOR);\n//flaw_line_below:\n\tif (yych == ':') goto yy17;\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy28;\n \tgoto yy3;\n yy14:\n//fix_flaw_line_below:\n//\tyych = *(YYMARKER = ++YYCURSOR);\n//fix_flaw_line_below:\n//\tif (yych == ':') goto yy29;\n//fix_flaw_line_below:\n//\tgoto yy3;\n//fix_flaw_line_below:\n//yy15:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 956 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 945 \"ext/standard/var_unserializer.re\"\n \t{\n \t/* this is the case where we have less data than planned */\n \tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n \treturn 0; /* not sure if it should be 0 or 1 here? */\n }\n//flaw_line_below:\n#line 695 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy16:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tgoto yy3;\n//fix_flaw_line_below:\n//#line 689 \"ext/standard/var_unserializer.c\"\n yy17:\n \tyych = *++YYCURSOR;\n \tif (yybm[0+yych] & 128) {\n//flaw_line_below:\n\t\tgoto yy20;\n//fix_flaw_line_below:\n//\t\tgoto yy31;\n \t}\n//flaw_line_below:\n\tif (yych == '+') goto yy19;\n//fix_flaw_line_below:\n//\tif (yych == '+') goto yy30;\n yy18:\n \tYYCURSOR = YYMARKER;\n \tgoto yy3;\n yy19:\n//fix_flaw_line_below:\n//\t++YYCURSOR;\n//fix_flaw_line_below:\n//#line 629 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//\t{\n//fix_flaw_line_below:\n//\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tZVAL_NULL(rval);\n//fix_flaw_line_below:\n//\treturn 1;\n//fix_flaw_line_below:\n//}\n//fix_flaw_line_below:\n//#line 707 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy21:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yybm[0+yych] & 128) {\n//flaw_line_below:\n\t\tgoto yy20;\n//fix_flaw_line_below:\n//\tif (yych <= ',') {\n//fix_flaw_line_below:\n//\t\tif (yych == '+') goto yy33;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tif (yych <= '-') goto yy33;\n//fix_flaw_line_below:\n//\t\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy34;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t}\n//fix_flaw_line_below:\n//yy22:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == '+') goto yy36;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy37;\n \tgoto yy18;\n//flaw_line_below:\nyy20:\n//flaw_line_below:\n\t++YYCURSOR;\n//flaw_line_below:\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n//flaw_line_below:\n\tyych = *YYCURSOR;\n//flaw_line_below:\n\tif (yybm[0+yych] & 128) {\n//flaw_line_below:\n\t\tgoto yy20;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//yy23:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == '+') goto yy39;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy40;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy24:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != '\"') goto yy18;\n//flaw_line_below:\n\t++YYCURSOR;\n//flaw_line_below:\n#line 804 \"ext/standard/var_unserializer.re\"\n//flaw_line_below:\n\t{\n//flaw_line_below:\n\tsize_t len, len2, len3, maxlen;\n//flaw_line_below:\n\tzend_long elements;\n//flaw_line_below:\n\tchar *str;\n//flaw_line_below:\n\tzend_string *class_name;\n//flaw_line_below:\n\tzend_class_entry *ce;\n//flaw_line_below:\n\tint incomplete_class = 0;\n//flaw_line_below:\n\n//flaw_line_below:\n\tint custom_object = 0;\n//flaw_line_below:\n\n//flaw_line_below:\n\tzval user_func;\n//flaw_line_below:\n\tzval retval;\n//flaw_line_below:\n\tzval args[1];\n//flaw_line_below:\n\n//flaw_line_below:\n    if (!var_hash) return 0;\n//flaw_line_below:\n\tif (*start == 'C') {\n//flaw_line_below:\n\t\tcustom_object = 1;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tlen2 = len = parse_uiv(start + 2);\n//flaw_line_below:\n\tmaxlen = max - YYCURSOR;\n//flaw_line_below:\n\tif (maxlen < len || len == 0) {\n//flaw_line_below:\n\t\t*p = start + 2;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tstr = (char*)YYCURSOR;\n//flaw_line_below:\n\n//flaw_line_below:\n\tYYCURSOR += len;\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (*(YYCURSOR) != '\"') {\n//flaw_line_below:\n\t\t*p = YYCURSOR;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\tif (*(YYCURSOR+1) != ':') {\n//flaw_line_below:\n\t\t*p = YYCURSOR+1;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");\n//flaw_line_below:\n\tif (len3 != len)\n//flaw_line_below:\n\t{\n//flaw_line_below:\n\t\t*p = YYCURSOR + len3 - len;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tclass_name = zend_string_init(str, len, 0);\n//flaw_line_below:\n\n//flaw_line_below:\n\tdo {\n//flaw_line_below:\n\t\tif(!unserialize_allowed_class(class_name, classes)) {\n//flaw_line_below:\n\t\t\tincomplete_class = 1;\n//flaw_line_below:\n\t\t\tce = PHP_IC_ENTRY;\n//flaw_line_below:\n\t\t\tbreak;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\t\t/* Try to find class directly */\n//flaw_line_below:\n\t\tBG(serialize_lock)++;\n//flaw_line_below:\n\t\tce = zend_lookup_class(class_name);\n//flaw_line_below:\n\t\tif (ce) {\n//flaw_line_below:\n\t\t\tBG(serialize_lock)--;\n//flaw_line_below:\n\t\t\tif (EG(exception)) {\n//flaw_line_below:\n\t\t\t\tzend_string_release(class_name);\n//flaw_line_below:\n\t\t\t\treturn 0;\n//flaw_line_below:\n\t\t\t}\n//flaw_line_below:\n\t\t\tbreak;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t\tBG(serialize_lock)--;\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tif (EG(exception)) {\n//flaw_line_below:\n\t\t\tzend_string_release(class_name);\n//flaw_line_below:\n\t\t\treturn 0;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\t\t/* Check for unserialize callback */\n//flaw_line_below:\n\t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {\n//flaw_line_below:\n\t\t\tincomplete_class = 1;\n//flaw_line_below:\n\t\t\tce = PHP_IC_ENTRY;\n//flaw_line_below:\n\t\t\tbreak;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\t\t/* Call unserialize callback */\n//flaw_line_below:\n\t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tZVAL_STR_COPY(&args[0], class_name);\n//flaw_line_below:\n\t\tBG(serialize_lock)++;\n//flaw_line_below:\n\t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {\n//flaw_line_below:\n\t\t\tBG(serialize_lock)--;\n//flaw_line_below:\n\t\t\tif (EG(exception)) {\n//flaw_line_below:\n\t\t\t\tzend_string_release(class_name);\n//flaw_line_below:\n\t\t\t\tzval_ptr_dtor(&user_func);\n//flaw_line_below:\n\t\t\t\tzval_ptr_dtor(&args[0]);\n//flaw_line_below:\n\t\t\t\treturn 0;\n//flaw_line_below:\n\t\t\t}\n//flaw_line_below:\n\t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));\n//flaw_line_below:\n\t\t\tincomplete_class = 1;\n//flaw_line_below:\n\t\t\tce = PHP_IC_ENTRY;\n//flaw_line_below:\n\t\t\tzval_ptr_dtor(&user_func);\n//flaw_line_below:\n\t\t\tzval_ptr_dtor(&args[0]);\n//flaw_line_below:\n\t\t\tbreak;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t\tBG(serialize_lock)--;\n//flaw_line_below:\n\t\tzval_ptr_dtor(&retval);\n//flaw_line_below:\n\t\tif (EG(exception)) {\n//flaw_line_below:\n\t\t\tzend_string_release(class_name);\n//flaw_line_below:\n\t\t\tzval_ptr_dtor(&user_func);\n//flaw_line_below:\n\t\t\tzval_ptr_dtor(&args[0]);\n//flaw_line_below:\n\t\t\treturn 0;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\t\t/* The callback function may have defined the class */\n//flaw_line_below:\n\t\tBG(serialize_lock)++;\n//flaw_line_below:\n\t\tif ((ce = zend_lookup_class(class_name)) == NULL) {\n//flaw_line_below:\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));\n//flaw_line_below:\n\t\t\tincomplete_class = 1;\n//flaw_line_below:\n\t\t\tce = PHP_IC_ENTRY;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '1') goto yy42;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy25:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= '/') {\n//fix_flaw_line_below:\n//\t\tif (yych <= ',') {\n//fix_flaw_line_below:\n//\t\t\tif (yych == '+') goto yy43;\n//fix_flaw_line_below:\n//\t\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\tif (yych <= '-') goto yy44;\n//fix_flaw_line_below:\n//\t\t\tif (yych <= '.') goto yy45;\n//fix_flaw_line_below:\n//\t\t\tgoto yy18;\n \t\t}\n//flaw_line_below:\n\t\tBG(serialize_lock)--;\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tzval_ptr_dtor(&user_func);\n//flaw_line_below:\n\t\tzval_ptr_dtor(&args[0]);\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\t} while (1);\n//flaw_line_below:\n\n//flaw_line_below:\n\t*p = YYCURSOR;\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (custom_object) {\n//flaw_line_below:\n\t\tint ret;\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tif (ret && incomplete_class) {\n//flaw_line_below:\n\t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tif (yych <= 'I') {\n//fix_flaw_line_below:\n//\t\t\tif (yych <= '9') goto yy46;\n//fix_flaw_line_below:\n//\t\t\tif (yych <= 'H') goto yy18;\n//fix_flaw_line_below:\n//\t\t\tgoto yy48;\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\tif (yych == 'N') goto yy49;\n//fix_flaw_line_below:\n//\t\t\tgoto yy18;\n \t\t}\n//flaw_line_below:\n\t\tzend_string_release(class_name);\n//flaw_line_below:\n\t\treturn ret;\n \t}\n//flaw_line_below:\n\n//flaw_line_below:\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (elements < 0) {\n//flaw_line_below:\n\t   zend_string_release(class_name);\n//flaw_line_below:\n\t   return 0;\n//fix_flaw_line_below:\n//yy26:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= ',') {\n//fix_flaw_line_below:\n//\t\tif (yych == '+') goto yy50;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tif (yych <= '-') goto yy50;\n//fix_flaw_line_below:\n//\t\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy51;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (incomplete_class) {\n//flaw_line_below:\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n//fix_flaw_line_below:\n//yy27:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= ',') {\n//fix_flaw_line_below:\n//\t\tif (yych == '+') goto yy53;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tif (yych <= '-') goto yy53;\n//fix_flaw_line_below:\n//\t\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy54;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t}\n//flaw_line_below:\n\tzend_string_release(class_name);\n//flaw_line_below:\n\n//flaw_line_below:\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n//flaw_line_below:\n}\n//flaw_line_below:\n#line 878 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy25:\n//fix_flaw_line_below:\n//yy28:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n//flaw_line_below:\n\t\tif (yych != '+') goto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych == '+') goto yy56;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t} else {\n//flaw_line_below:\n\t\tif (yych <= '-') goto yy26;\n//fix_flaw_line_below:\n//\t\tif (yych <= '-') goto yy56;\n \t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy27;\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy57;\n \t\tgoto yy18;\n \t}\n//flaw_line_below:\nyy26:\n//fix_flaw_line_below:\n//yy29:\n \tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == '+') goto yy59;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy27:\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy60;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy30:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yybm[0+yych] & 128) {\n//fix_flaw_line_below:\n//\t\tgoto yy31;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy31:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yybm[0+yych] & 128) {\n//fix_flaw_line_below:\n//\t\tgoto yy31;\n//fix_flaw_line_below:\n//\t}\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy27;\n//flaw_line_below:\n\tif (yych >= ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= ':') goto yy62;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy33:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != '\"') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych >= ':') goto yy18;\n//fix_flaw_line_below:\n//yy34:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 793 \"ext/standard/var_unserializer.re\"\n//flaw_line_below:\n\t{\n//flaw_line_below:\n\tzend_long elements;\n//flaw_line_below:\n    if (!var_hash) return 0;\n//flaw_line_below:\n\n//flaw_line_below:\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n//flaw_line_below:\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n//flaw_line_below:\n}\n//flaw_line_below:\n#line 914 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy32:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == '+') goto yy33;\n//fix_flaw_line_below:\n//\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n//fix_flaw_line_below:\n//\tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych <= '9') goto yy34;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy63;\n \tgoto yy18;\n//flaw_line_below:\nyy33:\n//fix_flaw_line_below:\n//yy36:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy34:\n//fix_flaw_line_below:\n//yy37:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy34;\n//flaw_line_below:\n\tif (yych >= ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy37;\n//fix_flaw_line_below:\n//\tif (yych <= ':') goto yy65;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy39:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != '{') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych >= ':') goto yy18;\n//fix_flaw_line_below:\n//yy40:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 769 \"ext/standard/var_unserializer.re\"\n//flaw_line_below:\n\t{\n//flaw_line_below:\n\tzend_long elements = parse_iv(start + 2);\n//flaw_line_below:\n\t/* use iv() not uiv() in order to check data range */\n//flaw_line_below:\n\t*p = YYCURSOR;\n//flaw_line_below:\n    if (!var_hash) return 0;\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tarray_init_size(rval, elements);\n//flaw_line_below:\n\tif (elements) {\n//flaw_line_below:\n\t\t/* we can't convert from packed to hash during unserialization, because\n//flaw_line_below:\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n//flaw_line_below:\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n//fix_flaw_line_below:\n//\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n//fix_flaw_line_below:\n//\tyych = *YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy40;\n//fix_flaw_line_below:\n//\tif (yych <= ':') goto yy66;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy42:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy67;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy43:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == '.') goto yy45;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy46;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy44:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= '/') {\n//fix_flaw_line_below:\n//\t\tif (yych != '.') goto yy18;\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy46;\n//fix_flaw_line_below:\n//\t\tif (yych == 'I') goto yy48;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n//flaw_line_below:\n\t\treturn 0;\n//fix_flaw_line_below:\n//yy45:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy69;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy46:\n//fix_flaw_line_below:\n//\t++YYCURSOR;\n//fix_flaw_line_below:\n//\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n//fix_flaw_line_below:\n//\tyych = *YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= ':') {\n//fix_flaw_line_below:\n//\t\tif (yych <= '.') {\n//fix_flaw_line_below:\n//\t\t\tif (yych <= '-') goto yy18;\n//fix_flaw_line_below:\n//\t\t\tgoto yy69;\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\t\t\tif (yych <= '9') goto yy46;\n//fix_flaw_line_below:\n//\t\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tif (yych <= 'E') {\n//fix_flaw_line_below:\n//\t\t\tif (yych <= ';') goto yy71;\n//fix_flaw_line_below:\n//\t\t\tif (yych <= 'D') goto yy18;\n//fix_flaw_line_below:\n//\t\t\tgoto yy73;\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\tif (yych == 'e') goto yy73;\n//fix_flaw_line_below:\n//\t\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t\t}\n \t}\n//flaw_line_below:\n\n//flaw_line_below:\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n//flaw_line_below:\n}\n//flaw_line_below:\n#line 959 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy39:\n//fix_flaw_line_below:\n//yy48:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == 'N') goto yy74;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy49:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == 'A') goto yy75;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy50:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == '+') goto yy40;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy41;\n//fix_flaw_line_below:\n//\tif (yych >= ':') goto yy18;\n//fix_flaw_line_below:\n//yy51:\n//fix_flaw_line_below:\n//\t++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n//fix_flaw_line_below:\n//\tyych = *YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy51;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy76;\n \tgoto yy18;\n//flaw_line_below:\nyy40:\n//fix_flaw_line_below:\n//yy53:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy41:\n//fix_flaw_line_below:\n//yy54:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy41;\n//flaw_line_below:\n\tif (yych >= ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy54;\n//fix_flaw_line_below:\n//\tif (yych <= ':') goto yy78;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy56:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != '\"') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '/') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych >= ':') goto yy18;\n//fix_flaw_line_below:\n//yy57:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 735 \"ext/standard/var_unserializer.re\"\n//flaw_line_below:\n\t{\n//flaw_line_below:\n\tsize_t len, maxlen;\n//flaw_line_below:\n\tzend_string *str;\n//flaw_line_below:\n\n//flaw_line_below:\n\tlen = parse_uiv(start + 2);\n//flaw_line_below:\n\tmaxlen = max - YYCURSOR;\n//flaw_line_below:\n\tif (maxlen < len) {\n//flaw_line_below:\n\t\t*p = start + 2;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (*(YYCURSOR) != '\"') {\n//flaw_line_below:\n\t\tzend_string_free(str);\n//flaw_line_below:\n\t\t*p = YYCURSOR;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (*(YYCURSOR + 1) != ';') {\n//flaw_line_below:\n\t\tefree(str);\n//flaw_line_below:\n\t\t*p = YYCURSOR + 1;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tYYCURSOR += 2;\n//flaw_line_below:\n\t*p = YYCURSOR;\n//flaw_line_below:\n\n//flaw_line_below:\n\tZVAL_STR(rval, str);\n//flaw_line_below:\n\treturn 1;\n//flaw_line_below:\n}\n//flaw_line_below:\n#line 1014 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy46:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == '+') goto yy47;\n//fix_flaw_line_below:\n//\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n//fix_flaw_line_below:\n//\tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy48;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy57;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy79;\n \tgoto yy18;\n//flaw_line_below:\nyy47:\n//fix_flaw_line_below:\n//yy59:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy48:\n//fix_flaw_line_below:\n//yy60:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy48;\n//flaw_line_below:\n\tif (yych >= ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy60;\n//fix_flaw_line_below:\n//\tif (yych <= ':') goto yy81;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy62:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != '\"') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych == '\"') goto yy82;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy63:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 703 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 580 \"ext/standard/var_unserializer.re\"\n \t{\n//flaw_line_below:\n\tsize_t len, maxlen;\n//flaw_line_below:\n\tchar *str;\n//flaw_line_below:\n\n//flaw_line_below:\n\tlen = parse_uiv(start + 2);\n//flaw_line_below:\n\tmaxlen = max - YYCURSOR;\n//flaw_line_below:\n\tif (maxlen < len) {\n//flaw_line_below:\n\t\t*p = start + 2;\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tstr = (char*)YYCURSOR;\n//fix_flaw_line_below:\n//\tzend_long id;\n \n//flaw_line_below:\n\tYYCURSOR += len;\n//fix_flaw_line_below:\n// \t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tif (!var_hash) return 0;\n \n//flaw_line_below:\n\tif (*(YYCURSOR) != '\"') {\n//flaw_line_below:\n\t\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tid = parse_iv(start + 2) - 1;\n//fix_flaw_line_below:\n//\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n \t\treturn 0;\n \t}\n \n//flaw_line_below:\n\tif (*(YYCURSOR + 1) != ';') {\n//flaw_line_below:\n\t\t*p = YYCURSOR + 1;\n//fix_flaw_line_below:\n//\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n \t\treturn 0;\n \t}\n \n//flaw_line_below:\n\tYYCURSOR += 2;\n//flaw_line_below:\n\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tif (Z_ISREF_P(rval_ref)) {\n//fix_flaw_line_below:\n//\t\tZVAL_COPY(rval, rval_ref);\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n//fix_flaw_line_below:\n//\t\tZVAL_COPY(rval, rval_ref);\n//fix_flaw_line_below:\n//\t}\n \n//flaw_line_below:\n\tZVAL_STRINGL(rval, str, len);\n \treturn 1;\n }\n//flaw_line_below:\n#line 1067 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy53:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') {\n//flaw_line_below:\n\t\tif (yych <= ',') {\n//flaw_line_below:\n\t\t\tif (yych == '+') goto yy57;\n//flaw_line_below:\n\t\t\tgoto yy18;\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tif (yych <= '-') goto yy55;\n//flaw_line_below:\n\t\t\tif (yych <= '.') goto yy60;\n//flaw_line_below:\n\t\t\tgoto yy18;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= 'I') {\n//flaw_line_below:\n\t\t\tif (yych <= '9') goto yy58;\n//flaw_line_below:\n\t\t\tif (yych <= 'H') goto yy18;\n//flaw_line_below:\n\t\t\tgoto yy56;\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tif (yych != 'N') goto yy18;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//#line 982 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy65:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == 'A') goto yy76;\n//fix_flaw_line_below:\n//\tif (yych == '\"') goto yy84;\n \tgoto yy18;\n//flaw_line_below:\nyy55:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') {\n//flaw_line_below:\n\t\tif (yych == '.') goto yy60;\n//flaw_line_below:\n\t\tgoto yy18;\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy58;\n//flaw_line_below:\n\t\tif (yych != 'I') goto yy18;\n//flaw_line_below:\n\t}\n//flaw_line_below:\nyy56:\n//fix_flaw_line_below:\n//yy66:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == 'N') goto yy72;\n//fix_flaw_line_below:\n//\tif (yych == '{') goto yy86;\n \tgoto yy18;\n//flaw_line_below:\nyy57:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == '.') goto yy60;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy58:\n//fix_flaw_line_below:\n//yy67:\n \t++YYCURSOR;\n//flaw_line_below:\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n//flaw_line_below:\n\tyych = *YYCURSOR;\n//flaw_line_below:\n\tif (yych <= ':') {\n//flaw_line_below:\n\t\tif (yych <= '.') {\n//flaw_line_below:\n\t\t\tif (yych <= '-') goto yy18;\n//flaw_line_below:\n\t\t\tgoto yy70;\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\t\tif (yych <= '9') goto yy58;\n//flaw_line_below:\n\t\t\tgoto yy18;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= 'E') {\n//flaw_line_below:\n\t\t\tif (yych <= ';') goto yy63;\n//flaw_line_below:\n\t\t\tif (yych <= 'D') goto yy18;\n//flaw_line_below:\n\t\t\tgoto yy65;\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tif (yych == 'e') goto yy65;\n//flaw_line_below:\n\t\t\tgoto yy18;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t}\n//flaw_line_below:\nyy60:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy61:\n//fix_flaw_line_below:\n//#line 635 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//\t{\n//fix_flaw_line_below:\n//\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tZVAL_BOOL(rval, parse_iv(start + 2));\n//fix_flaw_line_below:\n//\treturn 1;\n//fix_flaw_line_below:\n//}\n//fix_flaw_line_below:\n//#line 999 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy69:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n \tyych = *YYCURSOR;\n \tif (yych <= ';') {\n \t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy61;\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy69;\n \t\tif (yych <= ':') goto yy18;\n \t} else {\n \t\tif (yych <= 'E') {\n \t\t\tif (yych <= 'D') goto yy18;\n//flaw_line_below:\n\t\t\tgoto yy65;\n//fix_flaw_line_below:\n//\t\t\tgoto yy73;\n \t\t} else {\n//flaw_line_below:\n\t\t\tif (yych == 'e') goto yy65;\n//fix_flaw_line_below:\n//\t\t\tif (yych == 'e') goto yy73;\n \t\t\tgoto yy18;\n \t\t}\n \t}\n//flaw_line_below:\nyy63:\n//fix_flaw_line_below:\n//yy71:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 694 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 683 \"ext/standard/var_unserializer.re\"\n \t{\n #if SIZEOF_ZEND_LONG == 4\n use_double:\n#endif\n\t*p = YYCURSOR;\n \tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n \treturn 1;\n }\n//flaw_line_below:\n#line 1164 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy65:\n//fix_flaw_line_below:\n//#line 1028 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy73:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n//flaw_line_below:\n\t\tif (yych != '+') goto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych == '+') goto yy88;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t} else {\n//flaw_line_below:\n\t\tif (yych <= '-') goto yy66;\n//fix_flaw_line_below:\n//\t\tif (yych <= '-') goto yy88;\n \t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy67;\n//fix_flaw_line_below:\n//\t\tif (yych <= '9') goto yy89;\n \t\tgoto yy18;\n \t}\n//flaw_line_below:\nyy66:\n//fix_flaw_line_below:\n//yy74:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= ',') {\n//flaw_line_below:\n\t\tif (yych == '+') goto yy69;\n//flaw_line_below:\n\t\tgoto yy18;\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= '-') goto yy69;\n//flaw_line_below:\n\t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych >= ':') goto yy18;\n//flaw_line_below:\n\t}\n//flaw_line_below:\nyy67:\n//flaw_line_below:\n\t++YYCURSOR;\n//flaw_line_below:\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n//flaw_line_below:\n\tyych = *YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy67;\n//flaw_line_below:\n\tif (yych == ';') goto yy63;\n//fix_flaw_line_below:\n//\tif (yych == 'F') goto yy91;\n \tgoto yy18;\n//flaw_line_below:\nyy69:\n//fix_flaw_line_below:\n//yy75:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy67;\n//fix_flaw_line_below:\n//\tif (yych == 'N') goto yy91;\n \tgoto yy18;\n//flaw_line_below:\nyy70:\n//fix_flaw_line_below:\n//yy76:\n \t++YYCURSOR;\n//flaw_line_below:\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n//flaw_line_below:\n\tyych = *YYCURSOR;\n//flaw_line_below:\n\tif (yych <= ';') {\n//flaw_line_below:\n\t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy70;\n//flaw_line_below:\n\t\tif (yych <= ':') goto yy18;\n//flaw_line_below:\n\t\tgoto yy63;\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= 'E') {\n//flaw_line_below:\n\t\t\tif (yych <= 'D') goto yy18;\n//flaw_line_below:\n\t\t\tgoto yy65;\n//fix_flaw_line_below:\n//#line 641 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//\t{\n//fix_flaw_line_below:\n//#if SIZEOF_ZEND_LONG == 4\n//fix_flaw_line_below:\n//\tint digits = YYCURSOR - start - 3;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (start[2] == '-' || start[2] == '+') {\n//fix_flaw_line_below:\n//\t\tdigits--;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n//fix_flaw_line_below:\n//\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n//fix_flaw_line_below:\n//\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n//fix_flaw_line_below:\n//\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n//fix_flaw_line_below:\n//\t\t\t\tgoto use_double;\n//fix_flaw_line_below:\n//\t\t\t}\n \t\t} else {\n//flaw_line_below:\n\t\t\tif (yych == 'e') goto yy65;\n//flaw_line_below:\n\t\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t\t\tgoto use_double;\n \t\t}\n \t}\n//flaw_line_below:\nyy72:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != 'F') goto yy18;\n//flaw_line_below:\nyy73:\n//fix_flaw_line_below:\n//#endif\n//fix_flaw_line_below:\n//\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tZVAL_LONG(rval, parse_iv(start + 2));\n//fix_flaw_line_below:\n//\treturn 1;\n//fix_flaw_line_below:\n//}\n//fix_flaw_line_below:\n//#line 1076 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy78:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych == '\"') goto yy92;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy79:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 678 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 605 \"ext/standard/var_unserializer.re\"\n \t{\n//flaw_line_below:\n\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tzend_long id;\n \n//flaw_line_below:\n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n//flaw_line_below:\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n//flaw_line_below:\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n//flaw_line_below:\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n//flaw_line_below:\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n//flaw_line_below:\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tZVAL_NULL(rval);\n//fix_flaw_line_below:\n// \t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\tif (!var_hash) return 0;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tid = parse_iv(start + 2) - 1;\n//fix_flaw_line_below:\n//\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (rval_ref == rval) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n \t}\n \n//fix_flaw_line_below:\n//\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tZVAL_COPY(rval, rval_ref);\n//fix_flaw_line_below:\n//\n \treturn 1;\n }\n//flaw_line_below:\n#line 1239 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy76:\n//fix_flaw_line_below:\n//#line 1107 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy81:\n \tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych == 'N') goto yy73;\n//fix_flaw_line_below:\n//\tif (yych == '\"') goto yy94;\n \tgoto yy18;\n//flaw_line_below:\nyy77:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= ',') {\n//flaw_line_below:\n\t\tif (yych != '+') goto yy18;\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= '-') goto yy78;\n//flaw_line_below:\n\t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy79;\n//flaw_line_below:\n\t\tgoto yy18;\n//flaw_line_below:\n\t}\n//flaw_line_below:\nyy78:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy79:\n//fix_flaw_line_below:\n//yy82:\n \t++YYCURSOR;\n//flaw_line_below:\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n//flaw_line_below:\n\tyych = *YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy79;\n//flaw_line_below:\n\tif (yych != ';') goto yy18;\n//flaw_line_below:\n\t++YYCURSOR;\n//flaw_line_below:\n#line 652 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 793 \"ext/standard/var_unserializer.re\"\n \t{\n//flaw_line_below:\n#if SIZEOF_ZEND_LONG == 4\n//flaw_line_below:\n\tint digits = YYCURSOR - start - 3;\n//fix_flaw_line_below:\n//\tsize_t len, len2, len3, maxlen;\n//fix_flaw_line_below:\n//\tzend_long elements;\n//fix_flaw_line_below:\n//\tchar *str;\n//fix_flaw_line_below:\n//\tzend_string *class_name;\n//fix_flaw_line_below:\n//\tzend_class_entry *ce;\n//fix_flaw_line_below:\n//\tint incomplete_class = 0;\n \n//flaw_line_below:\n\tif (start[2] == '-' || start[2] == '+') {\n//flaw_line_below:\n\t\tdigits--;\n//fix_flaw_line_below:\n//\tint custom_object = 0;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tzval user_func;\n//fix_flaw_line_below:\n//\tzval retval;\n//fix_flaw_line_below:\n//\tzval args[1];\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    if (!var_hash) return 0;\n//fix_flaw_line_below:\n//\tif (*start == 'C') {\n//fix_flaw_line_below:\n//\t\tcustom_object = 1;\n \t}\n \n//flaw_line_below:\n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n//flaw_line_below:\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n//flaw_line_below:\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n//flaw_line_below:\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n//fix_flaw_line_below:\n//\tlen2 = len = parse_uiv(start + 2);\n//fix_flaw_line_below:\n//\tmaxlen = max - YYCURSOR;\n//fix_flaw_line_below:\n//\tif (maxlen < len || len == 0) {\n//fix_flaw_line_below:\n//\t\t*p = start + 2;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n \n//flaw_line_below:\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n//flaw_line_below:\n\t\t\t\tgoto use_double;\n//fix_flaw_line_below:\n//\tstr = (char*)YYCURSOR;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tYYCURSOR += len;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (*(YYCURSOR) != '\"') {\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\tif (*(YYCURSOR+1) != ':') {\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR+1;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");\n//fix_flaw_line_below:\n//\tif (len3 != len)\n//fix_flaw_line_below:\n//\t{\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR + len3 - len;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tclass_name = zend_string_init(str, len, 0);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tdo {\n//fix_flaw_line_below:\n//\t\tif(!unserialize_allowed_class(class_name, classes)) {\n//fix_flaw_line_below:\n//\t\t\tincomplete_class = 1;\n//fix_flaw_line_below:\n//\t\t\tce = PHP_IC_ENTRY;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* Try to find class directly */\n//fix_flaw_line_below:\n//\t\tBG(serialize_lock)++;\n//fix_flaw_line_below:\n//\t\tce = zend_lookup_class(class_name);\n//fix_flaw_line_below:\n//\t\tif (ce) {\n//fix_flaw_line_below:\n//\t\t\tBG(serialize_lock)--;\n//fix_flaw_line_below:\n//\t\t\tif (EG(exception)) {\n//fix_flaw_line_below:\n//\t\t\t\tzend_string_release(class_name);\n//fix_flaw_line_below:\n//\t\t\t\treturn 0;\n \t\t\t}\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tgoto use_double;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n \t\t}\n//flaw_line_below:\n\t}\n//flaw_line_below:\n#endif\n//fix_flaw_line_below:\n//\t\tBG(serialize_lock)--;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (EG(exception)) {\n//fix_flaw_line_below:\n//\t\t\tzend_string_release(class_name);\n//fix_flaw_line_below:\n//\t\t\treturn 0;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* Check for unserialize callback */\n//fix_flaw_line_below:\n//\t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {\n//fix_flaw_line_below:\n//\t\t\tincomplete_class = 1;\n//fix_flaw_line_below:\n//\t\t\tce = PHP_IC_ENTRY;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* Call unserialize callback */\n//fix_flaw_line_below:\n//\t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tZVAL_STR_COPY(&args[0], class_name);\n//fix_flaw_line_below:\n//\t\tBG(serialize_lock)++;\n//fix_flaw_line_below:\n//\t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {\n//fix_flaw_line_below:\n//\t\t\tBG(serialize_lock)--;\n//fix_flaw_line_below:\n//\t\t\tif (EG(exception)) {\n//fix_flaw_line_below:\n//\t\t\t\tzend_string_release(class_name);\n//fix_flaw_line_below:\n//\t\t\t\tzval_ptr_dtor(&user_func);\n//fix_flaw_line_below:\n//\t\t\t\tzval_ptr_dtor(&args[0]);\n//fix_flaw_line_below:\n//\t\t\t\treturn 0;\n//fix_flaw_line_below:\n//\t\t\t}\n//fix_flaw_line_below:\n//\t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));\n//fix_flaw_line_below:\n//\t\t\tincomplete_class = 1;\n//fix_flaw_line_below:\n//\t\t\tce = PHP_IC_ENTRY;\n//fix_flaw_line_below:\n//\t\t\tzval_ptr_dtor(&user_func);\n//fix_flaw_line_below:\n//\t\t\tzval_ptr_dtor(&args[0]);\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tBG(serialize_lock)--;\n//fix_flaw_line_below:\n//\t\tzval_ptr_dtor(&retval);\n//fix_flaw_line_below:\n//\t\tif (EG(exception)) {\n//fix_flaw_line_below:\n//\t\t\tzend_string_release(class_name);\n//fix_flaw_line_below:\n//\t\t\tzval_ptr_dtor(&user_func);\n//fix_flaw_line_below:\n//\t\t\tzval_ptr_dtor(&args[0]);\n//fix_flaw_line_below:\n//\t\t\treturn 0;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* The callback function may have defined the class */\n//fix_flaw_line_below:\n//\t\tBG(serialize_lock)++;\n//fix_flaw_line_below:\n//\t\tif ((ce = zend_lookup_class(class_name)) == NULL) {\n//fix_flaw_line_below:\n//\t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));\n//fix_flaw_line_below:\n//\t\t\tincomplete_class = 1;\n//fix_flaw_line_below:\n//\t\t\tce = PHP_IC_ENTRY;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tBG(serialize_lock)--;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tzval_ptr_dtor(&user_func);\n//fix_flaw_line_below:\n//\t\tzval_ptr_dtor(&args[0]);\n//fix_flaw_line_below:\n//\t\tbreak;\n//fix_flaw_line_below:\n//\t} while (1);\n//fix_flaw_line_below:\n//\n \t*p = YYCURSOR;\n//flaw_line_below:\n\tZVAL_LONG(rval, parse_iv(start + 2));\n//flaw_line_below:\n\treturn 1;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (custom_object) {\n//fix_flaw_line_below:\n//\t\tint ret;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (ret && incomplete_class) {\n//fix_flaw_line_below:\n//\t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tzend_string_release(class_name);\n//fix_flaw_line_below:\n//\t\treturn ret;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (elements < 0) {\n//fix_flaw_line_below:\n//\t   zend_string_release(class_name);\n//fix_flaw_line_below:\n//\t   return 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (incomplete_class) {\n//fix_flaw_line_below:\n//\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\tzend_string_release(class_name);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n }\n//flaw_line_below:\n#line 1292 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy83:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= '2') goto yy18;\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych != ';') goto yy18;\n//fix_flaw_line_below:\n//#line 1266 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy84:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 646 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 724 \"ext/standard/var_unserializer.re\"\n \t{\n//fix_flaw_line_below:\n//\tsize_t len, maxlen;\n//fix_flaw_line_below:\n//\tzend_string *str;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tlen = parse_uiv(start + 2);\n//fix_flaw_line_below:\n//\tmaxlen = max - YYCURSOR;\n//fix_flaw_line_below:\n//\tif (maxlen < len) {\n//fix_flaw_line_below:\n//\t\t*p = start + 2;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (*(YYCURSOR) != '\"') {\n//fix_flaw_line_below:\n//\t\tzend_string_free(str);\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (*(YYCURSOR + 1) != ';') {\n//fix_flaw_line_below:\n//\t\tefree(str);\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR + 1;\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tYYCURSOR += 2;\n \t*p = YYCURSOR;\n//flaw_line_below:\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tZVAL_STR(rval, str);\n \treturn 1;\n }\n//flaw_line_below:\n#line 1306 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy87:\n//fix_flaw_line_below:\n//#line 1303 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy86:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 640 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 758 \"ext/standard/var_unserializer.re\"\n \t{\n//fix_flaw_line_below:\n//\tzend_long elements = parse_iv(start + 2);\n//fix_flaw_line_below:\n//\t/* use iv() not uiv() in order to check data range */\n \t*p = YYCURSOR;\n//flaw_line_below:\n\tZVAL_NULL(rval);\n//flaw_line_below:\n\treturn 1;\n//fix_flaw_line_below:\n//    if (!var_hash) return 0;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tarray_init_size(rval, elements);\n//fix_flaw_line_below:\n//\tif (elements) {\n//fix_flaw_line_below:\n//\t\t/* we can't convert from packed to hash during unserialization, because\n//fix_flaw_line_below:\n//\t\t   reference to some zvals might be keept in var_hash (to support references) */\n//fix_flaw_line_below:\n//\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n }\n//flaw_line_below:\n#line 1315 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy89:\n//fix_flaw_line_below:\n//#line 1330 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy88:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n//flaw_line_below:\n\t\tif (yych != '+') goto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych == '+') goto yy96;\n//fix_flaw_line_below:\n//\t\tgoto yy18;\n \t} else {\n//flaw_line_below:\n\t\tif (yych <= '-') goto yy90;\n//fix_flaw_line_below:\n//\t\tif (yych <= '-') goto yy96;\n \t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy91;\n//flaw_line_below:\n\t\tgoto yy18;\n//fix_flaw_line_below:\n//\t\tif (yych >= ':') goto yy18;\n \t}\n//flaw_line_below:\nyy90:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ':') goto yy18;\n//flaw_line_below:\nyy91:\n//fix_flaw_line_below:\n//yy89:\n \t++YYCURSOR;\n \tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy91;\n//flaw_line_below:\n\tif (yych != ';') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy89;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy71;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy91:\n//fix_flaw_line_below:\n//\tyych = *++YYCURSOR;\n//fix_flaw_line_below:\n//\tif (yych == ';') goto yy97;\n//fix_flaw_line_below:\n//\tgoto yy18;\n//fix_flaw_line_below:\n//yy92:\n \t++YYCURSOR;\n//flaw_line_below:\n#line 615 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 782 \"ext/standard/var_unserializer.re\"\n \t{\n//flaw_line_below:\n\tzend_long id;\n//fix_flaw_line_below:\n//\tzend_long elements;\n//fix_flaw_line_below:\n//    if (!var_hash) return 0;\n \n//flaw_line_below:\n \t*p = YYCURSOR;\n//flaw_line_below:\n\tif (!var_hash) return 0;\n//fix_flaw_line_below:\n//\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n//fix_flaw_line_below:\n//\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n//fix_flaw_line_below:\n//}\n//fix_flaw_line_below:\n//#line 1366 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//yy94:\n//fix_flaw_line_below:\n//\t++YYCURSOR;\n//fix_flaw_line_below:\n//#line 692 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//\t{\n//fix_flaw_line_below:\n//\tsize_t len, maxlen;\n//fix_flaw_line_below:\n//\tchar *str;\n \n//flaw_line_below:\n\tid = parse_iv(start + 2) - 1;\n//flaw_line_below:\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n//fix_flaw_line_below:\n//\tlen = parse_uiv(start + 2);\n//fix_flaw_line_below:\n//\tmaxlen = max - YYCURSOR;\n//fix_flaw_line_below:\n//\tif (maxlen < len) {\n//fix_flaw_line_below:\n//\t\t*p = start + 2;\n \t\treturn 0;\n \t}\n \n//flaw_line_below:\n\tif (rval_ref == rval) {\n//fix_flaw_line_below:\n//\tstr = (char*)YYCURSOR;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tYYCURSOR += len;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (*(YYCURSOR) != '\"') {\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR;\n \t\treturn 0;\n \t}\n \n//flaw_line_below:\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n//flaw_line_below:\n\t\tZVAL_UNDEF(rval);\n//flaw_line_below:\n\t\treturn 1;\n//fix_flaw_line_below:\n//\tif (*(YYCURSOR + 1) != ';') {\n//fix_flaw_line_below:\n//\t\t*p = YYCURSOR + 1;\n//fix_flaw_line_below:\n//\t\treturn 0;\n \t}\n \n//flaw_line_below:\n\tZVAL_COPY(rval, rval_ref);\n//fix_flaw_line_below:\n//\tYYCURSOR += 2;\n//fix_flaw_line_below:\n//\t*p = YYCURSOR;\n \n//fix_flaw_line_below:\n//\tZVAL_STRINGL(rval, str, len);\n \treturn 1;\n }\n//flaw_line_below:\n#line 1363 \"ext/standard/var_unserializer.c\"\n//flaw_line_below:\nyy95:\n//flaw_line_below:\n\tyych = *++YYCURSOR;\n//flaw_line_below:\n\tif (yych <= ',') {\n//flaw_line_below:\n\t\tif (yych != '+') goto yy18;\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tif (yych <= '-') goto yy96;\n//flaw_line_below:\n\t\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\t\tif (yych <= '9') goto yy97;\n//flaw_line_below:\n\t\tgoto yy18;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//#line 1401 \"ext/standard/var_unserializer.c\"\n yy96:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych >= ':') goto yy18;\n//fix_flaw_line_below:\n//\tif (yych <= '9') goto yy89;\n//fix_flaw_line_below:\n//\tgoto yy18;\n yy97:\n \t++YYCURSOR;\n//flaw_line_below:\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n//flaw_line_below:\n\tyych = *YYCURSOR;\n//flaw_line_below:\n\tif (yych <= '/') goto yy18;\n//flaw_line_below:\n\tif (yych <= '9') goto yy97;\n//flaw_line_below:\n\tif (yych != ';') goto yy18;\n//flaw_line_below:\n\t++YYCURSOR;\n//flaw_line_below:\n#line 589 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 667 \"ext/standard/var_unserializer.re\"\n \t{\n//flaw_line_below:\n\tzend_long id;\n//flaw_line_below:\n\n//flaw_line_below:\n \t*p = YYCURSOR;\n//flaw_line_below:\n\tif (!var_hash) return 0;\n//flaw_line_below:\n\n//flaw_line_below:\n\tid = parse_iv(start + 2) - 1;\n//flaw_line_below:\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n//flaw_line_below:\n\t\treturn 0;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\t*p = YYCURSOR;\n \n//flaw_line_below:\n\tzval_ptr_dtor(rval);\n//flaw_line_below:\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n//flaw_line_below:\n\t\tZVAL_UNDEF(rval);\n//flaw_line_below:\n\t\treturn 1;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\tif (Z_ISREF_P(rval_ref)) {\n//flaw_line_below:\n\t\tZVAL_COPY(rval, rval_ref);\n//fix_flaw_line_below:\n//\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n//fix_flaw_line_below:\n//\t\tZVAL_DOUBLE(rval, php_get_nan());\n//fix_flaw_line_below:\n//\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n//fix_flaw_line_below:\n//\t\tZVAL_DOUBLE(rval, php_get_inf());\n//fix_flaw_line_below:\n//\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n//fix_flaw_line_below:\n//\t\tZVAL_DOUBLE(rval, -php_get_inf());\n \t} else {\n//flaw_line_below:\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n//flaw_line_below:\n\t\tZVAL_COPY(rval, rval_ref);\n//fix_flaw_line_below:\n//\t\tZVAL_NULL(rval);\n \t}\n \n \treturn 1;\n }\n//flaw_line_below:\n#line 1412 \"ext/standard/var_unserializer.c\"\n//fix_flaw_line_below:\n//#line 1425 \"ext/standard/var_unserializer.c\"\n }\n//flaw_line_below:\n#line 964 \"ext/standard/var_unserializer.re\"\n//fix_flaw_line_below:\n//#line 953 \"ext/standard/var_unserializer.re\"\n \n \n \treturn 0;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "int main (int argc, char *argv[])\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n     catDict->lookup(\"OutputIntents\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj);\n     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n    if (!afObj.isNull()) {\n       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &ocObj);\n    if (!ocObj.isNull() && ocObj.isDict()) {\n       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookup(\"Names\", &names);\n    if (!names.isNull() && names.isDict()) {\n       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n \n   for (i = 0; i < (int) docs.size(); i++) {\n     for (j = 1; j <= docs[i]->getNumPages(); j++) {\n       PDFRectangle *cropBox = NULL;\n       if (docs[i]->getCatalog()->getPage(j)->isCropped())\n         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}\n",
        "post_patch": "int main (int argc, char *argv[])\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n     catDict->lookup(\"OutputIntents\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj);\n     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n    if (!afObj.isNull() && refPage) {\n       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &ocObj);\n    if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookup(\"Names\", &names);\n    if (!names.isNull() && names.isDict() && refPage) {\n       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n \n   for (i = 0; i < (int) docs.size(); i++) {\n     for (j = 1; j <= docs[i]->getNumPages(); j++) {\n      if (!docs[i]->getCatalog()->getPage(j)) {\n        continue;\n      }\n\n       PDFRectangle *cropBox = NULL;\n       if (docs[i]->getCatalog()->getPage(j)->isCropped())\n         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}\n",
        "post_patch_with_fix": "int main (int argc, char *argv[])\n///////////////////////////////////////////////////////////////////////////\n// Merge PDF files given by arguments 1 to argc-2 and write the result\n// to the file specified by argument argc-1.\n///////////////////////////////////////////////////////////////////////////\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  // handle OutputIntents, AcroForm, OCProperties & Names\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n     catDict->lookup(\"OutputIntents\", &intents);\n     catDict->lookupNF(\"AcroForm\", &afObj);\n     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n//flaw_line_below:\n    if (!afObj.isNull()) {\n//fix_flaw_line_below:\n//    if (!afObj.isNull() && refPage) {\n       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookupNF(\"OCProperties\", &ocObj);\n//flaw_line_below:\n    if (!ocObj.isNull() && ocObj.isDict()) {\n//fix_flaw_line_below:\n//    if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     catDict->lookup(\"Names\", &names);\n//flaw_line_below:\n    if (!names.isNull() && names.isDict()) {\n//fix_flaw_line_below:\n//    if (!names.isNull() && names.isDict() && refPage) {\n       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n     }\n     if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n \n   for (i = 0; i < (int) docs.size(); i++) {\n     for (j = 1; j <= docs[i]->getNumPages(); j++) {\n//fix_flaw_line_below:\n//      if (!docs[i]->getCatalog()->getPage(j)) {\n//fix_flaw_line_below:\n//        continue;\n//fix_flaw_line_below:\n//      }\n//fix_flaw_line_below:\n//\n       PDFRectangle *cropBox = NULL;\n       if (docs[i]->getCatalog()->getPage(j)->isCropped())\n         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  // insert OutputIntents\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  // insert AcroForm\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  // insert OCProperties\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  // insert Names\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }\n",
        "post_patch": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\n\treturn hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n",
        "post_patch_with_fix": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n//flaw_line_below:\n\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n//flaw_line_below:\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n//flaw_line_below:\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n//flaw_line_below:\n\tif (ret == NETDEV_TX_OK) {\n//flaw_line_below:\n\t\tnetif_trans_update(ndev);\n//flaw_line_below:\n\t\tndev->stats.tx_bytes += skb->len;\n//flaw_line_below:\n\t\tndev->stats.tx_packets++;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\treturn (netdev_tx_t)ret;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn hns_nic_net_xmit_hw(ndev, skb,\n//fix_flaw_line_below:\n//\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "nfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n \tp = decode_fh(p, &args->fh);\n \tif (!p)\n \t\treturn 0;\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n\treturn xdr_argsize_check(rqstp, p);\n }\n",
        "post_patch": "nfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n \tp = decode_fh(p, &args->fh);\n \tif (!p)\n \t\treturn 0;\n\tif (!xdr_argsize_check(rqstp, p))\n\t\treturn 0;\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n\treturn 1;\n }\n",
        "post_patch_with_fix": "nfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n \tp = decode_fh(p, &args->fh);\n \tif (!p)\n \t\treturn 0;\n//fix_flaw_line_below:\n//\tif (!xdr_argsize_check(rqstp, p))\n//fix_flaw_line_below:\n//\t\treturn 0;\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n//flaw_line_below:\n\treturn xdr_argsize_check(rqstp, p);\n//fix_flaw_line_below:\n//\treturn 1;\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": " void DataReductionProxyConfig::SecureProxyCheck(\n     SecureProxyCheckerCallback fetcher_callback) {\n   secure_proxy_checker_->CheckIfSecureProxyIsAllowed(fetcher_callback);\n }\n",
        "post_patch": " void DataReductionProxyConfig::SecureProxyCheck(\n     SecureProxyCheckerCallback fetcher_callback) {\n  if (params::IsIncludedInHoldbackFieldTrial())\n    return;\n\n   secure_proxy_checker_->CheckIfSecureProxyIsAllowed(fetcher_callback);\n }\n",
        "post_patch_with_fix": " void DataReductionProxyConfig::SecureProxyCheck(\n     SecureProxyCheckerCallback fetcher_callback) {\n//fix_flaw_line_below:\n//  if (params::IsIncludedInHoldbackFieldTrial())\n//fix_flaw_line_below:\n//    return;\n//fix_flaw_line_below:\n//\n   secure_proxy_checker_->CheckIfSecureProxyIsAllowed(fetcher_callback);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n    }\n \n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
        "post_patch": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n \n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
        "post_patch_with_fix": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n//flaw_line_below:\n    }\n \n//flaw_line_below:\n    i = 0;\n//flaw_line_below:\n    darray_foreach(alias, info->aliases) {\n//flaw_line_below:\n        if (alias->real != XKB_ATOM_NONE) {\n//flaw_line_below:\n            key_aliases[i].alias = alias->alias;\n//flaw_line_below:\n            key_aliases[i].real = alias->real;\n//flaw_line_below:\n            i++;\n//fix_flaw_line_below:\n//        i = 0;\n//fix_flaw_line_below:\n//        darray_foreach(alias, info->aliases) {\n//fix_flaw_line_below:\n//            if (alias->real != XKB_ATOM_NONE) {\n//fix_flaw_line_below:\n//                key_aliases[i].alias = alias->alias;\n//fix_flaw_line_below:\n//                key_aliases[i].real = alias->real;\n//fix_flaw_line_below:\n//                i++;\n//fix_flaw_line_below:\n//            }\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n \t\t\t\t     const char *buf, size_t count)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n \n \tif (count > PATH_MAX)\n \t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n \tif (cp)\n \t\t*cp = '\\0';\n \n \tif (strlen(driver_override)) {\n \t\tpdev->driver_override = driver_override;\n \t} else {\n \t\tkfree(driver_override);\n \t\tpdev->driver_override = NULL;\n \t}\n \n \tkfree(old);\n \n\treturn count;\n}\n",
        "post_patch": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n \t\t\t\t     const char *buf, size_t count)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old, *cp;\n \n \tif (count > PATH_MAX)\n \t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n \tif (cp)\n \t\t*cp = '\\0';\n \n\tdevice_lock(dev);\n\told = pdev->driver_override;\n \tif (strlen(driver_override)) {\n \t\tpdev->driver_override = driver_override;\n \t} else {\n \t\tkfree(driver_override);\n \t\tpdev->driver_override = NULL;\n \t}\n\tdevice_unlock(dev);\n \n \tkfree(old);\n \n\treturn count;\n}\n",
        "post_patch_with_fix": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n \t\t\t\t     const char *buf, size_t count)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n//flaw_line_below:\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n//fix_flaw_line_below:\n//\tchar *driver_override, *old, *cp;\n \n \tif (count > PATH_MAX)\n \t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n \tif (cp)\n \t\t*cp = '\\0';\n \n//fix_flaw_line_below:\n//\tdevice_lock(dev);\n//fix_flaw_line_below:\n//\told = pdev->driver_override;\n \tif (strlen(driver_override)) {\n \t\tpdev->driver_override = driver_override;\n \t} else {\n \t\tkfree(driver_override);\n \t\tpdev->driver_override = NULL;\n \t}\n//fix_flaw_line_below:\n//\tdevice_unlock(dev);\n \n \tkfree(old);\n \n\treturn count;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": " static void skcipher_release(void *private)\n {\n\tcrypto_free_skcipher(private);\n }\n",
        "post_patch": " static void skcipher_release(void *private)\n {\n\tstruct skcipher_tfm *tfm = private;\n\n\tcrypto_free_skcipher(tfm->skcipher);\n\tkfree(tfm);\n }\n",
        "post_patch_with_fix": " static void skcipher_release(void *private)\n {\n//flaw_line_below:\n\tcrypto_free_skcipher(private);\n//fix_flaw_line_below:\n//\tstruct skcipher_tfm *tfm = private;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tcrypto_free_skcipher(tfm->skcipher);\n//fix_flaw_line_below:\n//\tkfree(tfm);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n \t\t\tif (tty->ops->flush_chars)\n \t\t\t\ttty->ops->flush_chars(tty);\n \t\t} else {\n \t\t\twhile (nr > 0) {\n \t\t\t\tc = tty->ops->write(tty, b, nr);\n \t\t\t\tif (c < 0) {\n \t\t\t\t\tretval = c;\n \t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n",
        "post_patch": "static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n \t\t\tif (tty->ops->flush_chars)\n \t\t\t\ttty->ops->flush_chars(tty);\n \t\t} else {\n\t\t\tstruct n_tty_data *ldata = tty->disc_data;\n\n \t\t\twhile (nr > 0) {\n\t\t\t\tmutex_lock(&ldata->output_lock);\n \t\t\t\tc = tty->ops->write(tty, b, nr);\n\t\t\t\tmutex_unlock(&ldata->output_lock);\n \t\t\t\tif (c < 0) {\n \t\t\t\t\tretval = c;\n \t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n",
        "post_patch_with_fix": "static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n \t\t\tif (tty->ops->flush_chars)\n \t\t\t\ttty->ops->flush_chars(tty);\n \t\t} else {\n//fix_flaw_line_below:\n//\t\t\tstruct n_tty_data *ldata = tty->disc_data;\n//fix_flaw_line_below:\n//\n \t\t\twhile (nr > 0) {\n//fix_flaw_line_below:\n//\t\t\t\tmutex_lock(&ldata->output_lock);\n \t\t\t\tc = tty->ops->write(tty, b, nr);\n//fix_flaw_line_below:\n//\t\t\t\tmutex_unlock(&ldata->output_lock);\n \t\t\t\tif (c < 0) {\n \t\t\t\t\tretval = c;\n \t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "void AutofillPopupBaseView::DoShow() {\n  const bool initialize_widget = !GetWidget();\n  if (initialize_widget) {\n    if (parent_widget_)\n      parent_widget_->AddObserver(this);\n\n    views::Widget* widget = new views::Widget;\n    views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);\n     params.delegate = this;\n     params.parent = parent_widget_ ? parent_widget_->GetNativeView()\n                                    : delegate_->container_view();\n    AddExtraInitParams(&params);\n     widget->Init(params);\n    std::unique_ptr<views::View> wrapper = CreateWrapperView();\n    if (wrapper)\n      widget->SetContentsView(wrapper.release());\n     widget->AddObserver(this);\n \n    widget->SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);\n\n    show_time_ = base::Time::Now();\n  }\n\n  GetWidget()->GetRootView()->SetBorder(CreateBorder());\n  DoUpdateBoundsAndRedrawPopup();\n  GetWidget()->Show();\n\n  if (initialize_widget)\n    views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);\n}\n",
        "post_patch": "void AutofillPopupBaseView::DoShow() {\n  const bool initialize_widget = !GetWidget();\n  if (initialize_widget) {\n    if (parent_widget_)\n      parent_widget_->AddObserver(this);\n\n    views::Widget* widget = new views::Widget;\n    views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);\n     params.delegate = this;\n     params.parent = parent_widget_ ? parent_widget_->GetNativeView()\n                                    : delegate_->container_view();\n    // Ensure the bubble border is not painted on an opaque background.\n    params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;\n    params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;\n     widget->Init(params);\n     widget->AddObserver(this);\n \n    widget->SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);\n\n    show_time_ = base::Time::Now();\n  }\n\n  GetWidget()->GetRootView()->SetBorder(CreateBorder());\n  DoUpdateBoundsAndRedrawPopup();\n  GetWidget()->Show();\n\n  if (initialize_widget)\n    views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);\n}\n",
        "post_patch_with_fix": "void AutofillPopupBaseView::DoShow() {\n  const bool initialize_widget = !GetWidget();\n  if (initialize_widget) {\n    // On Mac Cocoa browser, |parent_widget_| is null (the parent is not a\n    // views::Widget).\n    // TODO(crbug.com/826862): Remove |parent_widget_|.\n    if (parent_widget_)\n      parent_widget_->AddObserver(this);\n\n    // The widget is destroyed by the corresponding NativeWidget, so we use\n    // a weak pointer to hold the reference and don't have to worry about\n    // deletion.\n    views::Widget* widget = new views::Widget;\n    views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);\n     params.delegate = this;\n     params.parent = parent_widget_ ? parent_widget_->GetNativeView()\n                                    : delegate_->container_view();\n//flaw_line_below:\n    AddExtraInitParams(&params);\n//fix_flaw_line_below:\n//    // Ensure the bubble border is not painted on an opaque background.\n//fix_flaw_line_below:\n//    params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;\n//fix_flaw_line_below:\n//    params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;\n     widget->Init(params);\n//flaw_line_below:\n\n//flaw_line_below:\n    std::unique_ptr<views::View> wrapper = CreateWrapperView();\n//flaw_line_below:\n    if (wrapper)\n//flaw_line_below:\n      widget->SetContentsView(wrapper.release());\n     widget->AddObserver(this);\n \n     // No animation for popup appearance (too distracting).\n    widget->SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);\n\n    show_time_ = base::Time::Now();\n  }\n\n  GetWidget()->GetRootView()->SetBorder(CreateBorder());\n  DoUpdateBoundsAndRedrawPopup();\n  GetWidget()->Show();\n\n  // Showing the widget can change native focus (which would result in an\n  // immediate hiding of the popup). Only start observing after shown.\n  if (initialize_widget)\n    views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,&image->exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->x_resolution;\n        pcx_info.vertical_resolution=(unsigned short) image->y_resolution;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->x_resolution+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->y_resolution+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->matte != MagickFalse)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n     length=(size_t) pcx_info.bytes_per_line;\n     pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n     if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     q=pixels;\n     if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(p));\n                  p++;\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(p));\n                  p++;\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(p));\n                  p++;\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum)\n                    (GetPixelAlpha(p)));\n                  p++;\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p++;\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        FileOpenError,\"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "post_patch": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,&image->exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->x_resolution;\n        pcx_info.vertical_resolution=(unsigned short) image->y_resolution;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->x_resolution+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->y_resolution+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->matte != MagickFalse)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n     length=(size_t) pcx_info.bytes_per_line;\n     pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n     if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     q=pixels;\n     if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(p));\n                  p++;\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(p));\n                  p++;\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(p));\n                  p++;\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum)\n                    (GetPixelAlpha(p)));\n                  p++;\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p++;\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        FileOpenError,\"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "post_patch_with_fix": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,&image->exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->x_resolution;\n        pcx_info.vertical_resolution=(unsigned short) image->y_resolution;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->x_resolution+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->y_resolution+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->matte != MagickFalse)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n     length=(size_t) pcx_info.bytes_per_line;\n     pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n     if (pixel_info == (MemoryInfo *) NULL)\n//flaw_line_below:\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n//fix_flaw_line_below:\n//      {\n//fix_flaw_line_below:\n//        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n//fix_flaw_line_below:\n//        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n//fix_flaw_line_below:\n//      }\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     q=pixels;\n     if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(p));\n                  p++;\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(p));\n                  p++;\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(p));\n                  p++;\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum)\n                    (GetPixelAlpha(p)));\n                  p++;\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p++;\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        FileOpenError,\"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static int __init ip6_tunnel_init(void)\n {\n \tint  err;\n \n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n \t}\n \n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n \t}\n \n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n \treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n \txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n \treturn err;\n }\n",
        "post_patch": "static int __init ip6_tunnel_init(void)\n {\n \tint  err;\n \n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto out_pernet;\n\n\terr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\n\tif (err < 0) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\tgoto out_ip4ip6;\n \t}\n \n\terr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\n\tif (err < 0) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\tgoto out_ip6ip6;\n \t}\n \n \treturn 0;\n\nout_ip6ip6:\n \txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout_ip4ip6:\n\tunregister_pernet_device(&ip6_tnl_net_ops);\nout_pernet:\n \treturn err;\n }\n",
        "post_patch_with_fix": "static int __init ip6_tunnel_init(void)\n {\n \tint  err;\n \n//flaw_line_below:\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n//fix_flaw_line_below:\n//\terr = register_pernet_device(&ip6_tnl_net_ops);\n//fix_flaw_line_below:\n//\tif (err < 0)\n//fix_flaw_line_below:\n//\t\tgoto out_pernet;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\terr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\n//fix_flaw_line_below:\n//\tif (err < 0) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n//flaw_line_below:\n\t\terr = -EAGAIN;\n//flaw_line_below:\n\t\tgoto out;\n//fix_flaw_line_below:\n//\t\tgoto out_ip4ip6;\n \t}\n \n//flaw_line_below:\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n//fix_flaw_line_below:\n//\terr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\n//fix_flaw_line_below:\n//\tif (err < 0) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n//flaw_line_below:\n\t\terr = -EAGAIN;\n//flaw_line_below:\n\t\tgoto unreg_ip4ip6;\n//fix_flaw_line_below:\n//\t\tgoto out_ip6ip6;\n \t}\n \n//flaw_line_below:\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n//flaw_line_below:\n\tif (err < 0)\n//flaw_line_below:\n\t\tgoto err_pernet;\n \treturn 0;\n//flaw_line_below:\nerr_pernet:\n//flaw_line_below:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\n//flaw_line_below:\nunreg_ip4ip6:\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//out_ip6ip6:\n \txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\n//flaw_line_below:\nout:\n//fix_flaw_line_below:\n//out_ip4ip6:\n//fix_flaw_line_below:\n//\tunregister_pernet_device(&ip6_tnl_net_ops);\n//fix_flaw_line_below:\n//out_pernet:\n \treturn err;\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n     goto MATLAB_KO;    /* unsupported endian */\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
        "post_patch": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n     goto MATLAB_KO;    /* unsupported endian */\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
        "post_patch_with_fix": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n     goto MATLAB_KO;    /* unsupported endian */\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n//flaw_line_below:\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n//fix_flaw_line_below:\n//    {\n//fix_flaw_line_below:\n//MATLAB_KO:\n//fix_flaw_line_below:\n//      clone_info=DestroyImageInfo(clone_info);\n//fix_flaw_line_below:\n//      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n//fix_flaw_line_below:\n//    }\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   /* need to rewrite VS code to add interpolation params */\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      /* dump shaders */\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n          fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n       fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n       glDeleteProgram(prog_id);\n       return NULL;\n    }\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}\n",
        "post_patch": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   /* need to rewrite VS code to add interpolation params */\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      /* dump shaders */\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n          fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n       fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n       glDeleteProgram(prog_id);\n      free(sprog);\n       return NULL;\n    }\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}\n",
        "post_patch_with_fix": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   /* need to rewrite VS code to add interpolation params */\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      /* dump shaders */\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n          fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n       fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n       glDeleteProgram(prog_id);\n//fix_flaw_line_below:\n//      free(sprog);\n       return NULL;\n    }\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(pwp_image);\n  pwp_image=DestroyImage(pwp_image);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch_with_fix": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n//flaw_line_below:\n  (void) CloseBlob(pwp_image);\n//flaw_line_below:\n  pwp_image=DestroyImage(pwp_image);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "DataReductionProxyConfigServiceClient::DataReductionProxyConfigServiceClient(\n    const net::BackoffEntry::Policy& backoff_policy,\n    DataReductionProxyRequestOptions* request_options,\n    DataReductionProxyMutableConfigValues* config_values,\n    DataReductionProxyConfig* config,\n    DataReductionProxyIOData* io_data,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    ConfigStorer config_storer)\n    : request_options_(request_options),\n      config_values_(config_values),\n      config_(config),\n      io_data_(io_data),\n      network_connection_tracker_(network_connection_tracker),\n      config_storer_(config_storer),\n      backoff_policy_(backoff_policy),\n      backoff_entry_(&backoff_policy_),\n      config_service_url_(util::AddApiKeyToUrl(params::GetConfigServiceURL())),\n      enabled_(false),\n      remote_config_applied_(false),\n#if defined(OS_ANDROID)\n      foreground_fetch_pending_(false),\n#endif\n      previous_request_failed_authentication_(false),\n      failed_attempts_before_success_(0),\n      fetch_in_progress_(false),\n      client_config_override_used_(false) {\n  DCHECK(request_options);\n  DCHECK(config_values);\n   DCHECK(config);\n   DCHECK(io_data);\n   DCHECK(config_service_url_.is_valid());\n \n   const base::CommandLine& command_line =\n       *base::CommandLine::ForCurrentProcess();\n  client_config_override_ = command_line.GetSwitchValueASCII(\n      switches::kDataReductionProxyServerClientConfig);\n\n  thread_checker_.DetachFromThread();\n}\n",
        "post_patch": "DataReductionProxyConfigServiceClient::DataReductionProxyConfigServiceClient(\n    const net::BackoffEntry::Policy& backoff_policy,\n    DataReductionProxyRequestOptions* request_options,\n    DataReductionProxyMutableConfigValues* config_values,\n    DataReductionProxyConfig* config,\n    DataReductionProxyIOData* io_data,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    ConfigStorer config_storer)\n    : request_options_(request_options),\n      config_values_(config_values),\n      config_(config),\n      io_data_(io_data),\n      network_connection_tracker_(network_connection_tracker),\n      config_storer_(config_storer),\n      backoff_policy_(backoff_policy),\n      backoff_entry_(&backoff_policy_),\n      config_service_url_(util::AddApiKeyToUrl(params::GetConfigServiceURL())),\n      enabled_(false),\n      remote_config_applied_(false),\n#if defined(OS_ANDROID)\n      foreground_fetch_pending_(false),\n#endif\n      previous_request_failed_authentication_(false),\n      failed_attempts_before_success_(0),\n      fetch_in_progress_(false),\n      client_config_override_used_(false) {\n  DCHECK(request_options);\n  DCHECK(config_values);\n   DCHECK(config);\n   DCHECK(io_data);\n   DCHECK(config_service_url_.is_valid());\n  DCHECK(!params::IsIncludedInHoldbackFieldTrial());\n \n   const base::CommandLine& command_line =\n       *base::CommandLine::ForCurrentProcess();\n  client_config_override_ = command_line.GetSwitchValueASCII(\n      switches::kDataReductionProxyServerClientConfig);\n\n  thread_checker_.DetachFromThread();\n}\n",
        "post_patch_with_fix": "DataReductionProxyConfigServiceClient::DataReductionProxyConfigServiceClient(\n    const net::BackoffEntry::Policy& backoff_policy,\n    DataReductionProxyRequestOptions* request_options,\n    DataReductionProxyMutableConfigValues* config_values,\n    DataReductionProxyConfig* config,\n    DataReductionProxyIOData* io_data,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    ConfigStorer config_storer)\n    : request_options_(request_options),\n      config_values_(config_values),\n      config_(config),\n      io_data_(io_data),\n      network_connection_tracker_(network_connection_tracker),\n      config_storer_(config_storer),\n      backoff_policy_(backoff_policy),\n      backoff_entry_(&backoff_policy_),\n      config_service_url_(util::AddApiKeyToUrl(params::GetConfigServiceURL())),\n      enabled_(false),\n      remote_config_applied_(false),\n#if defined(OS_ANDROID)\n      foreground_fetch_pending_(false),\n#endif\n      previous_request_failed_authentication_(false),\n      failed_attempts_before_success_(0),\n      fetch_in_progress_(false),\n      client_config_override_used_(false) {\n  DCHECK(request_options);\n  DCHECK(config_values);\n   DCHECK(config);\n   DCHECK(io_data);\n   DCHECK(config_service_url_.is_valid());\n//fix_flaw_line_below:\n//  DCHECK(!params::IsIncludedInHoldbackFieldTrial());\n \n   const base::CommandLine& command_line =\n       *base::CommandLine::ForCurrentProcess();\n  client_config_override_ = command_line.GetSwitchValueASCII(\n      switches::kDataReductionProxyServerClientConfig);\n\n  // Constructed on the UI thread, but should be checked on the IO thread.\n  thread_checker_.DetachFromThread();\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "AppControllerImpl::AppControllerImpl(Profile* profile)\n//// static\n     : profile_(profile),\n       app_service_proxy_(apps::AppServiceProxy::Get(profile)),\n       url_prefix_(base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n           chromeos::switches::kKioskNextHomeUrlPrefix)) {\n   app_service_proxy_->AppRegistryCache().AddObserver(this);\n \n  if (profile) {\n    content::URLDataSource::Add(profile,\n                                std::make_unique<apps::AppIconSource>(profile));\n  }\n }\n",
        "post_patch": "AppControllerImpl::AppControllerImpl(Profile* profile)\n//// static\nAppControllerService* AppControllerService::Get(\n    content::BrowserContext* context) {\n  return AppControllerServiceFactory::GetForBrowserContext(context);\n}\n\nAppControllerService::AppControllerService(Profile* profile)\n     : profile_(profile),\n       app_service_proxy_(apps::AppServiceProxy::Get(profile)),\n       url_prefix_(base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n           chromeos::switches::kKioskNextHomeUrlPrefix)) {\n  DCHECK(profile);\n   app_service_proxy_->AppRegistryCache().AddObserver(this);\n \n  content::URLDataSource::Add(profile,\n                              std::make_unique<apps::AppIconSource>(profile));\n }\n",
        "post_patch_with_fix": "AppControllerImpl::AppControllerImpl(Profile* profile)\n//fix_flaw_line_below:\n//// static\n//fix_flaw_line_below:\n//AppControllerService* AppControllerService::Get(\n//fix_flaw_line_below:\n//    content::BrowserContext* context) {\n//fix_flaw_line_below:\n//  return AppControllerServiceFactory::GetForBrowserContext(context);\n//fix_flaw_line_below:\n//}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//AppControllerService::AppControllerService(Profile* profile)\n     : profile_(profile),\n       app_service_proxy_(apps::AppServiceProxy::Get(profile)),\n       url_prefix_(base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n           chromeos::switches::kKioskNextHomeUrlPrefix)) {\n//fix_flaw_line_below:\n//  DCHECK(profile);\n   app_service_proxy_->AppRegistryCache().AddObserver(this);\n \n   // Add the chrome://app-icon URL data source.\n   // TODO(ltenorio): Move this to a more suitable location when we change\n   // the Kiosk Next Home to WebUI.\n//flaw_line_below:\n  if (profile) {\n//flaw_line_below:\n    content::URLDataSource::Add(profile,\n//flaw_line_below:\n                                std::make_unique<apps::AppIconSource>(profile));\n//flaw_line_below:\n  }\n//fix_flaw_line_below:\n//  content::URLDataSource::Add(profile,\n//fix_flaw_line_below:\n//                              std::make_unique<apps::AppIconSource>(profile));\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n \n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n \n        ice_conn = IceAcceptConnection (listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n \n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n \n         return TRUE;\n }\n",
        "post_patch": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n \n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n \n        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n \n        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n",
        "post_patch_with_fix": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n//flaw_line_below:\n        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n//flaw_line_below:\n        GsmClient      *client;\n//flaw_line_below:\n        GsmXsmpServer  *server;\n//flaw_line_below:\n\n//flaw_line_below:\n        listener = data->listener;\n//flaw_line_below:\n        server = data->server;\n \n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n \n//flaw_line_below:\n        ice_conn = IceAcceptConnection (listener, &status);\n//fix_flaw_line_below:\n//        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n \n//flaw_line_below:\n        client = gsm_xsmp_client_new (ice_conn);\n//flaw_line_below:\n        ice_conn->context = client;\n//flaw_line_below:\n\n//flaw_line_below:\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n//flaw_line_below:\n        /* the store will own the ref */\n//flaw_line_below:\n        g_object_unref (client);\n//fix_flaw_line_below:\n//        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotated_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  status=MagickTrue;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    /*\n      Object parser loop.\n     */\n     ldblk=ReadBlobLSBLong(image);\n     if ((ldblk > 9999) || (ldblk < 0))\n       break;\n     HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return(DestroyImageList(image));\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    if ((image->columns == 0) || (image->rows == 0))\n      return(DestroyImageList(image));\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        if(HDR.imagf==1) ldblk *= 2;\n        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n        if ((image->columns == 0) || (image->rows == 0))\n          return(image->previous == (Image *) NULL ? DestroyImageList(image)\n            : image);\n        goto skip_reading_current;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,GRAYColorspace,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return(DestroyImageList(image));\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    rotated_image=RotateImage(image,90.0,exception);\n    if (rotated_image != (Image *) NULL)\n      {\n        rotated_image->page.x=0;\n        rotated_image->page.y=0;\n        rotated_image->colors = image->colors;\n        DestroyBlob(rotated_image);\n        rotated_image->blob=ReferenceBlob(image->blob);\n        AppendImageToList(&image,rotated_image);\n        DeleteImageFromList(&image);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\nskip_reading_current:\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotated_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  status=MagickTrue;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    /*\n      Object parser loop.\n     */\n     ldblk=ReadBlobLSBLong(image);\n    if(EOFBlob(image)) break;\n     if ((ldblk > 9999) || (ldblk < 0))\n       break;\n     HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return(DestroyImageList(image));\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    if ((image->columns == 0) || (image->rows == 0))\n      return(DestroyImageList(image));\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        if(HDR.imagf==1) ldblk *= 2;\n        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n        if ((image->columns == 0) || (image->rows == 0))\n          return(image->previous == (Image *) NULL ? DestroyImageList(image)\n            : image);\n        goto skip_reading_current;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,GRAYColorspace,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return(DestroyImageList(image));\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    rotated_image=RotateImage(image,90.0,exception);\n    if (rotated_image != (Image *) NULL)\n      {\n        rotated_image->page.x=0;\n        rotated_image->page.y=0;\n        rotated_image->colors = image->colors;\n        DestroyBlob(rotated_image);\n        rotated_image->blob=ReferenceBlob(image->blob);\n        AppendImageToList(&image,rotated_image);\n        DeleteImageFromList(&image);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\nskip_reading_current:\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch_with_fix": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotated_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  status=MagickTrue;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    /*\n      Object parser loop.\n     */\n     ldblk=ReadBlobLSBLong(image);\n//fix_flaw_line_below:\n//    if(EOFBlob(image)) break;\n     if ((ldblk > 9999) || (ldblk < 0))\n       break;\n     HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return(DestroyImageList(image));\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    if ((image->columns == 0) || (image->rows == 0))\n      return(DestroyImageList(image));\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        if(HDR.imagf==1) ldblk *= 2;\n        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n        if ((image->columns == 0) || (image->rows == 0))\n          return(image->previous == (Image *) NULL ? DestroyImageList(image)\n            : image);\n        goto skip_reading_current;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,GRAYColorspace,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return(DestroyImageList(image));\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    rotated_image=RotateImage(image,90.0,exception);\n    if (rotated_image != (Image *) NULL)\n      {\n        rotated_image->page.x=0;\n        rotated_image->page.y=0;\n        rotated_image->colors = image->colors;\n        DestroyBlob(rotated_image);\n        rotated_image->blob=ReferenceBlob(image->blob);\n        AppendImageToList(&image,rotated_image);\n        DeleteImageFromList(&image);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\nskip_reading_current:\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "int VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVARefFramesFromDPB(\n     const H264DPB& dpb,\n     VAPictureH264* va_pics,\n     int num_pics) {\n   H264Picture::Vector::const_reverse_iterator rit;\n   int i;\n \n  for (rit = dpb.rbegin(), i = 0; rit != dpb.rend() && i < num_pics; ++rit) {\n    if ((*rit)->ref)\n      FillVAPicture(&va_pics[i++], *rit);\n  }\n\n  return i;\n}\n",
        "post_patch": "int VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVARefFramesFromDPB(\n     const H264DPB& dpb,\n     VAPictureH264* va_pics,\n     int num_pics) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   H264Picture::Vector::const_reverse_iterator rit;\n   int i;\n \n  for (rit = dpb.rbegin(), i = 0; rit != dpb.rend() && i < num_pics; ++rit) {\n    if ((*rit)->ref)\n      FillVAPicture(&va_pics[i++], *rit);\n  }\n\n  return i;\n}\n",
        "post_patch_with_fix": "int VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVARefFramesFromDPB(\n     const H264DPB& dpb,\n     VAPictureH264* va_pics,\n     int num_pics) {\n//fix_flaw_line_below:\n//  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   H264Picture::Vector::const_reverse_iterator rit;\n   int i;\n \n  // Return reference frames in reverse order of insertion.\n  // Libva does not document this, but other implementations (e.g. mplayer)\n  // do it this way as well.\n  for (rit = dpb.rbegin(), i = 0; rit != dpb.rend() && i < num_pics; ++rit) {\n    if ((*rit)->ref)\n      FillVAPicture(&va_pics[i++], *rit);\n  }\n\n  return i;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "parse_range(char *str, size_t file_sz, int *nranges)\n {\n\tstatic struct range\t ranges[MAX_RANGES];\n \tint\t\t\t i = 0;\n \tchar\t\t\t*p, *q;\n \n \t/* Extract range unit */\n \tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n \n \t*p++ = '\\0';\n \t/* Check if it's a bytes range spec */\n \tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n \n \twhile ((q = strchr(p, ',')) != NULL) {\n \t\t*q++ = '\\0';\n \n \t\t/* Extract start and end positions */\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n \t\t\tcontinue;\n \n \t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n \n \t\tp = q;\n \t}\n \n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n \t\ti++;\n \n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n }\n",
        "post_patch": "parse_range(char *str, size_t file_sz, int *nranges)\nint\nparse_ranges(struct client *clt, char *str, size_t file_sz)\n {\n \tint\t\t\t i = 0;\n \tchar\t\t\t*p, *q;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\n\tmemset(r, 0, sizeof(*r));\n \n \t/* Extract range unit */\n \tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (-1);\n \n \t*p++ = '\\0';\n \t/* Check if it's a bytes range spec */\n \tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (-1);\n \n \twhile ((q = strchr(p, ',')) != NULL) {\n \t\t*q++ = '\\0';\n \n \t\t/* Extract start and end positions */\n\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n \t\t\tcontinue;\n \n \t\ti++;\n\t\tif (i == SERVER_MAX_RANGES)\n\t\t\treturn (-1);\n \n \t\tp = q;\n \t}\n \n\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n \t\ti++;\n \n\tr->range_total = file_sz;\n\tr->range_count = i;\n\treturn (i);\n }\n",
        "post_patch_with_fix": "parse_range(char *str, size_t file_sz, int *nranges)\n//fix_flaw_line_below:\n//int\n//fix_flaw_line_below:\n//parse_ranges(struct client *clt, char *str, size_t file_sz)\n {\n//flaw_line_below:\n\tstatic struct range\t ranges[MAX_RANGES];\n \tint\t\t\t i = 0;\n \tchar\t\t\t*p, *q;\n//fix_flaw_line_below:\n//\tstruct range_data\t*r = &clt->clt_ranges;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tmemset(r, 0, sizeof(*r));\n \n \t/* Extract range unit */\n \tif ((p = strchr(str, '=')) == NULL)\n//flaw_line_below:\n\t\treturn (NULL);\n//fix_flaw_line_below:\n//\t\treturn (-1);\n \n \t*p++ = '\\0';\n \t/* Check if it's a bytes range spec */\n \tif (strcmp(str, \"bytes\") != 0)\n//flaw_line_below:\n\t\treturn (NULL);\n//fix_flaw_line_below:\n//\t\treturn (-1);\n \n \twhile ((q = strchr(p, ',')) != NULL) {\n \t\t*q++ = '\\0';\n \n \t\t/* Extract start and end positions */\n//flaw_line_below:\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n//fix_flaw_line_below:\n//\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n \t\t\tcontinue;\n \n \t\ti++;\n//flaw_line_below:\n\t\tif (i == MAX_RANGES)\n//flaw_line_below:\n\t\t\treturn (NULL);\n//fix_flaw_line_below:\n//\t\tif (i == SERVER_MAX_RANGES)\n//fix_flaw_line_below:\n//\t\t\treturn (-1);\n \n \t\tp = q;\n \t}\n \n//flaw_line_below:\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n//fix_flaw_line_below:\n//\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n \t\ti++;\n \n//flaw_line_below:\n\t*nranges = i;\n//flaw_line_below:\n\treturn (i ? ranges : NULL);\n//fix_flaw_line_below:\n//\tr->range_total = file_sz;\n//fix_flaw_line_below:\n//\tr->range_count = i;\n//fix_flaw_line_below:\n//\treturn (i);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t/*\n \t * Ensure irq/preemption can't change debugctl in between.\n \t * Note also that both TIF_BLOCKSTEP and debugctl should\n \t * be changed atomically wrt preemption.\n\t * FIXME: this means that set/clear TIF_BLOCKSTEP is simply\n\t * wrong if task != current, SIGKILL can wakeup the stopped\n\t * tracee and set/clear can play with the running task, this\n\t * can confuse the next __switch_to_xtra().\n \t */\n \tlocal_irq_disable();\n \tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}\n",
        "post_patch": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t/*\n \t * Ensure irq/preemption can't change debugctl in between.\n \t * Note also that both TIF_BLOCKSTEP and debugctl should\n \t * be changed atomically wrt preemption.\n\t *\n\t * NOTE: this means that set/clear TIF_BLOCKSTEP is only safe if\n\t * task is current or it can't be running, otherwise we can race\n\t * with __switch_to_xtra(). We rely on ptrace_freeze_traced() but\n\t * PTRACE_KILL is not safe.\n \t */\n \tlocal_irq_disable();\n \tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}\n",
        "post_patch_with_fix": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t/*\n \t * Ensure irq/preemption can't change debugctl in between.\n \t * Note also that both TIF_BLOCKSTEP and debugctl should\n \t * be changed atomically wrt preemption.\n//flaw_line_below:\n\t * FIXME: this means that set/clear TIF_BLOCKSTEP is simply\n//flaw_line_below:\n\t * wrong if task != current, SIGKILL can wakeup the stopped\n//flaw_line_below:\n\t * tracee and set/clear can play with the running task, this\n//flaw_line_below:\n\t * can confuse the next __switch_to_xtra().\n//fix_flaw_line_below:\n//\t *\n//fix_flaw_line_below:\n//\t * NOTE: this means that set/clear TIF_BLOCKSTEP is only safe if\n//fix_flaw_line_below:\n//\t * task is current or it can't be running, otherwise we can race\n//fix_flaw_line_below:\n//\t * with __switch_to_xtra(). We rely on ptrace_freeze_traced() but\n//fix_flaw_line_below:\n//\t * PTRACE_KILL is not safe.\n \t */\n \tlocal_irq_disable();\n \tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n\t\t\treturn ret;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n\treturn count;\n }\n",
        "post_patch": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n\tret = count;\n\nout:\n\to2nm_unlock_subsystem();\n\treturn ret;\n }\n",
        "post_patch_with_fix": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n//flaw_line_below:\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n//fix_flaw_line_below:\n//\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n//fix_flaw_line_below:\n//\to2nm_lock_subsystem();\n//fix_flaw_line_below:\n//\tcluster = to_o2nm_cluster_from_node(node);\n//fix_flaw_line_below:\n//\tif (!cluster) {\n//fix_flaw_line_below:\n//\t\tret = -EINVAL;\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n//flaw_line_below:\n\t    cluster->cl_local_node != node->nd_num)\n//flaw_line_below:\n\t\treturn -EBUSY;\n//fix_flaw_line_below:\n//\t    cluster->cl_local_node != node->nd_num) {\n//fix_flaw_line_below:\n//\t\tret = -EBUSY;\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n//flaw_line_below:\n\t\t\treturn ret;\n//fix_flaw_line_below:\n//\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n//flaw_line_below:\n\treturn count;\n//fix_flaw_line_below:\n//\tret = count;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//out:\n//fix_flaw_line_below:\n//\to2nm_unlock_subsystem();\n//fix_flaw_line_below:\n//\treturn ret;\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val = 0, err;\n\n\tif (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |\n\t\t\t     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |\n\t\t\t     (1<<IP_RETOPTS) | (1<<IP_TOS) |\n\t\t\t     (1<<IP_TTL) | (1<<IP_HDRINCL) |\n\t\t\t     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |\n\t\t\t     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |\n\t\t\t     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |\n\t\t\t     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||\n\t    optname == IP_MULTICAST_TTL ||\n\t    optname == IP_MULTICAST_ALL ||\n\t    optname == IP_MULTICAST_LOOP ||\n\t    optname == IP_RECVORIGDSTADDR) {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tlock_sock(sk);\n\n \tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n\t\tstruct ip_options *opt = NULL;\n \t\tif (optlen > 40)\n \t\t\tgoto e_inval;\n \t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n \t\t\t\t\t       optval, optlen);\n \t\tif (err)\n \t\t\tbreak;\n \t\tif (inet->is_icsk) {\n \t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n \t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n \t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n #endif\n\t\t\t\tif (inet->opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= inet->opt->optlen;\n \t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->optlen;\n \t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n \t\t\t}\n #endif\n \t\t}\n\t\topt = xchg(&inet->opt, opt);\n\t\tkfree(opt);\n \t\tbreak;\n \t}\n \tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~3;\n\t\t\tval |= inet->tos & 3;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 0 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct in_addr) &&\n\t\t\t    copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\treturn -EINVAL;\n}\n",
        "post_patch": "static int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val = 0, err;\n\n\tif (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |\n\t\t\t     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |\n\t\t\t     (1<<IP_RETOPTS) | (1<<IP_TOS) |\n\t\t\t     (1<<IP_TTL) | (1<<IP_HDRINCL) |\n\t\t\t     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |\n\t\t\t     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |\n\t\t\t     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |\n\t\t\t     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||\n\t    optname == IP_MULTICAST_TTL ||\n\t    optname == IP_MULTICAST_ALL ||\n\t    optname == IP_MULTICAST_LOOP ||\n\t    optname == IP_RECVORIGDSTADDR) {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tlock_sock(sk);\n\n \tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n\t\tstruct ip_options_rcu *old, *opt = NULL;\n\n \t\tif (optlen > 40)\n \t\t\tgoto e_inval;\n \t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n \t\t\t\t\t       optval, optlen);\n \t\tif (err)\n \t\t\tbreak;\n\t\told = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tsock_owned_by_user(sk));\n \t\tif (inet->is_icsk) {\n \t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n \t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n \t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n #endif\n\t\t\t\tif (old)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= old->opt.optlen;\n \t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->opt.optlen;\n \t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n \t\t\t}\n #endif\n \t\t}\n\t\trcu_assign_pointer(inet->inet_opt, opt);\n\t\tif (old)\n\t\t\tcall_rcu(&old->rcu, opt_kfree_rcu);\n \t\tbreak;\n \t}\n \tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~3;\n\t\t\tval |= inet->tos & 3;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 0 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct in_addr) &&\n\t\t\t    copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\treturn -EINVAL;\n}\n",
        "post_patch_with_fix": "static int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val = 0, err;\n\n\tif (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |\n\t\t\t     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |\n\t\t\t     (1<<IP_RETOPTS) | (1<<IP_TOS) |\n\t\t\t     (1<<IP_TTL) | (1<<IP_HDRINCL) |\n\t\t\t     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |\n\t\t\t     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |\n\t\t\t     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |\n\t\t\t     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||\n\t    optname == IP_MULTICAST_TTL ||\n\t    optname == IP_MULTICAST_ALL ||\n\t    optname == IP_MULTICAST_LOOP ||\n\t    optname == IP_RECVORIGDSTADDR) {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tlock_sock(sk);\n\n \tswitch (optname) {\n \tcase IP_OPTIONS:\n \t{\n//flaw_line_below:\n\t\tstruct ip_options *opt = NULL;\n//fix_flaw_line_below:\n//\t\tstruct ip_options_rcu *old, *opt = NULL;\n//fix_flaw_line_below:\n//\n \t\tif (optlen > 40)\n \t\t\tgoto e_inval;\n \t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n \t\t\t\t\t       optval, optlen);\n \t\tif (err)\n \t\t\tbreak;\n//fix_flaw_line_below:\n//\t\told = rcu_dereference_protected(inet->inet_opt,\n//fix_flaw_line_below:\n//\t\t\t\t\t\tsock_owned_by_user(sk));\n \t\tif (inet->is_icsk) {\n \t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n \t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n \t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n #endif\n//flaw_line_below:\n\t\t\t\tif (inet->opt)\n//flaw_line_below:\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= inet->opt->optlen;\n//fix_flaw_line_below:\n//\t\t\t\tif (old)\n//fix_flaw_line_below:\n//\t\t\t\t\ticsk->icsk_ext_hdr_len -= old->opt.optlen;\n \t\t\t\tif (opt)\n//flaw_line_below:\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->optlen;\n//fix_flaw_line_below:\n//\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->opt.optlen;\n \t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n \t\t\t}\n #endif\n \t\t}\n//flaw_line_below:\n\t\topt = xchg(&inet->opt, opt);\n//flaw_line_below:\n\t\tkfree(opt);\n//fix_flaw_line_below:\n//\t\trcu_assign_pointer(inet->inet_opt, opt);\n//fix_flaw_line_below:\n//\t\tif (old)\n//fix_flaw_line_below:\n//\t\t\tcall_rcu(&old->rcu, opt_kfree_rcu);\n \t\tbreak;\n \t}\n \tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~3;\n\t\t\tval |= inet->tos & 3;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 0 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct in_addr) &&\n\t\t\t    copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\treturn -EINVAL;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "void ProfileSyncService::OnExperimentsChanged(\n    const browser_sync::Experiments& experiments) {\n  if (current_experiments.Matches(experiments))\n    return;\n\n  if (migrator_.get() &&\n      migrator_->state() != browser_sync::BackendMigrator::IDLE) {\n    DVLOG(1) << \"Dropping OnExperimentsChanged due to migrator busy.\";\n    return;\n  }\n \n   const syncable::ModelTypeSet registered_types = GetRegisteredDataTypes();\n   syncable::ModelTypeSet to_add;\n  if (experiments.sync_tabs)\n    to_add.Put(syncable::SESSIONS);\n   const syncable::ModelTypeSet to_register =\n       Difference(to_add, registered_types);\n   DVLOG(2) << \"OnExperimentsChanged called with types: \"\n           << syncable::ModelTypeSetToString(to_add);\n  DVLOG(2) << \"Enabling types: \" << syncable::ModelTypeSetToString(to_register);\n\n  for (syncable::ModelTypeSet::Iterator it = to_register.First();\n       it.Good(); it.Inc()) {\n    RegisterNewDataType(it.Get());\n#if !defined(OS_ANDROID)\n    std::string experiment_name = GetExperimentNameForDataType(it.Get());\n    if (experiment_name.empty())\n      continue;\n    about_flags::SetExperimentEnabled(g_browser_process->local_state(),\n                                      experiment_name,\n                                      true);\n#endif  // !defined(OS_ANDROID)\n  }\n\n  if (sync_prefs_.HasKeepEverythingSynced()) {\n    sync_prefs_.SetPreferredDataTypes(registered_types, registered_types);\n\n    if (!to_register.Empty() && HasSyncSetupCompleted() && migrator_.get()) {\n      DVLOG(1) << \"Dynamically enabling new datatypes: \"\n               << syncable::ModelTypeSetToString(to_register);\n      OnMigrationNeededForTypes(to_register);\n    }\n  }\n\n  if (experiments.sync_tab_favicons) {\n    DVLOG(1) << \"Enabling syncing of tab favicons.\";\n    about_flags::SetExperimentEnabled(g_browser_process->local_state(),\n                                      \"sync-tab-favicons\",\n                                      true);\n  }\n\n  current_experiments = experiments;\n}\n",
        "post_patch": "void ProfileSyncService::OnExperimentsChanged(\n    const browser_sync::Experiments& experiments) {\n  if (current_experiments.Matches(experiments))\n    return;\n\n  if (migrator_.get() &&\n      migrator_->state() != browser_sync::BackendMigrator::IDLE) {\n    DVLOG(1) << \"Dropping OnExperimentsChanged due to migrator busy.\";\n    return;\n  }\n \n   const syncable::ModelTypeSet registered_types = GetRegisteredDataTypes();\n   syncable::ModelTypeSet to_add;\n   const syncable::ModelTypeSet to_register =\n       Difference(to_add, registered_types);\n   DVLOG(2) << \"OnExperimentsChanged called with types: \"\n           << syncable::ModelTypeSetToString(to_add);\n  DVLOG(2) << \"Enabling types: \" << syncable::ModelTypeSetToString(to_register);\n\n  for (syncable::ModelTypeSet::Iterator it = to_register.First();\n       it.Good(); it.Inc()) {\n    RegisterNewDataType(it.Get());\n#if !defined(OS_ANDROID)\n    std::string experiment_name = GetExperimentNameForDataType(it.Get());\n    if (experiment_name.empty())\n      continue;\n    about_flags::SetExperimentEnabled(g_browser_process->local_state(),\n                                      experiment_name,\n                                      true);\n#endif  // !defined(OS_ANDROID)\n  }\n\n  if (sync_prefs_.HasKeepEverythingSynced()) {\n    sync_prefs_.SetPreferredDataTypes(registered_types, registered_types);\n\n    if (!to_register.Empty() && HasSyncSetupCompleted() && migrator_.get()) {\n      DVLOG(1) << \"Dynamically enabling new datatypes: \"\n               << syncable::ModelTypeSetToString(to_register);\n      OnMigrationNeededForTypes(to_register);\n    }\n  }\n\n  if (experiments.sync_tab_favicons) {\n    DVLOG(1) << \"Enabling syncing of tab favicons.\";\n    about_flags::SetExperimentEnabled(g_browser_process->local_state(),\n                                      \"sync-tab-favicons\",\n                                      true);\n  }\n\n  current_experiments = experiments;\n}\n",
        "post_patch_with_fix": "void ProfileSyncService::OnExperimentsChanged(\n    const browser_sync::Experiments& experiments) {\n  if (current_experiments.Matches(experiments))\n    return;\n\n  // If this is a first time sync for a client, this will be called before\n  // OnBackendInitialized() to ensure the new datatypes are available at sync\n  // setup. As a result, the migrator won't exist yet. This is fine because for\n  // first time sync cases we're only concerned with making the datatype\n  // available.\n  if (migrator_.get() &&\n      migrator_->state() != browser_sync::BackendMigrator::IDLE) {\n    DVLOG(1) << \"Dropping OnExperimentsChanged due to migrator busy.\";\n    return;\n  }\n \n   const syncable::ModelTypeSet registered_types = GetRegisteredDataTypes();\n   syncable::ModelTypeSet to_add;\n//flaw_line_below:\n  if (experiments.sync_tabs)\n//flaw_line_below:\n    to_add.Put(syncable::SESSIONS);\n   const syncable::ModelTypeSet to_register =\n       Difference(to_add, registered_types);\n   DVLOG(2) << \"OnExperimentsChanged called with types: \"\n           << syncable::ModelTypeSetToString(to_add);\n  DVLOG(2) << \"Enabling types: \" << syncable::ModelTypeSetToString(to_register);\n\n  for (syncable::ModelTypeSet::Iterator it = to_register.First();\n       it.Good(); it.Inc()) {\n    // Received notice to enable experimental type. Check if the type is\n    // registered, and if not register a new datatype controller.\n    RegisterNewDataType(it.Get());\n#if !defined(OS_ANDROID)\n    // Enable the about:flags switch for the experimental type so we don't have\n    // to always perform this reconfiguration. Once we set this, the type will\n    // remain registered on restart, so we will no longer go down this code\n    // path.\n    std::string experiment_name = GetExperimentNameForDataType(it.Get());\n    if (experiment_name.empty())\n      continue;\n    about_flags::SetExperimentEnabled(g_browser_process->local_state(),\n                                      experiment_name,\n                                      true);\n#endif  // !defined(OS_ANDROID)\n  }\n\n  // Check if the user has \"Keep Everything Synced\" enabled. If so, we want\n  // to turn on all experimental types if they're not already on. Otherwise we\n  // leave them off.\n  // Note: if any types are already registered, we don't turn them on. This\n  // covers the case where we're already in the process of reconfiguring\n  // to turn an experimental type on.\n  if (sync_prefs_.HasKeepEverythingSynced()) {\n    // Mark all data types as preferred.\n    sync_prefs_.SetPreferredDataTypes(registered_types, registered_types);\n\n    // Only automatically turn on types if we have already finished set up.\n    // Otherwise, just leave the experimental types on by default.\n    if (!to_register.Empty() && HasSyncSetupCompleted() && migrator_.get()) {\n      DVLOG(1) << \"Dynamically enabling new datatypes: \"\n               << syncable::ModelTypeSetToString(to_register);\n      OnMigrationNeededForTypes(to_register);\n    }\n  }\n\n  // Now enable any non-datatype features.\n  if (experiments.sync_tab_favicons) {\n    DVLOG(1) << \"Enabling syncing of tab favicons.\";\n    about_flags::SetExperimentEnabled(g_browser_process->local_state(),\n                                      \"sync-tab-favicons\",\n                                      true);\n  }\n\n  current_experiments = experiments;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": " void HTML_put_string(HTStructured * me, const char *s)\n {\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n\tHTChunkPuts(&me->title, s);\n \tbreak;\n \n     case HTML_STYLE:\n\tHTChunkPuts(&me->style_block, s);\n \tbreak;\n \n     case HTML_SCRIPT:\n\tHTChunkPuts(&me->script, s);\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n \tbreak;\n \n     case HTML_OBJECT:\n\tHTChunkPuts(&me->object, s);\n \tbreak;\n \n     case HTML_TEXTAREA:\n\tHTChunkPuts(&me->textarea, s);\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n\tHTChunkPuts(&me->option, s);\n \tbreak;\n \n     case HTML_MATH:\n\tHTChunkPuts(&me->math, s);\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t/*\n\t\t * We do this so that a raw '\\r' in the string will not be\n\t\t * interpreted as an internal request to break a line - passing\n\t\t * '\\r' to HText_appendText is treated by it as a request to\n\t\t * insert a blank line - VH\n\t\t */\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t/* Ignore leaders */\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    /*\n\t\t     * Treat any '\\r' which is not followed by '\\n' as '\\n', to\n\t\t     * account for macintosh lineend in ALT attributes etc.  -\n\t\t     * kw\n\t\t     */\n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t/* Ignore it */\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    /* ignore */\n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t/* set the Last Character */\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    /* set it to a generic separator */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    /*\n\t\t     * \\r's are ignored.  In order to keep collapsing spaces\n\t\t     * correctly, we must default back to the previous\n\t\t     * separator, if there was one.  So we set LastChar to a\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n",
        "post_patch": " void HTML_put_string(HTStructured * me, const char *s)\n {\n    HTChunk *target = NULL;\n\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n\ttarget = &me->title;\n \tbreak;\n \n     case HTML_STYLE:\n\ttarget = &me->style_block;\n \tbreak;\n \n     case HTML_SCRIPT:\n\ttarget = &me->script;\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n \tbreak;\n \n     case HTML_OBJECT:\n\ttarget = &me->object;\n \tbreak;\n \n     case HTML_TEXTAREA:\n\ttarget = &me->textarea;\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n\ttarget = &me->option;\n \tbreak;\n \n     case HTML_MATH:\n\ttarget = &me->math;\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t/*\n\t\t * We do this so that a raw '\\r' in the string will not be\n\t\t * interpreted as an internal request to break a line - passing\n\t\t * '\\r' to HText_appendText is treated by it as a request to\n\t\t * insert a blank line - VH\n\t\t */\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t/* Ignore leaders */\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    /*\n\t\t     * Treat any '\\r' which is not followed by '\\n' as '\\n', to\n\t\t     * account for macintosh lineend in ALT attributes etc.  -\n\t\t     * kw\n\t\t     */\n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t/* Ignore it */\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    /* ignore */\n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t/* set the Last Character */\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    /* set it to a generic separator */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    /*\n\t\t     * \\r's are ignored.  In order to keep collapsing spaces\n\t\t     * correctly, we must default back to the previous\n\t\t     * separator, if there was one.  So we set LastChar to a\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n\n    if (target != NULL) {\n\tif (target->data == s) {\n\t    CTRACE((tfp, \"BUG: appending chunk to itself: `%.*s'\\n\",\n\t\t    target->size, target->data));\n\t} else {\n\t    HTChunkPuts(target, s);\n\t}\n    }\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n",
        "post_patch_with_fix": " void HTML_put_string(HTStructured * me, const char *s)\n {\n//fix_flaw_line_below:\n//    HTChunk *target = NULL;\n//fix_flaw_line_below:\n//\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n//flaw_line_below:\n\tHTChunkPuts(&me->title, s);\n//fix_flaw_line_below:\n//\ttarget = &me->title;\n \tbreak;\n \n     case HTML_STYLE:\n//flaw_line_below:\n\tHTChunkPuts(&me->style_block, s);\n//fix_flaw_line_below:\n//\ttarget = &me->style_block;\n \tbreak;\n \n     case HTML_SCRIPT:\n//flaw_line_below:\n\tHTChunkPuts(&me->script, s);\n//fix_flaw_line_below:\n//\ttarget = &me->script;\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n \tbreak;\n \n     case HTML_OBJECT:\n//flaw_line_below:\n\tHTChunkPuts(&me->object, s);\n//fix_flaw_line_below:\n//\ttarget = &me->object;\n \tbreak;\n \n     case HTML_TEXTAREA:\n//flaw_line_below:\n\tHTChunkPuts(&me->textarea, s);\n//fix_flaw_line_below:\n//\ttarget = &me->textarea;\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n//flaw_line_below:\n\tHTChunkPuts(&me->option, s);\n//fix_flaw_line_below:\n//\ttarget = &me->option;\n \tbreak;\n \n     case HTML_MATH:\n//flaw_line_below:\n\tHTChunkPuts(&me->math, s);\n//fix_flaw_line_below:\n//\ttarget = &me->math;\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t    if (psrc_view) {\n\t\t/*\n\t\t * We do this so that a raw '\\r' in the string will not be\n\t\t * interpreted as an internal request to break a line - passing\n\t\t * '\\r' to HText_appendText is treated by it as a request to\n\t\t * insert a blank line - VH\n\t\t */\n\t\tfor (; *s; ++s)\n\t\t    HTML_put_character(me, *s);\n\t    } else\n#endif\n\t\tHText_appendText(me->text, s);\n\t    break;\n\t} else {\n\t    const char *p = s;\n\t    char c;\n\n\t    if (me->style_change) {\n\t\tfor (; *p && ((*p == '\\n') || (*p == '\\r') ||\n\t\t\t      (*p == ' ') || (*p == '\\t')); p++) ;\t/* Ignore leaders */\n\t\tif (!*p)\n\t\t    break;\n\t\tUPDATE_STYLE;\n\t    }\n\t    for (; *p; p++) {\n\t\tif (*p == 13 && p[1] != 10) {\n\t\t    /*\n\t\t     * Treat any '\\r' which is not followed by '\\n' as '\\n', to\n\t\t     * account for macintosh lineend in ALT attributes etc.  -\n\t\t     * kw\n\t\t     */\n\t\t    c = '\\n';\n\t\t} else {\n\t\t    c = *p;\n\t\t}\n\t\tif (me->style_change) {\n\t\t    if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n\t\t\tcontinue;\t/* Ignore it */\n\t\t    UPDATE_STYLE;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t    if (!FIX_JAPANESE_SPACES) {\n\t\t\tif (me->in_word) {\n\t\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\t\tHText_appendCharacter(me->text, ' ');\n\t\t\t    me->in_word = NO;\n\t\t\t}\n\t\t    }\n\n\t\t} else if (c == ' ' || c == '\\t') {\n\t\t    if (HText_getLastChar(me->text) != ' ')\n\t\t\tHText_appendCharacter(me->text, ' ');\n\n\t\t} else if (c == '\\r') {\n\t\t    /* ignore */\n\t\t} else {\n\t\t    HText_appendCharacter(me->text, c);\n\t\t    me->in_word = YES;\n\t\t}\n\n\t\t/* set the Last Character */\n\t\tif (c == '\\n' || c == '\\t') {\n\t\t    /* set it to a generic separator */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else if (c == '\\r' &&\n\t\t\t   HText_getLastChar(me->text) == ' ') {\n\t\t    /*\n\t\t     * \\r's are ignored.  In order to keep collapsing spaces\n\t\t     * correctly, we must default back to the previous\n\t\t     * separator, if there was one.  So we set LastChar to a\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    if (target != NULL) {\n//fix_flaw_line_below:\n//\tif (target->data == s) {\n//fix_flaw_line_below:\n//\t    CTRACE((tfp, \"BUG: appending chunk to itself: `%.*s'\\n\",\n//fix_flaw_line_below:\n//\t\t    target->size, target->data));\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t    HTChunkPuts(target, s);\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//    }\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n",
        "post_patch": "gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n",
        "post_patch_with_fix": "gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n//fix_flaw_line_below:\n//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n//fix_flaw_line_below:\n//\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n \n \tline += PKT_LEN_SIZE;\n \t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n \t */\n \tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n \t}\n \n \tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n",
        "post_patch": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n \n \tline += PKT_LEN_SIZE;\n \t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n",
        "post_patch_with_fix": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n \n \tline += PKT_LEN_SIZE;\n \t/*\n//flaw_line_below:\n\t * TODO: How do we deal with empty lines? Try again? with the next\n//flaw_line_below:\n\t * line?\n//fix_flaw_line_below:\n//\t * The Git protocol does not specify empty lines as part\n//fix_flaw_line_below:\n//\t * of the protocol. Not knowing what to do with an empty\n//fix_flaw_line_below:\n//\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n//flaw_line_below:\n\t\t*head = NULL;\n//flaw_line_below:\n\t\t*out = line;\n//flaw_line_below:\n\t\treturn 0;\n//fix_flaw_line_below:\n//\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n//fix_flaw_line_below:\n//\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
        "post_patch": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
        "post_patch_with_fix": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n//fix_flaw_line_below:\n//\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n",
        "post_patch": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n\tinfo->port = NULL;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n",
        "post_patch_with_fix": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n//fix_flaw_line_below:\n//\tinfo->port = NULL;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    gint offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    gint data_length = 0;\n    gint req_id = 0;\n    gint command_id = -1;\n    gint status = 0;\n    guint prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    usb_conv_info_t *usb_conv_info;\n    gint stream_detected = FALSE;\n    gint control_detected = FALSE;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = TRUE;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = TRUE;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&\n             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){\n            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str(status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->fd->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->fd->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n        u3v_conv_info->ep_stream = usb_conv_info->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}\n",
        "post_patch": "dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    gint offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    gint data_length = 0;\n    gint req_id = 0;\n    gint command_id = -1;\n    gint status = 0;\n    guint prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    usb_conv_info_t *usb_conv_info;\n    gint stream_detected = FALSE;\n    gint control_detected = FALSE;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_U3V;\n    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = TRUE;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = TRUE;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&\n             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){\n            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str(status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->fd->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->fd->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n        u3v_conv_info->ep_stream = usb_conv_info->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}\n",
        "post_patch_with_fix": "dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    gint offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    gint data_length = 0;\n    gint req_id = 0;\n    gint command_id = -1;\n    gint status = 0;\n    guint prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    usb_conv_info_t *usb_conv_info;\n    gint stream_detected = FALSE;\n    gint control_detected = FALSE;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n//fix_flaw_line_below:\n//        usb_conv_info->class_data_type = USB_CONV_U3V;\n//fix_flaw_line_below:\n//    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n//fix_flaw_line_below:\n//        /* Don't dissect if another USB type is in the conversation */\n//fix_flaw_line_below:\n//        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = TRUE;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = TRUE;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&\n             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){\n            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str(status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->fd->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->fd->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n        u3v_conv_info->ep_stream = usb_conv_info->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info = NULL;\n    video_entity_t    *entity          = NULL;\n    proto_item *item          = NULL;\n    proto_item *subtype_item  = NULL;\n    proto_tree *tree          = NULL;\n    guint8      entity_id     = 0;\n    guint16     terminal_type = 0;\n    int         offset        = 0;\n    guint8      subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const gchar *subtype_str;\n\n        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                                   ett_descriptor_video_control, &item, \"VIDEO CONTROL INTERFACE DESCRIPTOR [%s]\",\n                                   subtype_str);\n    }\n\n    /* Common fields */\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == VC_HEADER)\n    {\n        guint8 num_vs_interfaces;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n\n        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\n\n        if (num_vs_interfaces > 0)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\n        }\n\n        offset += 9 + num_vs_interfaces;\n    }\n    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\n    {\n        /* Fields common to input and output terminals */\n        entity_id     = tvb_get_guint8(tvb, offset);\n        terminal_type = tvb_get_letohs(tvb, offset+1);\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            ++offset;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_INPUT_TERMINAL)\n        {\n            if (terminal_type == ITT_CAMERA)\n            {\n                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);\n            }\n            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\n            {\n                /* @todo */\n            }\n        }\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\n            {\n                /* @todo */\n            }\n        }\n    }\n    else\n    {\n        /* Field common to extension / processing / selector / encoding units */\n        entity_id = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_PROCESSING_UNIT)\n        {\n            offset = dissect_usb_video_processing_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_SELECTOR_UNIT)\n        {\n            offset = dissect_usb_video_selector_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_EXTENSION_UNIT)\n        {\n            offset = dissect_usb_video_extension_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_ENCODING_UNIT)\n        {\n            /* @todo UVC 1.5 */\n        }\n        else\n        {\n            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\n                                   \"Unknown VC subtype %u\", subtype);\n        }\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n        /* offset = descriptor_len; */\n    }\n\n    if (entity_id != 0)\n        proto_item_append_text(item, \" (Entity %d)\", entity_id);\n\n    if (subtype != VC_HEADER && usb_conv_info)\n    {\n        /* Switch to the usb_conv_info of the Video Control interface */\n        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);\n        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n\n        if (!video_conv_info)\n        {\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n        if (!entity)\n        {\n            entity = wmem_new(wmem_file_scope(), video_entity_t);\n            entity->entityID     = entity_id;\n            entity->subtype      = subtype;\n            entity->terminalType = terminal_type;\n\n            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);\n        }\n    }\n\n    return descriptor_len;\n}\n",
        "post_patch": "dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info = NULL;\n    video_entity_t    *entity          = NULL;\n    proto_item *item          = NULL;\n    proto_item *subtype_item  = NULL;\n    proto_tree *tree          = NULL;\n    guint8      entity_id     = 0;\n    guint16     terminal_type = 0;\n    int         offset        = 0;\n    guint8      subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const gchar *subtype_str;\n\n        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                                   ett_descriptor_video_control, &item, \"VIDEO CONTROL INTERFACE DESCRIPTOR [%s]\",\n                                   subtype_str);\n    }\n\n    /* Common fields */\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == VC_HEADER)\n    {\n        guint8 num_vs_interfaces;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n\n        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\n\n        if (num_vs_interfaces > 0)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\n        }\n\n        offset += 9 + num_vs_interfaces;\n    }\n    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\n    {\n        /* Fields common to input and output terminals */\n        entity_id     = tvb_get_guint8(tvb, offset);\n        terminal_type = tvb_get_letohs(tvb, offset+1);\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            ++offset;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_INPUT_TERMINAL)\n        {\n            if (terminal_type == ITT_CAMERA)\n            {\n                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);\n            }\n            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\n            {\n                /* @todo */\n            }\n        }\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\n            {\n                /* @todo */\n            }\n        }\n    }\n    else\n    {\n        /* Field common to extension / processing / selector / encoding units */\n        entity_id = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_PROCESSING_UNIT)\n        {\n            offset = dissect_usb_video_processing_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_SELECTOR_UNIT)\n        {\n            offset = dissect_usb_video_selector_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_EXTENSION_UNIT)\n        {\n            offset = dissect_usb_video_extension_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_ENCODING_UNIT)\n        {\n            /* @todo UVC 1.5 */\n        }\n        else\n        {\n            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\n                                   \"Unknown VC subtype %u\", subtype);\n        }\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n        /* offset = descriptor_len; */\n    }\n\n    if (entity_id != 0)\n        proto_item_append_text(item, \" (Entity %d)\", entity_id);\n\n    if (subtype != VC_HEADER && usb_conv_info)\n    {\n        /* Switch to the usb_conv_info of the Video Control interface */\n        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);\n        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n\n        if (!video_conv_info)\n        {\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n            /* Stop dissection if another USB type is in the conversation */\n            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n        if (!entity)\n        {\n            entity = wmem_new(wmem_file_scope(), video_entity_t);\n            entity->entityID     = entity_id;\n            entity->subtype      = subtype;\n            entity->terminalType = terminal_type;\n\n            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);\n        }\n    }\n\n    return descriptor_len;\n}\n",
        "post_patch_with_fix": "dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info = NULL;\n    video_entity_t    *entity          = NULL;\n    proto_item *item          = NULL;\n    proto_item *subtype_item  = NULL;\n    proto_tree *tree          = NULL;\n    guint8      entity_id     = 0;\n    guint16     terminal_type = 0;\n    int         offset        = 0;\n    guint8      subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const gchar *subtype_str;\n\n        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                                   ett_descriptor_video_control, &item, \"VIDEO CONTROL INTERFACE DESCRIPTOR [%s]\",\n                                   subtype_str);\n    }\n\n    /* Common fields */\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == VC_HEADER)\n    {\n        guint8 num_vs_interfaces;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n\n        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\n\n        if (num_vs_interfaces > 0)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\n        }\n\n        offset += 9 + num_vs_interfaces;\n    }\n    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\n    {\n        /* Fields common to input and output terminals */\n        entity_id     = tvb_get_guint8(tvb, offset);\n        terminal_type = tvb_get_letohs(tvb, offset+1);\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            ++offset;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_INPUT_TERMINAL)\n        {\n            if (terminal_type == ITT_CAMERA)\n            {\n                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);\n            }\n            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\n            {\n                /* @todo */\n            }\n        }\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\n            {\n                /* @todo */\n            }\n        }\n    }\n    else\n    {\n        /* Field common to extension / processing / selector / encoding units */\n        entity_id = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_PROCESSING_UNIT)\n        {\n            offset = dissect_usb_video_processing_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_SELECTOR_UNIT)\n        {\n            offset = dissect_usb_video_selector_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_EXTENSION_UNIT)\n        {\n            offset = dissect_usb_video_extension_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_ENCODING_UNIT)\n        {\n            /* @todo UVC 1.5 */\n        }\n        else\n        {\n            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\n                                   \"Unknown VC subtype %u\", subtype);\n        }\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n        /* offset = descriptor_len; */\n    }\n\n    if (entity_id != 0)\n        proto_item_append_text(item, \" (Entity %d)\", entity_id);\n\n    if (subtype != VC_HEADER && usb_conv_info)\n    {\n        /* Switch to the usb_conv_info of the Video Control interface */\n        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);\n        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n\n        if (!video_conv_info)\n        {\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n//fix_flaw_line_below:\n//            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n//fix_flaw_line_below:\n//        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n//fix_flaw_line_below:\n//            /* Stop dissection if another USB type is in the conversation */\n//fix_flaw_line_below:\n//            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n        if (!entity)\n        {\n            entity = wmem_new(wmem_file_scope(), video_entity_t);\n            entity->entityID     = entity_id;\n            entity->subtype      = subtype;\n            entity->terminalType = terminal_type;\n\n            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);\n        }\n    }\n\n    return descriptor_len;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n \tif (out == NULL) {\n \t\treturn;\n \t}\n\tgdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n",
        "post_patch": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n \tif (out == NULL) {\n \t\treturn;\n \t}\n\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n",
        "post_patch_with_fix": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n \tif (out == NULL) {\n \t\treturn;\n \t}\n//flaw_line_below:\n\tgdImageWebpCtx(im, out, -1);\n//fix_flaw_line_below:\n//\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    },
    {
        "pre_patch": "xfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n \t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n \t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n \t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n \t\t\t\tkmem_free(args.value);\n \t\t\t} else {\n \t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}\n",
        "post_patch": "xfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n \t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n \t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n \t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (!retval)\n\t\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\t\targs.value);\n \t\t\t\tkmem_free(args.value);\n \t\t\t} else {\n \t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}\n",
        "post_patch_with_fix": "xfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n \t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n \t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n \t\t\t\tretval = xfs_attr_rmtval_get(&args);\n//flaw_line_below:\n\t\t\t\tif (retval)\n//flaw_line_below:\n\t\t\t\t\treturn retval;\n//flaw_line_below:\n\t\t\t\tretval = context->put_listent(context,\n//flaw_line_below:\n\t\t\t\t\t\tentry->flags,\n//flaw_line_below:\n\t\t\t\t\t\tname_rmt->name,\n//flaw_line_below:\n\t\t\t\t\t\t(int)name_rmt->namelen,\n//flaw_line_below:\n\t\t\t\t\t\tvaluelen,\n//flaw_line_below:\n\t\t\t\t\t\targs.value);\n//fix_flaw_line_below:\n//\t\t\t\tif (!retval)\n//fix_flaw_line_below:\n//\t\t\t\t\tretval = context->put_listent(context,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\tentry->flags,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\tname_rmt->name,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\t(int)name_rmt->namelen,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\tvaluelen,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\targs.value);\n \t\t\t\tkmem_free(args.value);\n \t\t\t} else {\n \t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}\n",
        "pre_patch_label": 1,
        "post_patch_label": 0
    }
]