[
    {
        "pre_patch": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n \t}\n \treturn GF_OK;\n }\n",
        "post_patch": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_Box* dref;\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;\n\t\tgf_isom_box_add_for_dump_mode(s, dref);\n \t}\n \treturn GF_OK;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "int udp_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tstruct udp_offload_priv *uo_priv;\n\t__be16 newlen = htons(skb->len - nhoff);\n\tstruct udphdr *uh = (struct udphdr *)(skb->data + nhoff);\n\tint err = -ENOSYS;\n\n\tuh->len = newlen;\n\n\trcu_read_lock();\n\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_complete)\n\t\t\tbreak;\n\t}\n\n\tif (uo_priv) {\n\t\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\t\terr = uo_priv->offload->callbacks.gro_complete(skb,\n\t\t\t\tnhoff + sizeof(struct udphdr),\n\t\t\t\tuo_priv->offload);\n\t}\n\n\trcu_read_unlock();\n\n\tif (skb->remcsum_offload)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TUNNEL_REMCSUM;\n\n\tskb->encapsulation = 1;\n\tskb_set_inner_mac_header(skb, nhoff + sizeof(struct udphdr));\n\n\treturn err;\n}\n",
        "post_patch": "int udp_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tstruct udp_offload_priv *uo_priv;\n\t__be16 newlen = htons(skb->len - nhoff);\n\tstruct udphdr *uh = (struct udphdr *)(skb->data + nhoff);\n\tint err = -ENOSYS;\n\n\tuh->len = newlen;\n\n\trcu_read_lock();\n\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_complete)\n\t\t\tbreak;\n\t}\n\n\tif (uo_priv) {\n\t\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\t\terr = uo_priv->offload->callbacks.gro_complete(skb,\n\t\t\t\tnhoff + sizeof(struct udphdr),\n\t\t\t\tuo_priv->offload);\n\t}\n\n\trcu_read_unlock();\n\n\tif (skb->remcsum_offload)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TUNNEL_REMCSUM;\n\n\tskb->encapsulation = 1;\n\tskb_set_inner_mac_header(skb, nhoff + sizeof(struct udphdr));\n\n\treturn err;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static ssize_t regulator_min_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uA);\n}\n",
        "post_patch": "static ssize_t regulator_min_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uA);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "safeboolean fill_input_buffer (j_decompress_ptr cinfo)\n{\n\tmy_src_ptr src = (my_src_ptr) cinfo->src;\n\t/* 2.0.12: signed size. Thanks to Geert Jansen */\n\tssize_t nbytes = 0;\n\n\t/* ssize_t got; */\n\t/* char *s; */\n\tmemset(src->buffer, 0, INPUT_BUF_SIZE);\n\n\twhile (nbytes < INPUT_BUF_SIZE) {\n\t\tint got = gdGetBuf(src->buffer + nbytes, INPUT_BUF_SIZE - nbytes, src->infile);\n\n\t\tif (got == EOF || got == 0) {\n\t\t\t/* EOF or error. If we got any data, don't worry about it. If we didn't, then this is unexpected. */\n\t\t\tif (!nbytes) {\n\t\t\t\tnbytes = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnbytes += got;\n\t}\n\n\tif (nbytes <= 0) {\n\t\tif (src->start_of_file)\t{ /* Treat empty input file as fatal error */\n\t\t\tERREXIT (cinfo, JERR_INPUT_EMPTY);\n\t\t}\n\t\tWARNMS (cinfo, JWRN_JPEG_EOF);\n\t\t/* Insert a fake EOI marker */\n\t\tsrc->buffer[0] = (unsigned char) 0xFF;\n\t\tsrc->buffer[1] = (unsigned char) JPEG_EOI;\n\t\tnbytes = 2;\n\t}\n\n\tsrc->pub.next_input_byte = src->buffer;\n\tsrc->pub.bytes_in_buffer = nbytes;\n\tsrc->start_of_file = FALSE;\n\n\treturn TRUE;\n}\n",
        "post_patch": "safeboolean fill_input_buffer (j_decompress_ptr cinfo)\n{\n\tmy_src_ptr src = (my_src_ptr) cinfo->src;\n\t/* 2.0.12: signed size. Thanks to Geert Jansen */\n\tssize_t nbytes = 0;\n\n\t/* ssize_t got; */\n\t/* char *s; */\n\tmemset(src->buffer, 0, INPUT_BUF_SIZE);\n\n\twhile (nbytes < INPUT_BUF_SIZE) {\n\t\tint got = gdGetBuf(src->buffer + nbytes, INPUT_BUF_SIZE - nbytes, src->infile);\n\n\t\tif (got == EOF || got == 0) {\n\t\t\t/* EOF or error. If we got any data, don't worry about it. If we didn't, then this is unexpected. */\n\t\t\tif (!nbytes) {\n\t\t\t\tnbytes = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnbytes += got;\n\t}\n\n\tif (nbytes <= 0) {\n\t\tif (src->start_of_file)\t{ /* Treat empty input file as fatal error */\n\t\t\tERREXIT (cinfo, JERR_INPUT_EMPTY);\n\t\t}\n\t\tWARNMS (cinfo, JWRN_JPEG_EOF);\n\t\t/* Insert a fake EOI marker */\n\t\tsrc->buffer[0] = (unsigned char) 0xFF;\n\t\tsrc->buffer[1] = (unsigned char) JPEG_EOI;\n\t\tnbytes = 2;\n\t}\n\n\tsrc->pub.next_input_byte = src->buffer;\n\tsrc->pub.bytes_in_buffer = nbytes;\n\tsrc->start_of_file = FALSE;\n\n\treturn TRUE;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n   }\n \n   (void) CloseBlob(image);\n  DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n}\n",
        "post_patch": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n   }\n \n   (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n}\n",
        "label": 1
    },
    {
        "pre_patch": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n \tvma = find_vma_prev(mm, addr, &prev);\n \tif (vma && (vma->vm_start <= addr))\n \t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n \t\treturn NULL;\n \tif (prev->vm_flags & VM_LOCKED)\n \t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}\n",
        "post_patch": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n \tvma = find_vma_prev(mm, addr, &prev);\n \tif (vma && (vma->vm_start <= addr))\n \t\treturn vma;\n\t/* don't alter vm_end if the coredump is running */\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n \t\treturn NULL;\n \tif (prev->vm_flags & VM_LOCKED)\n \t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "iasecc_select_file(struct sc_card *card, const struct sc_path *path,\n\t\t struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path lpath;\n\tint cache_valid = card->cache.valid, df_from_cache = 0;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tmemcpy(&lpath, path, sizeof(struct sc_path));\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tsc_log(ctx,\n\t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, path->len, path->type, path->aid.len);\n \tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n \n \tsc_print_cache(card);\n\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n \t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n \n \t\trv = iasecc_select_mf(card, file_out);\n \t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n \n\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {\n\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n\t\t\tlpath.len -=  2;\n\t\t}\n \t}\n \n \tif (lpath.aid.len)\t{\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_path ppath;\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       lpath.aid.value, lpath.aid.len);\n\t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));\n\t\tmemset(&ppath, 0, sizeof(ppath));\n\t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);\n\t\tppath.len = lpath.aid.len;\n\t\tppath.type = SC_PATH_TYPE_DF_NAME;\n\n\t\tif (card->cache.valid && card->cache.current_df\n\t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len\n\t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))\n\t\t\tdf_from_cache = 1;\n\n\t\trv = iasecc_select_file(card, &ppath, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");\n\n\t\tif (file_out)\n\t\t\t*file_out = file;\n\t\telse\n\t\t   sc_file_free(file);\n\n\t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)\n\t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\t}\n\n\tif (lpath.type == SC_PATH_TYPE_PATH)\n\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\n\tif (!lpath.len)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_df->path.len == lpath.len\n\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {\n\t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));\n\t\tif (file_out)   {\n\t\t\tsc_file_free(*file_out);\n\t\t\tsc_file_dup(file_out, card->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(card);\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu apdu;\n\t\tstruct sc_file *file = NULL;\n\t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\t\tint pathlen = lpath.len;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");\n\n\t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {\n\t\t\tapdu.p1 = 0x02;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {\n\t\t\t\tapdu.p1 = 0x01;\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\t}\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {\n\t\t\tapdu.p1 = 0x09;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {\n\t\t\tapdu.p1 = 0x03;\n\t\t\tpathlen = 0;\n\t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tapdu.p1 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (ii=0; ii<2; ii++)   {\n\t\t\tapdu.lc = pathlen;\n\t\t\tapdu.data = lpath.value;\n\t\t\tapdu.datalen = pathlen;\n\n\t\t\tapdu.resp = rbuf;\n\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\tapdu.le = 256;\n\n\t\t\trv = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&\n\t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {\n\t\t\t\tapdu.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ii)   {\n\t\t\t\t/* 'SELECT AID' do not returned FCP. Try to emulate. */\n\t\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Using of the cached DF and EF can cause problems in the multi-thread environment.\n\t\t * FIXME: introduce config. option that invalidates this cache outside the locked card session,\n\t\t *        (or invent something else)\n\t\t */\n\t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {\n\t\t\tsc_invalidate_cache(card);\n\t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = NULL;\n\t\t\t}\n\t\t\trv = iasecc_select_file(card, path, file_out);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       apdu.resplen);\n\t\tif (apdu.resplen)   {\n\t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);\n\n\t\t\tswitch (apdu.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tfile = sc_file_new();\n\t\t\t\tif (file == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->path = lpath;\n\n\t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);\n\t\t\t\tif (rv)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\n\t\t\tsc_log(ctx, \"FileType %i\", file->type);\n\t\t\tif (file->type == SC_FILE_TYPE_DF)   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_df);\n\t\t\t\tcard->cache.current_df = NULL;\n\n\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_df, file);\n\t\t\t\tcard->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_ef, file);\n\t\t\t}\n\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(file);\n\t\t\t}\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tsc_file_free(card->cache.current_df);\n\t\t\tcard->cache.current_df = NULL;\n\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\tcard->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n",
        "post_patch": "iasecc_select_file(struct sc_card *card, const struct sc_path *path,\n\t\t struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path lpath;\n\tint cache_valid = card->cache.valid, df_from_cache = 0;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tmemcpy(&lpath, path, sizeof(struct sc_path));\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tsc_log(ctx,\n\t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, path->len, path->type, path->aid.len);\n \tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n \n \tsc_print_cache(card);\n\tif (path->type != SC_PATH_TYPE_DF_NAME\n\t\t\t&& lpath.len >= 2\n\t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n \t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n \n \t\trv = iasecc_select_mf(card, file_out);\n \t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n \n\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n\t\tlpath.len -=  2;\n \t}\n \n \tif (lpath.aid.len)\t{\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_path ppath;\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       lpath.aid.value, lpath.aid.len);\n\t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));\n\t\tmemset(&ppath, 0, sizeof(ppath));\n\t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);\n\t\tppath.len = lpath.aid.len;\n\t\tppath.type = SC_PATH_TYPE_DF_NAME;\n\n\t\tif (card->cache.valid && card->cache.current_df\n\t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len\n\t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))\n\t\t\tdf_from_cache = 1;\n\n\t\trv = iasecc_select_file(card, &ppath, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");\n\n\t\tif (file_out)\n\t\t\t*file_out = file;\n\t\telse\n\t\t   sc_file_free(file);\n\n\t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)\n\t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\t}\n\n\tif (lpath.type == SC_PATH_TYPE_PATH)\n\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\n\tif (!lpath.len)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_df->path.len == lpath.len\n\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {\n\t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));\n\t\tif (file_out)   {\n\t\t\tsc_file_free(*file_out);\n\t\t\tsc_file_dup(file_out, card->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(card);\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu apdu;\n\t\tstruct sc_file *file = NULL;\n\t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\t\tint pathlen = lpath.len;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");\n\n\t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {\n\t\t\tapdu.p1 = 0x02;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {\n\t\t\t\tapdu.p1 = 0x01;\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\t}\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {\n\t\t\tapdu.p1 = 0x09;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {\n\t\t\tapdu.p1 = 0x03;\n\t\t\tpathlen = 0;\n\t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tapdu.p1 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (ii=0; ii<2; ii++)   {\n\t\t\tapdu.lc = pathlen;\n\t\t\tapdu.data = lpath.value;\n\t\t\tapdu.datalen = pathlen;\n\n\t\t\tapdu.resp = rbuf;\n\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\tapdu.le = 256;\n\n\t\t\trv = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&\n\t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {\n\t\t\t\tapdu.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ii)   {\n\t\t\t\t/* 'SELECT AID' do not returned FCP. Try to emulate. */\n\t\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Using of the cached DF and EF can cause problems in the multi-thread environment.\n\t\t * FIXME: introduce config. option that invalidates this cache outside the locked card session,\n\t\t *        (or invent something else)\n\t\t */\n\t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {\n\t\t\tsc_invalidate_cache(card);\n\t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = NULL;\n\t\t\t}\n\t\t\trv = iasecc_select_file(card, path, file_out);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       apdu.resplen);\n\t\tif (apdu.resplen)   {\n\t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);\n\n\t\t\tswitch (apdu.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tfile = sc_file_new();\n\t\t\t\tif (file == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->path = lpath;\n\n\t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);\n\t\t\t\tif (rv)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\n\t\t\tsc_log(ctx, \"FileType %i\", file->type);\n\t\t\tif (file->type == SC_FILE_TYPE_DF)   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_df);\n\t\t\t\tcard->cache.current_df = NULL;\n\n\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_df, file);\n\t\t\t\tcard->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_ef, file);\n\t\t\t}\n\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(file);\n\t\t\t}\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tsc_file_free(card->cache.current_df);\n\t\t\tcard->cache.current_df = NULL;\n\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\tcard->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n {\n \n    s->avctx->profile = get_bits(gb, 4);\n    s->avctx->level   = get_bits(gb, 4);\n \n    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n        s->avctx->level = 0;\n     }\n \n     return 0;\n}\n",
        "post_patch": "static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\nstatic int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n {\n \n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n \n    if (*profile == 0 && *level == 8) {\n        *level = 0;\n     }\n \n     return 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int matchlabel(js_Ast *node, const char *label)\n{\n\twhile (node && node->type == STM_LABEL) {\n\t\tif (!strcmp(node->a->string, label))\n\t\t\treturn 1;\n\t\tnode = node->parent;\n\t}\n\treturn 0;\n}\n",
        "post_patch": "static int matchlabel(js_Ast *node, const char *label)\n{\n\twhile (node && node->type == STM_LABEL) {\n\t\tif (!strcmp(node->a->string, label))\n\t\t\treturn 1;\n\t\tnode = node->parent;\n\t}\n\treturn 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MaxTextExtent],\n    implicit_vr[MaxTextExtent],\n    magick[MaxTextExtent],\n    photometric[MaxTextExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MaxTextExtent);\n  info.polarity=MagickFalse;\n  info.scale=(Quantum *) NULL;\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.significant_bits=0;\n  info.rescale=MagickFalse;\n  info.rescale_intercept=0.0;\n  info.rescale_slope=1.0;\n  info.window_center=0.0;\n  info.window_width=0.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  sequence=MagickFalse;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MaxTextExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MaxTextExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n           if ((quantum != 0) && (length != 0))\n             {\n               if (length > GetBlobSize(image))\n                ThrowReaderException(CorruptImageError,\n                   \"InsufficientImageDataInFile\");\n               if (~length >= 1)\n                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowDCMException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MaxTextExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MaxTextExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowDCMException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            info.samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            for (i=0; i < (ssize_t) MagickMin(length,MaxTextExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            info.bits_allocated=(size_t) datum;\n            info.bytes_per_pixel=1;\n            if (datum > 8)\n              info.bytes_per_pixel=2;\n            info.depth=info.bits_allocated;\n            if (info.depth > 32)\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            info.max_value=(1UL << info.bits_allocated)-1;\n            image->depth=info.depth;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            info.significant_bits=(size_t) datum;\n            info.bytes_per_pixel=1;\n            if (info.significant_bits > 8)\n              info.bytes_per_pixel=2;\n            info.depth=info.significant_bits;\n            if (info.depth > 32)\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            info.max_value=(1UL << info.significant_bits)-1;\n            info.mask=(size_t) GetQuantumRange(info.significant_bits);\n            image->depth=info.depth;\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            info.signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              info.window_center=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              info.window_width=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              info.rescale_intercept=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              info.rescale_slope=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/info.bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (info.bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              info.polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (info.signed_data == 0xffff)\n    info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MaxTextExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"j2k:%s\",\n            filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property));\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(info.depth)+1);\n      info.scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*info.scale));\n      if (info.scale == (Quantum *) NULL)\n        ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(info.depth);\n      for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n        info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image)+8;\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=info.depth;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        break;\n      }\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelPacket *) NULL) &&\n        (info.samples_per_pixel == 1))\n      {\n        int\n          index;\n\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << info.depth;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].red=(Quantum) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].green=(Quantum) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].blue=(Quantum) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].red=(Quantum) index;\n            image->colormap[i].green=(Quantum) index;\n            image->colormap[i].blue=(Quantum) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n        if (stream_info->segment_count > 1)\n          {\n            info.bytes_per_pixel=1;\n            info.depth=8;\n            if (stream_info->offset_count > 0)\n              (void) SeekBlob(image,stream_info->offsets[0]+\n                stream_info->segments[0],SEEK_SET);\n          }\n      }\n    if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        register ssize_t\n          x;\n\n        register PixelPacket\n          *q;\n\n        ssize_t\n          y;\n\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                default:\n                  break;\n              }\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              info.window_width=0;\n          }\n        option=GetImageOption(image_info,\"dcm:window\");\n        if (option != (char *) NULL)\n          {\n            GeometryInfo\n              geometry_info;\n\n            MagickStatusType\n              flags;\n\n            flags=ParseGeometry(option,&geometry_info);\n            if (flags & RhoValue)\n              info.window_center=geometry_info.rho;\n            if (flags & SigmaValue)\n              info.window_width=geometry_info.sigma;\n            info.rescale=MagickTrue;\n          }\n        option=GetImageOption(image_info,\"dcm:rescale\");\n        if (option != (char *) NULL)\n          info.rescale=IsStringTrue(option);\n        if ((info.window_center != 0) && (info.window_width == 0))\n          info.window_width=info.window_center;\n        status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n        if ((status != MagickFalse) && (stream_info->segment_count > 1))\n          {\n            if (stream_info->offset_count > 0)\n              (void) SeekBlob(image,stream_info->offsets[0]+\n                stream_info->segments[1],SEEK_SET);\n            (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,exception);\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowDCMException(exception,message) \\\n{ \\\n  if (data != (unsigned char *) NULL) \\\n    data=(unsigned char *) RelinquishMagickMemory(data); \\\n  if (stream_info != (DCMStreamInfo *) NULL) \\\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    explicit_vr[MaxTextExtent],\n    implicit_vr[MaxTextExtent],\n    magick[MaxTextExtent],\n    photometric[MaxTextExtent];\n\n  DCMInfo\n    info;\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    colors,\n    height,\n    length,\n    number_scenes,\n    quantum,\n    status,\n    width;\n\n  ssize_t\n    count,\n    scene;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  data=(unsigned char *) NULL;\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MaxTextExtent);\n  info.polarity=MagickFalse;\n  info.scale=(Quantum *) NULL;\n  info.bits_allocated=8;\n  info.bytes_per_pixel=1;\n  info.depth=8;\n  info.mask=0xffff;\n  info.max_value=255UL;\n  info.samples_per_pixel=1;\n  info.signed_data=(~0UL);\n  info.significant_bits=0;\n  info.rescale=MagickFalse;\n  info.rescale_intercept=0.0;\n  info.rescale_slope=1.0;\n  info.window_center=0.0;\n  info.window_width=0.0;\n  data=(unsigned char *) NULL;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  number_scenes=1;\n  sequence=MagickFalse;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MaxTextExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MaxTextExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n           if ((quantum != 0) && (length != 0))\n             {\n               if (length > GetBlobSize(image))\n                ThrowDCMException(CorruptImageError,\n                   \"InsufficientImageDataInFile\");\n               if (~length >= 1)\n                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowDCMException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MaxTextExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MaxTextExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowDCMException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            info.samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            for (i=0; i < (ssize_t) MagickMin(length,MaxTextExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            info.polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            info.bits_allocated=(size_t) datum;\n            info.bytes_per_pixel=1;\n            if (datum > 8)\n              info.bytes_per_pixel=2;\n            info.depth=info.bits_allocated;\n            if (info.depth > 32)\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            info.max_value=(1UL << info.bits_allocated)-1;\n            image->depth=info.depth;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            info.significant_bits=(size_t) datum;\n            info.bytes_per_pixel=1;\n            if (info.significant_bits > 8)\n              info.bytes_per_pixel=2;\n            info.depth=info.significant_bits;\n            if (info.depth > 32)\n              ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n            info.max_value=(1UL << info.significant_bits)-1;\n            info.mask=(size_t) GetQuantumRange(info.significant_bits);\n            image->depth=info.depth;\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            info.signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              info.window_center=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              info.window_width=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              info.rescale_intercept=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              info.rescale_slope=StringToDouble((char *) data,\n                (char **) NULL);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/info.bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (info.bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              info.polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (info.signed_data == 0xffff)\n    info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MaxTextExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"j2k:%s\",\n            filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property));\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(info.depth)+1);\n      info.scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*info.scale));\n      if (info.scale == (Quantum *) NULL)\n        ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(info.depth);\n      for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)\n        info.scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image)+8;\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=info.depth;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        break;\n      }\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelPacket *) NULL) &&\n        (info.samples_per_pixel == 1))\n      {\n        int\n          index;\n\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << info.depth;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          ThrowDCMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].red=(Quantum) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].green=(Quantum) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].blue=(Quantum) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((info.scale != (Quantum *) NULL) &&\n                (index <= (int) info.max_value))\n              index=(int) info.scale[index];\n            image->colormap[i].red=(Quantum) index;\n            image->colormap[i].green=(Quantum) index;\n            image->colormap[i].blue=(Quantum) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowDCMException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n        if (stream_info->segment_count > 1)\n          {\n            info.bytes_per_pixel=1;\n            info.depth=8;\n            if (stream_info->offset_count > 0)\n              (void) SeekBlob(image,stream_info->offsets[0]+\n                stream_info->segments[0],SEEK_SET);\n          }\n      }\n    if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        register ssize_t\n          x;\n\n        register PixelPacket\n          *q;\n\n        ssize_t\n          y;\n\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) info.samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                default:\n                  break;\n              }\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              info.window_width=0;\n          }\n        option=GetImageOption(image_info,\"dcm:window\");\n        if (option != (char *) NULL)\n          {\n            GeometryInfo\n              geometry_info;\n\n            MagickStatusType\n              flags;\n\n            flags=ParseGeometry(option,&geometry_info);\n            if (flags & RhoValue)\n              info.window_center=geometry_info.rho;\n            if (flags & SigmaValue)\n              info.window_width=geometry_info.sigma;\n            info.rescale=MagickTrue;\n          }\n        option=GetImageOption(image_info,\"dcm:rescale\");\n        if (option != (char *) NULL)\n          info.rescale=IsStringTrue(option);\n        if ((info.window_center != 0) && (info.window_width == 0))\n          info.window_width=info.window_center;\n        status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);\n        if ((status != MagickFalse) && (stream_info->segment_count > 1))\n          {\n            if (stream_info->offset_count > 0)\n              (void) SeekBlob(image,stream_info->offsets[0]+\n                stream_info->segments[1],SEEK_SET);\n            (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,exception);\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (info.scale != (Quantum *) NULL)\n    info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n",
        "post_patch": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}\n",
        "post_patch": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}\n",
        "label": 1
    },
    {
        "pre_patch": "PHP_METHOD(snmp, __construct)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1, *a2;\n\tint a1_len, a2_len;\n\tlong timeout = SNMP_DEFAULT_TIMEOUT;\n\tlong retries = SNMP_DEFAULT_RETRIES;\n\tlong version = SNMP_DEFAULT_VERSION;\n\tint argc = ZEND_NUM_ARGS();\n\tzend_error_handling error_handling;\n \n        snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n        zend_replace_error_handling(EH_THROW, NULL, &error_handling TSRMLS_CC);\n        if (zend_parse_parameters(argc TSRMLS_CC, \"lss|ll\", &version, &a1, &a1_len, &a2, &a2_len, &timeout, &retries) == FAILURE) {\n                zend_restore_error_handling(&error_handling TSRMLS_CC);\n                return;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n\tswitch(version) {\n\t\tcase SNMP_VERSION_1:\n\t\tcase SNMP_VERSION_2c:\n\t\tcase SNMP_VERSION_3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_throw_exception(zend_exception_get_default(TSRMLS_C), \"Unknown SNMP protocol version\", 0 TSRMLS_CC);\n\t\t\treturn;\n\t}\n\n\t/* handle re-open of snmp session */\n        if (snmp_object->session) {\n                netsnmp_session_free(&(snmp_object->session));\n        }\n        if (netsnmp_session_init(&(snmp_object->session), version, a1, a2, timeout, retries TSRMLS_CC)) {\n                return;\n        }\n\tsnmp_object->max_oids = 0;\n\tsnmp_object->valueretrieval = SNMP_G(valueretrieval);\n\tsnmp_object->enum_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n\tsnmp_object->oid_output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n\tsnmp_object->quick_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n\tsnmp_object->oid_increasing_check = TRUE;\n\tsnmp_object->exceptions_enabled = 0;\n }\n",
        "post_patch": "PHP_METHOD(snmp, __construct)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1, *a2;\n\tint a1_len, a2_len;\n\tlong timeout = SNMP_DEFAULT_TIMEOUT;\n\tlong retries = SNMP_DEFAULT_RETRIES;\n\tlong version = SNMP_DEFAULT_VERSION;\n\tint argc = ZEND_NUM_ARGS();\n\tzend_error_handling error_handling;\n \n        snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n        zend_replace_error_handling(EH_THROW, NULL, &error_handling TSRMLS_CC);\n\n        if (zend_parse_parameters(argc TSRMLS_CC, \"lss|ll\", &version, &a1, &a1_len, &a2, &a2_len, &timeout, &retries) == FAILURE) {\n                zend_restore_error_handling(&error_handling TSRMLS_CC);\n                return;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n\tswitch(version) {\n\t\tcase SNMP_VERSION_1:\n\t\tcase SNMP_VERSION_2c:\n\t\tcase SNMP_VERSION_3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_throw_exception(zend_exception_get_default(TSRMLS_C), \"Unknown SNMP protocol version\", 0 TSRMLS_CC);\n\t\t\treturn;\n\t}\n\n\t/* handle re-open of snmp session */\n        if (snmp_object->session) {\n                netsnmp_session_free(&(snmp_object->session));\n        }\n\n        if (netsnmp_session_init(&(snmp_object->session), version, a1, a2, timeout, retries TSRMLS_CC)) {\n                return;\n        }\n\tsnmp_object->max_oids = 0;\n\tsnmp_object->valueretrieval = SNMP_G(valueretrieval);\n\tsnmp_object->enum_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n\tsnmp_object->oid_output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n\tsnmp_object->quick_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n\tsnmp_object->oid_increasing_check = TRUE;\n\tsnmp_object->exceptions_enabled = 0;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static u32 svc_rdma_get_inv_rkey(struct rpcrdma_msg *rdma_argp,\n\t\t\t\t struct rpcrdma_write_array *wr_ary,\n\t\t\t\t struct rpcrdma_write_array *rp_ary)\n {\n\tstruct rpcrdma_read_chunk *rd_ary;\n\tstruct rpcrdma_segment *arg_ch;\n \n\trd_ary = (struct rpcrdma_read_chunk *)&rdma_argp->rm_body.rm_chunks[0];\n\tif (rd_ary->rc_discrim != xdr_zero)\n\t\treturn be32_to_cpu(rd_ary->rc_target.rs_handle);\n \n\tif (wr_ary && be32_to_cpu(wr_ary->wc_nchunks)) {\n\t\targ_ch = &wr_ary->wc_array[0].wc_target;\n\t\treturn be32_to_cpu(arg_ch->rs_handle);\n\t}\n \n\tif (rp_ary && be32_to_cpu(rp_ary->wc_nchunks)) {\n\t\targ_ch = &rp_ary->wc_array[0].wc_target;\n\t\treturn be32_to_cpu(arg_ch->rs_handle);\n\t}\n \n \treturn 0;\n }\n",
        "post_patch": "static u32 svc_rdma_get_inv_rkey(struct rpcrdma_msg *rdma_argp,\nstatic u32 svc_rdma_get_inv_rkey(__be32 *rdma_argp,\n\t\t\t\t __be32 *wr_lst, __be32 *rp_ch)\n {\n\t__be32 *p;\n \n\tp = rdma_argp + rpcrdma_fixed_maxsz;\n\tif (*p != xdr_zero)\n\t\tp += 2;\n\telse if (wr_lst && be32_to_cpup(wr_lst + 1))\n\t\tp = wr_lst + 2;\n\telse if (rp_ch && be32_to_cpup(rp_ch + 1))\n\t\tp = rp_ch + 2;\n\telse\n\t\treturn 0;\n\treturn be32_to_cpup(p);\n}\n \n/* ib_dma_map_page() is used here because svc_rdma_dma_unmap()\n * is used during completion to DMA-unmap this memory, and\n * it uses ib_dma_unmap_page() exclusively.\n */\nstatic int svc_rdma_dma_map_buf(struct svcxprt_rdma *rdma,\n\t\t\t\tstruct svc_rdma_op_ctxt *ctxt,\n\t\t\t\tunsigned int sge_no,\n\t\t\t\tunsigned char *base,\n\t\t\t\tunsigned int len)\n{\n\tunsigned long offset = (unsigned long)base & ~PAGE_MASK;\n\tstruct ib_device *dev = rdma->sc_cm_id->device;\n\tdma_addr_t dma_addr;\n \n\tdma_addr = ib_dma_map_page(dev, virt_to_page(base),\n\t\t\t\t   offset, len, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(dev, dma_addr))\n\t\treturn -EIO;\n \n\tctxt->sge[sge_no].addr = dma_addr;\n\tctxt->sge[sge_no].length = len;\n\tctxt->sge[sge_no].lkey = rdma->sc_pd->local_dma_lkey;\n\tsvc_rdma_count_mappings(rdma, ctxt);\n \treturn 0;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "CStarter::Hold( void )\n{\t\n\tbool jobRunning = false;\n\tUserProc *job;\n\n\tdprintf( D_ALWAYS, \"Hold all jobs\\n\" );\n\n\tif ( this->deferral_tid != -1 ) {\n\t\tthis->removeDeferredJobs();\n\t}\n\n\tm_job_list.Rewind();\n\twhile( (job = m_job_list.Next()) != NULL ) {\n\t\tif( job->Hold() ) {\n\t\t\tm_job_list.DeleteCurrent();\n\t\t\tdelete job;\n\t\t} else {\n\t\t\tjobRunning = true;\n\t\t}\n\t}\n\tShuttingDown = TRUE;\n\treturn ( !jobRunning );\n}\n",
        "post_patch": "CStarter::Hold( void )\n{\t\n\tbool jobRunning = false;\n\tUserProc *job;\n\n\tdprintf( D_ALWAYS, \"Hold all jobs\\n\" );\n\n\tif ( this->deferral_tid != -1 ) {\n\t\tthis->removeDeferredJobs();\n\t}\n\n\tm_job_list.Rewind();\n\twhile( (job = m_job_list.Next()) != NULL ) {\n\t\tif( job->Hold() ) {\n\t\t\tm_job_list.DeleteCurrent();\n\t\t\tdelete job;\n\t\t} else {\n\t\t\tjobRunning = true;\n\t\t}\n\t}\n\tShuttingDown = TRUE;\n\treturn ( !jobRunning );\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n \t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n \tstruct rtable *rt;\n \n \t/*\n\t * setup for corking.\n\t */\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n \t\t\tif (unlikely(cork->opt == NULL))\n \t\t\t\treturn -ENOBUFS;\n \t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n \t\tcork->flags |= IPCORK_OPT;\n \t\tcork->addr = ipc->addr;\n \t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t/*\n\t * We steal reference to this route, caller should not release it\n\t */\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}\n",
        "post_patch": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n \t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *opt;\n \tstruct rtable *rt;\n \n \t/*\n\t * setup for corking.\n\t */\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n \t\t\tif (unlikely(cork->opt == NULL))\n \t\t\t\treturn -ENOBUFS;\n \t\t}\n\t\tmemcpy(cork->opt, &opt->opt, sizeof(struct ip_options) + opt->opt.optlen);\n \t\tcork->flags |= IPCORK_OPT;\n \t\tcork->addr = ipc->addr;\n \t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t/*\n\t * We steal reference to this route, caller should not release it\n\t */\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (ret < local_nr_pages) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n \t\toffset = offset_in_page(uaddr);\n \t\tfor (j = cur_page; j < page_limit; j++) {\n \t\t\tunsigned int bytes = PAGE_SIZE - offset;\n \n \t\t\tif (len <= 0)\n \t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n \t\t\t\t\t    bytes)\n \t\t\t\tbreak;\n \n \t\t\tlen -= bytes;\n \t\t\toffset = 0;\n \t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tfor (j = 0; j < nr_pages; j++) {\n\t\tif (!pages[j])\n\t\t\tbreak;\n\t\tput_page(pages[j]);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}\n",
        "post_patch": "struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (ret < local_nr_pages) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n \t\toffset = offset_in_page(uaddr);\n \t\tfor (j = cur_page; j < page_limit; j++) {\n \t\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;\n \n \t\t\tif (len <= 0)\n \t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n \t\t\t\t\t    bytes)\n \t\t\t\tbreak;\n \n\t\t\t/*\n\t\t\t * check if vector was merged with previous\n\t\t\t * drop page reference if needed\n\t\t\t */\n\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)\n\t\t\t\tput_page(pages[j]);\n\n \t\t\tlen -= bytes;\n \t\t\toffset = 0;\n \t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tfor (j = 0; j < nr_pages; j++) {\n\t\tif (!pages[j])\n\t\t\tbreak;\n\t\tput_page(pages[j]);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "INST_HANDLER (pop) {\t// POP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\t__generic_pop (op, 1);\n\tESIL_A (\"r%d,=,\", d);\t// store in Rd\n\n}\n",
        "post_patch": "INST_HANDLER (pop) {\t// POP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\t__generic_pop (op, 1);\n\tESIL_A (\"r%d,=,\", d);\t// store in Rd\n\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n \n     if (length != 0)\n       {\n         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*chunk));\n \n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}\n",
        "post_patch": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n \n     if (length != 0)\n       {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*chunk));\n \n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static struct ffs_dev *_ffs_get_single_dev(void)\n{\n\tstruct ffs_dev *dev;\n\n\tif (list_is_singular(&ffs_devices)) {\n\t\tdev = list_first_entry(&ffs_devices, struct ffs_dev, entry);\n\t\tif (dev->single)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n",
        "post_patch": "static struct ffs_dev *_ffs_get_single_dev(void)\n{\n\tstruct ffs_dev *dev;\n\n\tif (list_is_singular(&ffs_devices)) {\n\t\tdev = list_first_entry(&ffs_devices, struct ffs_dev, entry);\n\t\tif (dev->single)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n \n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n\t\treturn res;\n \n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\n \n \treturn res;\n }\n",
        "post_patch": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n \n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n\t\tgoto err_add_port;\n \n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\nerr_add_port:\n\thsr_del_node(&hsr->self_node_db);\n \n \treturn res;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\n\t\t      unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_INFO:\n\t\treturn 0;\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_pcm_lib_ioctl_reset(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\treturn snd_pcm_lib_ioctl_channel_info(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_FIFO_SIZE:\n\t\treturn snd_pcm_lib_ioctl_fifo_size(substream, arg);\n\t}\n\treturn -ENXIO;\n}\n",
        "post_patch": "int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\n\t\t      unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_INFO:\n\t\treturn 0;\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_pcm_lib_ioctl_reset(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\treturn snd_pcm_lib_ioctl_channel_info(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_FIFO_SIZE:\n\t\treturn snd_pcm_lib_ioctl_fifo_size(substream, arg);\n\t}\n\treturn -ENXIO;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "WebGLRenderingContextBase::~WebGLRenderingContextBase() {\n   destruction_in_progress_ = true;\n \n  DestroyContext();\n\n  RestoreEvictedContext(this);\n}\n",
        "post_patch": "WebGLRenderingContextBase::~WebGLRenderingContextBase() {\n   destruction_in_progress_ = true;\n \n  clearProgramCompletionQueries();\n\n  DestroyContext();\n\n  RestoreEvictedContext(this);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "RenderView* RenderFrameImpl::GetRenderView() {\n  return render_view_;\n}\n",
        "post_patch": "RenderView* RenderFrameImpl::GetRenderView() {\n  return render_view_;\n}\n",
        "label": 0
    },
    {
        "pre_patch": " void dump_mm(const struct mm_struct *mm)\n {\n\tpr_emerg(\"mm %px mmap %px seqnum %d task_size %lu\\n\"\n #ifdef CONFIG_MMU\n \t\t\"get_unmapped_area %px\\n\"\n #endif\n\t\t\"mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\\n\"\n\t\t\"pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"\n\t\t\"hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\\n\"\n\t\t\"pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\\n\"\n\t\t\"start_code %lx end_code %lx start_data %lx end_data %lx\\n\"\n\t\t\"start_brk %lx brk %lx start_stack %lx\\n\"\n\t\t\"arg_start %lx arg_end %lx env_start %lx env_end %lx\\n\"\n\t\t\"binfmt %px flags %lx core_state %px\\n\"\n#ifdef CONFIG_AIO\n\t\t\"ioctx_table %px\\n\"\n#endif\n#ifdef CONFIG_MEMCG\n\t\t\"owner %px \"\n#endif\n\t\t\"exe_file %px\\n\"\n#ifdef CONFIG_MMU_NOTIFIER\n\t\t\"mmu_notifier_mm %px\\n\"\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\t\"numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\\n\"\n#endif\n \t\t\"tlb_flush_pending %d\\n\"\n \t\t\"def_flags: %#lx(%pGv)\\n\",\n \n\t\tmm, mm->mmap, mm->vmacache_seqnum, mm->task_size,\n #ifdef CONFIG_MMU\n \t\tmm->get_unmapped_area,\n #endif\n\t\tmm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end,\n\t\tmm->pgd, atomic_read(&mm->mm_users),\n\t\tatomic_read(&mm->mm_count),\n\t\tmm_pgtables_bytes(mm),\n\t\tmm->map_count,\n\t\tmm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm,\n\t\tmm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm,\n\t\tmm->start_code, mm->end_code, mm->start_data, mm->end_data,\n\t\tmm->start_brk, mm->brk, mm->start_stack,\n\t\tmm->arg_start, mm->arg_end, mm->env_start, mm->env_end,\n\t\tmm->binfmt, mm->flags, mm->core_state,\n#ifdef CONFIG_AIO\n\t\tmm->ioctx_table,\n#endif\n#ifdef CONFIG_MEMCG\n\t\tmm->owner,\n#endif\n\t\tmm->exe_file,\n#ifdef CONFIG_MMU_NOTIFIER\n\t\tmm->mmu_notifier_mm,\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\tmm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq,\n#endif\n\t\tatomic_read(&mm->tlb_flush_pending),\n\t\tmm->def_flags, &mm->def_flags\n\t);\n}\n",
        "post_patch": " void dump_mm(const struct mm_struct *mm)\n {\n\tpr_emerg(\"mm %px mmap %px seqnum %llu task_size %lu\\n\"\n #ifdef CONFIG_MMU\n \t\t\"get_unmapped_area %px\\n\"\n #endif\n\t\t\"mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\\n\"\n\t\t\"pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"\n\t\t\"hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\\n\"\n\t\t\"pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\\n\"\n\t\t\"start_code %lx end_code %lx start_data %lx end_data %lx\\n\"\n\t\t\"start_brk %lx brk %lx start_stack %lx\\n\"\n\t\t\"arg_start %lx arg_end %lx env_start %lx env_end %lx\\n\"\n\t\t\"binfmt %px flags %lx core_state %px\\n\"\n#ifdef CONFIG_AIO\n\t\t\"ioctx_table %px\\n\"\n#endif\n#ifdef CONFIG_MEMCG\n\t\t\"owner %px \"\n#endif\n\t\t\"exe_file %px\\n\"\n#ifdef CONFIG_MMU_NOTIFIER\n\t\t\"mmu_notifier_mm %px\\n\"\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\t\"numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\\n\"\n#endif\n \t\t\"tlb_flush_pending %d\\n\"\n \t\t\"def_flags: %#lx(%pGv)\\n\",\n \n\t\tmm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,\n #ifdef CONFIG_MMU\n \t\tmm->get_unmapped_area,\n #endif\n\t\tmm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end,\n\t\tmm->pgd, atomic_read(&mm->mm_users),\n\t\tatomic_read(&mm->mm_count),\n\t\tmm_pgtables_bytes(mm),\n\t\tmm->map_count,\n\t\tmm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm,\n\t\tmm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm,\n\t\tmm->start_code, mm->end_code, mm->start_data, mm->end_data,\n\t\tmm->start_brk, mm->brk, mm->start_stack,\n\t\tmm->arg_start, mm->arg_end, mm->env_start, mm->env_end,\n\t\tmm->binfmt, mm->flags, mm->core_state,\n#ifdef CONFIG_AIO\n\t\tmm->ioctx_table,\n#endif\n#ifdef CONFIG_MEMCG\n\t\tmm->owner,\n#endif\n\t\tmm->exe_file,\n#ifdef CONFIG_MMU_NOTIFIER\n\t\tmm->mmu_notifier_mm,\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\tmm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq,\n#endif\n\t\tatomic_read(&mm->tlb_flush_pending),\n\t\tmm->def_flags, &mm->def_flags\n\t);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "pdf14_custom_put_image(gx_device * dev, gs_gstate * pgs, gx_device * target)\n{\n    pdf14_device * pdev = (pdf14_device *)dev;\n    pdf14_buf *buf = pdev->ctx->stack;\n    gs_int_rect rect = buf->rect;\n    int x0 = rect.p.x, y0 = rect.p.y;\n    int planestride = buf->planestride;\n    int rowstride = buf->rowstride;\n    int num_comp = buf->n_chan - 1;\n    const byte bg = pdev->ctx->additive ? 0xff : 0;\n    int x1, y1, width, height;\n    byte *buf_ptr;\n\n    if_debug0m('v', dev->memory, \"[v]pdf14_custom_put_image\\n\");\n    rect_intersect(rect, buf->dirty);\n    x1 = min(pdev->width, rect.q.x);\n    y1 = min(pdev->height, rect.q.y);\n    width = x1 - rect.p.x;\n    height = y1 - rect.p.y;\n    if (width <= 0 || height <= 0 || buf->data == NULL)\n        return 0;\n    buf_ptr = buf->data + rect.p.y * buf->rowstride + rect.p.x;\n\n    return gx_put_blended_image_custom(target, buf_ptr,\n                      planestride, rowstride,\n                      x0, y0, width, height, num_comp, bg);\n}\n",
        "post_patch": "pdf14_custom_put_image(gx_device * dev, gs_gstate * pgs, gx_device * target)\n{\n    pdf14_device * pdev = (pdf14_device *)dev;\n    pdf14_buf *buf = pdev->ctx->stack;\n    gs_int_rect rect = buf->rect;\n    int x0 = rect.p.x, y0 = rect.p.y;\n    int planestride = buf->planestride;\n    int rowstride = buf->rowstride;\n    int num_comp = buf->n_chan - 1;\n    const byte bg = pdev->ctx->additive ? 0xff : 0;\n    int x1, y1, width, height;\n    byte *buf_ptr;\n\n    if_debug0m('v', dev->memory, \"[v]pdf14_custom_put_image\\n\");\n    rect_intersect(rect, buf->dirty);\n    x1 = min(pdev->width, rect.q.x);\n    y1 = min(pdev->height, rect.q.y);\n    width = x1 - rect.p.x;\n    height = y1 - rect.p.y;\n    if (width <= 0 || height <= 0 || buf->data == NULL)\n        return 0;\n    buf_ptr = buf->data + rect.p.y * buf->rowstride + rect.p.x;\n\n    return gx_put_blended_image_custom(target, buf_ptr,\n                      planestride, rowstride,\n                      x0, y0, width, height, num_comp, bg);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void PDFiumEngine::FillPageSides(int progressive_index) {\n  DCHECK_GE(progressive_index, 0);\n  DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());\n\n  int page_index = progressive_paints_[progressive_index].page_index;\n  const pp::Rect& dirty_in_screen = progressive_paints_[progressive_index].rect;\n  FPDF_BITMAP bitmap = progressive_paints_[progressive_index].bitmap;\n\n  pp::Rect page_rect = pages_[page_index]->rect();\n  if (page_rect.x() > 0) {\n    pp::Rect left(0, page_rect.y() - kPageShadowTop,\n                  page_rect.x() - kPageShadowLeft,\n                  page_rect.height() + kPageShadowTop + kPageShadowBottom +\n                      kPageSeparatorThickness);\n    left = GetScreenRect(left).Intersect(dirty_in_screen);\n\n    FPDFBitmap_FillRect(bitmap, left.x() - dirty_in_screen.x(),\n                        left.y() - dirty_in_screen.y(), left.width(),\n                        left.height(), client_->GetBackgroundColor());\n  }\n\n  if (page_rect.right() < document_size_.width()) {\n    pp::Rect right(\n        page_rect.right() + kPageShadowRight, page_rect.y() - kPageShadowTop,\n        document_size_.width() - page_rect.right() - kPageShadowRight,\n        page_rect.height() + kPageShadowTop + kPageShadowBottom +\n            kPageSeparatorThickness);\n    right = GetScreenRect(right).Intersect(dirty_in_screen);\n\n    FPDFBitmap_FillRect(bitmap, right.x() - dirty_in_screen.x(),\n                        right.y() - dirty_in_screen.y(), right.width(),\n                        right.height(), client_->GetBackgroundColor());\n  }\n\n  pp::Rect bottom(page_rect.x() - kPageShadowLeft,\n                  page_rect.bottom() + kPageShadowBottom,\n                  page_rect.width() + kPageShadowLeft + kPageShadowRight,\n                  kPageSeparatorThickness);\n  bottom = GetScreenRect(bottom).Intersect(dirty_in_screen);\n\n  FPDFBitmap_FillRect(bitmap, bottom.x() - dirty_in_screen.x(),\n                      bottom.y() - dirty_in_screen.y(), bottom.width(),\n                      bottom.height(), client_->GetBackgroundColor());\n}\n",
        "post_patch": "void PDFiumEngine::FillPageSides(int progressive_index) {\n  DCHECK_GE(progressive_index, 0);\n  DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());\n\n  int page_index = progressive_paints_[progressive_index].page_index;\n  const pp::Rect& dirty_in_screen = progressive_paints_[progressive_index].rect;\n  FPDF_BITMAP bitmap = progressive_paints_[progressive_index].bitmap;\n\n  pp::Rect page_rect = pages_[page_index]->rect();\n  if (page_rect.x() > 0) {\n    pp::Rect left(0, page_rect.y() - kPageShadowTop,\n                  page_rect.x() - kPageShadowLeft,\n                  page_rect.height() + kPageShadowTop + kPageShadowBottom +\n                      kPageSeparatorThickness);\n    left = GetScreenRect(left).Intersect(dirty_in_screen);\n\n    FPDFBitmap_FillRect(bitmap, left.x() - dirty_in_screen.x(),\n                        left.y() - dirty_in_screen.y(), left.width(),\n                        left.height(), client_->GetBackgroundColor());\n  }\n\n  if (page_rect.right() < document_size_.width()) {\n    pp::Rect right(\n        page_rect.right() + kPageShadowRight, page_rect.y() - kPageShadowTop,\n        document_size_.width() - page_rect.right() - kPageShadowRight,\n        page_rect.height() + kPageShadowTop + kPageShadowBottom +\n            kPageSeparatorThickness);\n    right = GetScreenRect(right).Intersect(dirty_in_screen);\n\n    FPDFBitmap_FillRect(bitmap, right.x() - dirty_in_screen.x(),\n                        right.y() - dirty_in_screen.y(), right.width(),\n                        right.height(), client_->GetBackgroundColor());\n  }\n\n  pp::Rect bottom(page_rect.x() - kPageShadowLeft,\n                  page_rect.bottom() + kPageShadowBottom,\n                  page_rect.width() + kPageShadowLeft + kPageShadowRight,\n                  kPageSeparatorThickness);\n  bottom = GetScreenRect(bottom).Intersect(dirty_in_screen);\n\n  FPDFBitmap_FillRect(bitmap, bottom.x() - dirty_in_screen.x(),\n                      bottom.y() - dirty_in_screen.y(), bottom.width(),\n                      bottom.height(), client_->GetBackgroundColor());\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\treturn;\n\t}\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tdown_read(&curseg->journal_rwsem);\n\ti = lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(journal, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\tup_read(&nm_i->nat_tree_lock);\n\t/* cache nat entry */\n\tdown_write(&nm_i->nat_tree_lock);\n\tcache_nat_entry(sbi, nid, &ne);\n\tup_write(&nm_i->nat_tree_lock);\n}\n",
        "post_patch": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\treturn;\n\t}\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tdown_read(&curseg->journal_rwsem);\n\ti = lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(journal, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\tup_read(&nm_i->nat_tree_lock);\n\t/* cache nat entry */\n\tdown_write(&nm_i->nat_tree_lock);\n\tcache_nat_entry(sbi, nid, &ne);\n\tup_write(&nm_i->nat_tree_lock);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int dev_loopback_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb_reset_mac_header(skb);\n\t__skb_pull(skb, skb_network_offset(skb));\n\tskb->pkt_type = PACKET_LOOPBACK;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tWARN_ON(!skb_dst(skb));\n\tskb_dst_force(skb);\n\tnetif_rx_ni(skb);\n\treturn 0;\n}\n",
        "post_patch": "int dev_loopback_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb_reset_mac_header(skb);\n\t__skb_pull(skb, skb_network_offset(skb));\n\tskb->pkt_type = PACKET_LOOPBACK;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tWARN_ON(!skb_dst(skb));\n\tskb_dst_force(skb);\n\tnetif_rx_ni(skb);\n\treturn 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "DataReductionProxyIOData::DataReductionProxyIOData(\n    Client client,\n    PrefService* prefs,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    bool enabled,\n    const std::string& user_agent,\n    const std::string& channel)\n    : client_(client),\n      network_connection_tracker_(network_connection_tracker),\n      io_task_runner_(io_task_runner),\n      ui_task_runner_(ui_task_runner),\n      enabled_(enabled),\n      channel_(channel),\n      effective_connection_type_(net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {\n  DCHECK(io_task_runner_);\n  DCHECK(ui_task_runner_);\n  configurator_.reset(new DataReductionProxyConfigurator());\n  configurator_->SetConfigUpdatedCallback(base::BindRepeating(\n      &DataReductionProxyIOData::OnProxyConfigUpdated, base::Unretained(this)));\n  DataReductionProxyMutableConfigValues* raw_mutable_config = nullptr;\n    std::unique_ptr<DataReductionProxyMutableConfigValues> mutable_config =\n        std::make_unique<DataReductionProxyMutableConfigValues>();\n    raw_mutable_config = mutable_config.get();\n    config_.reset(new DataReductionProxyConfig(\n        io_task_runner, ui_task_runner, network_connection_tracker_,\n        std::move(mutable_config), configurator_.get()));\n    request_options_.reset(\n        new DataReductionProxyRequestOptions(client_, config_.get()));\n    request_options_->Init();\n    request_options_->SetUpdateHeaderCallback(base::BindRepeating(\n        &DataReductionProxyIOData::UpdateProxyRequestHeaders,\n        base::Unretained(this)));\n\n    config_client_.reset(new DataReductionProxyConfigServiceClient(\n        GetBackoffPolicy(), request_options_.get(), raw_mutable_config,\n        config_.get(), this, network_connection_tracker_,\n        base::BindRepeating(&DataReductionProxyIOData::StoreSerializedConfig,\n                            base::Unretained(this))));\n \n     network_properties_manager_.reset(new NetworkPropertiesManager(\n         base::DefaultClock::GetInstance(), prefs, ui_task_runner_));\n}\n",
        "post_patch": "DataReductionProxyIOData::DataReductionProxyIOData(\n    Client client,\n    PrefService* prefs,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    bool enabled,\n    const std::string& user_agent,\n    const std::string& channel)\n    : client_(client),\n      network_connection_tracker_(network_connection_tracker),\n      io_task_runner_(io_task_runner),\n      ui_task_runner_(ui_task_runner),\n      enabled_(enabled),\n      channel_(channel),\n      effective_connection_type_(net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {\n  DCHECK(io_task_runner_);\n  DCHECK(ui_task_runner_);\n  configurator_.reset(new DataReductionProxyConfigurator());\n  configurator_->SetConfigUpdatedCallback(base::BindRepeating(\n      &DataReductionProxyIOData::OnProxyConfigUpdated, base::Unretained(this)));\n  DataReductionProxyMutableConfigValues* raw_mutable_config = nullptr;\n    std::unique_ptr<DataReductionProxyMutableConfigValues> mutable_config =\n        std::make_unique<DataReductionProxyMutableConfigValues>();\n    raw_mutable_config = mutable_config.get();\n    config_.reset(new DataReductionProxyConfig(\n        io_task_runner, ui_task_runner, network_connection_tracker_,\n        std::move(mutable_config), configurator_.get()));\n    request_options_.reset(\n        new DataReductionProxyRequestOptions(client_, config_.get()));\n    request_options_->Init();\n    request_options_->SetUpdateHeaderCallback(base::BindRepeating(\n        &DataReductionProxyIOData::UpdateProxyRequestHeaders,\n        base::Unretained(this)));\n\n    if (!params::IsIncludedInHoldbackFieldTrial()) {\n      config_client_.reset(new DataReductionProxyConfigServiceClient(\n          GetBackoffPolicy(), request_options_.get(), raw_mutable_config,\n          config_.get(), this, network_connection_tracker_,\n          base::BindRepeating(&DataReductionProxyIOData::StoreSerializedConfig,\n                              base::Unretained(this))));\n    }\n \n     network_properties_manager_.reset(new NetworkPropertiesManager(\n         base::DefaultClock::GetInstance(), prefs, ui_task_runner_));\n}\n",
        "label": 1
    },
    {
        "pre_patch": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 230 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n#line 1661 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 242 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\n\n        ERROR_IF(rule == NULL);\n\n        (yyval.rule) = rule;\n      }\n#line 1674 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 251 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1686 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 259 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free((yyvsp[-8].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1701 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 274 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = NULL;\n      }\n#line 1709 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 278 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1736 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 305 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = NULL;\n      }\n#line 1744 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 309 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1771 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 340 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 341 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 346 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 347 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 353 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = NULL;\n      }\n#line 1803 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 357 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1821 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 375 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = identifier;\n      }\n#line 1838 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 388 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1874 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 424 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 425 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 431 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0);\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1906 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 447 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer));\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1923 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 460 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer));\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1940 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 473 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            TRUE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1957 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 486 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            FALSE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1974 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 502 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 503 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 509 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 1994 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 513 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n        compiler->error_line = 0;\n      }\n#line 2009 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 524 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 2017 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 528 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n\n        compiler->error_line = 0;\n      }\n#line 2033 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 540 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n      }\n#line 2047 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 553 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0; }\n#line 2053 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 554 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 559 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 560 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 561 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 562 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 568 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2172 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 653 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2222 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 699 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2283 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 757 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2328 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 801 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 802 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 807 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n            break;\n        }\n\n        ERROR_IF((yyval.c_string) == NULL);\n      }\n#line 2369 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 832 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n        {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n              break;\n          }\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2405 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 868 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2451 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 914 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2474 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 936 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2487 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 945 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2500 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 954 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2519 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 969 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2535 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 981 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2553 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 995 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2570 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 1008 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2585 \"grammar.c\" /* yacc.c:1646  */\n    break;\n \n   case 62:\n #line 1019 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int var_index;\n \n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 2619 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 63:\n#line 1049 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n#line 2658 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 64:\n#line 1084 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2741 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 65:\n#line 1163 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n#line 2775 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 66:\n#line 1193 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n#line 2828 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 67:\n#line 1242 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2838 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 68:\n#line 1248 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2848 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 69:\n#line 1254 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2878 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 70:\n#line 1280 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2918 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 71:\n#line 1316 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2947 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 72:\n#line 1341 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2987 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 73:\n#line 1377 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3000 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 74:\n#line 1386 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3013 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 75:\n#line 1395 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3026 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 76:\n#line 1404 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3039 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 77:\n#line 1413 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3052 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 78:\n#line 1422 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3065 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 79:\n#line 1431 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3073 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 80:\n#line 1435 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3081 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 81:\n#line 1442 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3087 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 82:\n#line 1443 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3093 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 83:\n#line 1449 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3115 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 84:\n#line 1471 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3131 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 85:\n#line 1483 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3146 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 86:\n#line 1498 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3155 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 88:\n#line 1504 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3166 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 91:\n#line 1521 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3177 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 92:\n#line 1528 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3188 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 94:\n#line 1540 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3196 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 95:\n#line 1544 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n#line 3204 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 96:\n#line 1552 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3212 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 97:\n#line 1556 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3226 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 98:\n#line 1566 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3244 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 99:\n#line 1580 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3264 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 100:\n#line 1596 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n#line 3278 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 101:\n#line 1606 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n#line 3291 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 102:\n#line 1615 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n#line 3320 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 103:\n#line 1640 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3336 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 104:\n#line 1652 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3352 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 105:\n#line 1664 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3372 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 106:\n#line 1680 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3388 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 107:\n#line 1692 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3408 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 108:\n#line 1708 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3457 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 109:\n#line 1753 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3480 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 110:\n#line 1772 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3502 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 111:\n#line 1790 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3524 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 112:\n#line 1808 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3546 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 113:\n#line 1826 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3576 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 114:\n#line 1852 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n#line 3598 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 115:\n#line 1870 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3612 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 116:\n#line 1880 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3626 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 117:\n#line 1890 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3640 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 118:\n#line 1900 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n#line 3654 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 119:\n#line 1910 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3668 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 120:\n#line 1920 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3682 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 121:\n#line 1930 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3690 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n \n#line 3694 \"grammar.c\" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n #endif\n   return yyresult;\n }\n",
        "post_patch": "yyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 230 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n      }\n#line 1661 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 242 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));\n\n        ERROR_IF(rule == NULL);\n\n        (yyval.rule) = rule;\n      }\n#line 1674 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 251 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1686 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 259 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1\n\n        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, rule);\n\n        yr_free((yyvsp[-8].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1701 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 274 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = NULL;\n      }\n#line 1709 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 278 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 1736 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 305 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = NULL;\n      }\n#line 1744 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 309 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        compiler->last_result = yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1771 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 340 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0;  }\n#line 1777 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 341 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1783 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 346 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1789 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 347 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1795 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 353 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = NULL;\n      }\n#line 1803 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 357 \"grammar.y\" /* yacc.c:1646  */\n    {\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1821 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 375 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* identifier;\n\n        compiler->last_result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = identifier;\n      }\n#line 1838 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 388 \"grammar.y\" /* yacc.c:1646  */\n    {\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1874 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 424 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1880 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 425 \"grammar.y\" /* yacc.c:1646  */\n    {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1886 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 431 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0);\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1906 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 447 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer));\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1923 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 460 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer));\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1940 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 473 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            TRUE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1957 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 486 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.meta) = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            FALSE);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF((yyval.meta) == NULL);\n      }\n#line 1974 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 502 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[0].string); }\n#line 1980 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 503 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.string) = (yyvsp[-1].string); }\n#line 1986 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 509 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 1994 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 513 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n        compiler->error_line = 0;\n      }\n#line 2009 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 524 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->error_line = yyget_lineno(yyscanner);\n      }\n#line 2017 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 528 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n\n        compiler->error_line = 0;\n      }\n#line 2033 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 540 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.string) = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        ERROR_IF((yyval.string) == NULL);\n      }\n#line 2047 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 553 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = 0; }\n#line 2053 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 554 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2059 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 559 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2065 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 560 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2071 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 561 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2077 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 562 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2083 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 568 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          compiler->last_result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            compiler->last_result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2172 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 653 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (compiler->last_result == ERROR_SUCCESS)\n              compiler->last_result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            compiler->last_result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2222 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 699 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            compiler->last_result = ERROR_WRONG_TYPE;\n          }\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_INDEXABLE;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2283 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 757 \"grammar.y\" /* yacc.c:1646  */\n    {\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          compiler->last_result = yr_parser_check_types(\n              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_arena_write_string(\n              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (compiler->last_result == ERROR_SUCCESS)\n            compiler->last_result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          compiler->last_result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n      }\n#line 2328 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 801 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2334 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 802 \"grammar.y\" /* yacc.c:1646  */\n    { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2340 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 807 \"grammar.y\" /* yacc.c:1646  */\n    {\n        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n            break;\n        }\n\n        ERROR_IF((yyval.c_string) == NULL);\n      }\n#line 2369 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 832 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n        {\n          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n              break;\n          }\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2405 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 868 \"grammar.y\" /* yacc.c:1646  */\n    {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        RE* re;\n        RE_ERROR error;\n\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        compiler->last_result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re->root_node->forward_code,\n              NULL,\n              NULL);\n\n        yr_re_destroy(re);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2451 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 914 \"grammar.y\" /* yacc.c:1646  */\n    {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL);\n\n          ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2474 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 936 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2487 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 945 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2500 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 954 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit(\n              yyscanner,\n              OP_MATCHES,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2519 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 969 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2535 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 981 \"grammar.y\" /* yacc.c:1646  */\n    {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2553 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 995 \"grammar.y\" /* yacc.c:1646  */\n    {\n        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2570 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 1008 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->last_result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2585 \"grammar.c\" /* yacc.c:1646  */\n    break;\n \n   case 62:\n #line 1019 \"grammar.y\" /* yacc.c:1646  */\n    {\n        compiler->loop_depth--;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n      }\n#line 2594 \"grammar.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 1024 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int var_index;\n \n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          compiler->last_result = \\\n              ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 2628 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 64:\n#line 1054 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n#line 2667 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 65:\n#line 1089 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2750 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 66:\n#line 1168 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n\n        if (compiler->loop_depth == MAX_LOOP_NESTING)\n          compiler->last_result = \\\n            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          compiler->last_result = \\\n            ERROR_NESTED_FOR_OF_LOOP;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n#line 2784 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 67:\n#line 1198 \"grammar.y\" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n#line 2837 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 68:\n#line 1247 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2847 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 69:\n#line 1253 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2857 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 70:\n#line 1259 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2887 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 71:\n#line 1285 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(and_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2927 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 72:\n#line 1321 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n\n        compiler->last_result = yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        fixup->address = jmp_destination_addr;\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n#line 2956 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 73:\n#line 1346 \"grammar.y\" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n\n\n        compiler->last_result = yr_arena_reserve_memory(\n            compiler->code_arena, 2);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n\n        fixup = compiler->fixup_stack_head;\n\n\n        *(void**)(fixup->address) = (void*)(or_addr + 1);\n\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 2996 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 74:\n#line 1382 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3009 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 75:\n#line 1391 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3022 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 76:\n#line 1400 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3035 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 77:\n#line 1409 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3048 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 78:\n#line 1418 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3061 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 79:\n#line 1427 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n#line 3074 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 80:\n#line 1436 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3082 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 81:\n#line 1440 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3090 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 82:\n#line 1447 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3096 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 83:\n#line 1448 \"grammar.y\" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3102 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 84:\n#line 1454 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3124 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 85:\n#line 1476 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3140 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 86:\n#line 1488 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          compiler->last_result = ERROR_WRONG_TYPE;\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3155 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 87:\n#line 1503 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3164 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 89:\n#line 1509 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3175 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 92:\n#line 1526 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3186 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 93:\n#line 1533 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3197 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 95:\n#line 1545 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n#line 3205 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 96:\n#line 1549 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n#line 3213 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 97:\n#line 1557 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n#line 3221 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 98:\n#line 1561 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3235 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 99:\n#line 1571 \"grammar.y\" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3253 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 100:\n#line 1585 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n\n        compiler->last_result = yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3273 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 101:\n#line 1601 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n#line 3287 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 102:\n#line 1611 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n#line 3300 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 103:\n#line 1620 \"grammar.y\" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n        compiler->last_result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n#line 3329 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 104:\n#line 1645 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3345 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 105:\n#line 1657 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3361 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 106:\n#line 1669 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3381 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 107:\n#line 1685 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3397 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 108:\n#line 1697 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (compiler->last_result == ERROR_SUCCESS)\n          compiler->last_result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n#line 3417 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 109:\n#line 1713 \"grammar.y\" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          compiler->last_result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              compiler->last_result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(FALSE);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3466 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 110:\n#line 1758 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n#line 3489 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 111:\n#line 1777 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3511 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 112:\n#line 1795 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3533 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 113:\n#line 1813 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3555 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 114:\n#line 1831 \"grammar.y\" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            compiler->last_result = ERROR_DIVISION_BY_ZERO;\n            ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n          }\n        }\n        else\n        {\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n#line 3585 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 115:\n#line 1857 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        yr_parser_emit(yyscanner, OP_MOD, NULL);\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          compiler->last_result = ERROR_DIVISION_BY_ZERO;\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n#line 3607 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 116:\n#line 1875 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3621 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 117:\n#line 1885 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3635 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 118:\n#line 1895 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3649 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 119:\n#line 1905 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n#line 3663 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 120:\n#line 1915 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3677 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 121:\n#line 1925 \"grammar.y\" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n#line 3691 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n  case 122:\n#line 1935 \"grammar.y\" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n#line 3699 \"grammar.c\" /* yacc.c:1646  */\n     break;\n \n \n#line 3703 \"grammar.c\" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n #endif\n   return yyresult;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n",
        "post_patch": "static int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        components,\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n             continue;\n           p=(unsigned char *) (exif+offset);\n         }\n       switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(MagickTrue);\n}\n",
        "post_patch": "static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        components,\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n             continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n           p=(unsigned char *) (exif+offset);\n         }\n       switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(MagickTrue);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n\tR_FREE (bb);\n }\n",
        "post_patch": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n\tif (bb->next) {\n\t\t// avoid double free\n\t\tbb->next->prev = NULL;\n\t}\n\tR_FREE (bb); // double free\n }\n",
        "label": 1
    },
    {
        "pre_patch": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}\n",
        "post_patch": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                        bps, channels, samplerate);\n             }\n         }\n        av_get_packet(pb, pkt, asize);\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n",
        "post_patch": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n    int ret;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n    if (err < 0)\n        return err;\n    if (nsv->state == NSV_FOUND_NSVS)\n        err = nsv_parse_NSVs_header(s);\n    if (err < 0)\n        return err;\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n        return -1;\n\n    auxcount = avio_r8(pb);\n    vsize = avio_rl16(pb);\n    asize = avio_rl16(pb);\n    vsize = (vsize << 4) | (auxcount >> 4);\n    auxcount &= 0x0f;\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n           auxcount, vsize, asize);\n    /* skip aux stuff */\n    for (i = 0; i < auxcount; i++) {\n        uint32_t av_unused auxtag;\n        auxsize = avio_rl16(pb);\n        auxtag = avio_rl32(pb);\n        avio_skip(pb, auxsize);\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n    }\n\n    if (pb->eof_reached)\n        return -1;\n    if (!vsize && !asize) {\n        nsv->state = NSV_UNSYNC;\n        goto null_chunk_retry;\n    }\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n    if (asize && st[NSV_ST_AUDIO]) {\n        nst = st[NSV_ST_AUDIO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n        /* read raw audio specific header on the first audio chunk... */\n        /* on ALL audio chunks ?? seems so! */\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n            uint8_t bps;\n            uint8_t channels;\n            uint16_t samplerate;\n            bps = avio_r8(pb);\n            channels = avio_r8(pb);\n            samplerate = avio_rl16(pb);\n            if (!channels || !samplerate)\n                return AVERROR_INVALIDDATA;\n            asize-=4;\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                   bps, channels, samplerate);\n            if (fill_header) {\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n                if (bps != 16) {\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n                }\n                bps /= channels; // ???\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                        bps, channels, samplerate);\n             }\n         }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }\n        nst->frame_offset++;\n    }\n\n    nsv->state = NSV_UNSYNC;\n    return 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)\n{\n  return((chunk[7] & 32) != 0);\n}\n",
        "post_patch": "unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)\n{\n  return((chunk[7] & 32) != 0);\n}\n",
        "label": 0
    },
    {
        "pre_patch": " int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n {\n    uint32_t chan_chunk = 0, channel_layout = 0, bcount;\n     unsigned char *channel_identities = NULL;\n     unsigned char *channel_reorder = NULL;\n     int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n             }\n \n             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n \n             if (debug_logging_mode) {\n                 char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n            }\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||\n                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {\n                    error_line (\"this .CAF file has an invalid 'chan' chunk!\");\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);\n\n            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n         else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n             uint32_t mEditCount;\n \n            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                 bcount != sizeof (mEditCount)) {\n                     error_line (\"%s is not a valid .CAF file!\", infilename);\n                     return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
        "post_patch": " int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n {\n    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;\n     unsigned char *channel_identities = NULL;\n     unsigned char *channel_reorder = NULL;\n     int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n             }\n \n             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n            desc_chunk = 1;\n \n             if (debug_logging_mode) {\n                 char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n            }\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||\n                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {\n                    error_line (\"this .CAF file has an invalid 'chan' chunk!\");\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);\n\n            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n         else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n             uint32_t mEditCount;\n \n            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                 bcount != sizeof (mEditCount)) {\n                     error_line (\"%s is not a valid .CAF file!\", infilename);\n                     return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n\tif (np->opt)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n \n \ttcp_ca_openreq_child(newsk, dst);\n \n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "post_patch": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n \n \ttcp_ca_openreq_child(newsk, dst);\n \n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n     }\n   }\n }\n",
        "post_patch": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n  mrb_value nil;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n     }\n   }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n }\n",
        "label": 1
    },
    {
        "pre_patch": " init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n {\n   switch (mrb_type(obj)) {\n     case MRB_TT_CLASS:\n     case MRB_TT_MODULE:\n       copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}\n",
        "post_patch": " init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n {\n   switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n     case MRB_TT_CLASS:\n     case MRB_TT_MODULE:\n       copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "check_compressible_cell(struct table *t, MAT * minv,\n\t\t\tdouble *newwidth, double *swidth, short *cwidth,\n\t\t\tdouble totalwidth, double *Sxx,\n\t\t\tint icol, int icell, double sxx, int corr)\n{\n    struct table_cell *cell = &t->cell;\n    int i, j, k, m, bcol, ecol, span;\n    double delta, owidth;\n    double dmax, dmin, sxy;\n    int rulewidth = table_rule_width(t);\n\n    if (sxx < 10.)\n\treturn corr;\n\n    if (icol >= 0) {\n\towidth = newwidth[icol];\n\tdelta = newwidth[icol] - (double)t->tabwidth[icol];\n\tbcol = icol;\n\tecol = bcol + 1;\n    }\n    else if (icell >= 0) {\n\towidth = swidth[icell];\n\tdelta = swidth[icell] - (double)cwidth[icell];\n\tbcol = cell->col[icell];\n\tecol = bcol + cell->colspan[icell];\n    }\n    else {\n\towidth = totalwidth;\n\tdelta = totalwidth;\n\tbcol = 0;\n\tecol = t->maxcol + 1;\n    }\n\n    dmin = delta;\n    dmax = -1.;\n    for (k = 0; k <= cell->maxcell; k++) {\n\tint bcol1, ecol1;\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tj = cell->index[k];\n\tif (j == icell)\n\t    continue;\n\tbcol1 = cell->col[j];\n\tecol1 = bcol1 + cell->colspan[j];\n\tsxy = 0.;\n\tfor (m = bcol1; m < ecol1; m++) {\n\t    for (i = bcol; i < ecol; i++)\n\t\tsxy += m_entry(minv, i, m);\n\t}\n\tif (bcol1 >= bcol && ecol1 <= ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n    }\n    for (m = 0; m <= t->maxcol; m++) {\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tif (m == icol)\n\t    continue;\n\tsxy = 0.;\n\tfor (i = bcol; i < ecol; i++)\n\t    sxy += m_entry(minv, i, m);\n\tif (m >= bcol && m < ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n    }\n  _end:\n    if (dmax > 0. && dmin > dmax)\n\tdmin = dmax;\n    span = ecol - bcol;\n    if ((span == t->maxcol + 1 && dmin >= 0.) ||\n\t(span != t->maxcol + 1 && dmin > rulewidth * 0.5)) {\n\tint nwidth = ceil_at_intervals(round(owidth - dmin), rulewidth);\n\tcorrect_table_matrix(t, bcol, ecol - bcol, nwidth, 1.);\n\tcorr++;\n    }\n    return corr;\n}\n",
        "post_patch": "check_compressible_cell(struct table *t, MAT * minv,\n\t\t\tdouble *newwidth, double *swidth, short *cwidth,\n\t\t\tdouble totalwidth, double *Sxx,\n\t\t\tint icol, int icell, double sxx, int corr)\n{\n    struct table_cell *cell = &t->cell;\n    int i, j, k, m, bcol, ecol, span;\n    double delta, owidth;\n    double dmax, dmin, sxy;\n    int rulewidth = table_rule_width(t);\n\n    if (sxx < 10.)\n\treturn corr;\n\n    if (icol >= 0) {\n\towidth = newwidth[icol];\n\tdelta = newwidth[icol] - (double)t->tabwidth[icol];\n\tbcol = icol;\n\tecol = bcol + 1;\n    }\n    else if (icell >= 0) {\n\towidth = swidth[icell];\n\tdelta = swidth[icell] - (double)cwidth[icell];\n\tbcol = cell->col[icell];\n\tecol = bcol + cell->colspan[icell];\n    }\n    else {\n\towidth = totalwidth;\n\tdelta = totalwidth;\n\tbcol = 0;\n\tecol = t->maxcol + 1;\n    }\n\n    dmin = delta;\n    dmax = -1.;\n    for (k = 0; k <= cell->maxcell; k++) {\n\tint bcol1, ecol1;\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tj = cell->index[k];\n\tif (j == icell)\n\t    continue;\n\tbcol1 = cell->col[j];\n\tecol1 = bcol1 + cell->colspan[j];\n\tsxy = 0.;\n\tfor (m = bcol1; m < ecol1; m++) {\n\t    for (i = bcol; i < ecol; i++)\n\t\tsxy += m_entry(minv, i, m);\n\t}\n\tif (bcol1 >= bcol && ecol1 <= ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, swidth[j], cwidth[j],\n\t\t\t\tsxx, Sxx[j], sxy, is_inclusive);\n    }\n    for (m = 0; m <= t->maxcol; m++) {\n\tint is_inclusive = 0;\n\tif (dmin <= 0.)\n\t    goto _end;\n\tif (m == icol)\n\t    continue;\n\tsxy = 0.;\n\tfor (i = bcol; i < ecol; i++)\n\t    sxy += m_entry(minv, i, m);\n\tif (m >= bcol && m < ecol) {\n\t    is_inclusive = 1;\n\t}\n\tif (sxy > 0.)\n\t    dmin = recalc_width(dmin, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n\telse\n\t    dmax = recalc_width(dmax, newwidth[m], t->tabwidth[m],\n\t\t\t\tsxx, m_entry(minv, m, m), sxy, is_inclusive);\n    }\n  _end:\n    if (dmax > 0. && dmin > dmax)\n\tdmin = dmax;\n    span = ecol - bcol;\n    if ((span == t->maxcol + 1 && dmin >= 0.) ||\n\t(span != t->maxcol + 1 && dmin > rulewidth * 0.5)) {\n\tint nwidth = ceil_at_intervals(round(owidth - dmin), rulewidth);\n\tcorrect_table_matrix(t, bcol, ecol - bcol, nwidth, 1.);\n\tcorr++;\n    }\n    return corr;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int ip_queue_xmit(struct sk_buff *skb)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt;\n \tstruct iphdr *iph;\n \tint res;\n\n\t/* Skip all of this if the packet is already routed,\n \t * f.e. by something like SCTP.\n \t */\n \trcu_read_lock();\n \trt = skb_rtable(skb);\n \tif (rt != NULL)\n \t\tgoto packet_routed;\n\n\t/* Make sure we can route this packet. */\n\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\tif (rt == NULL) {\n\t\t__be32 daddr;\n \n \t\t/* Use correct destination address if we have options. */\n \t\tdaddr = inet->inet_daddr;\n\t\tif(opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport,\n\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol,\n\t\t\t\t\t   RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n \tskb_dst_set_noref(skb, &rt->dst);\n \n packet_routed:\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto no_route;\n \n \t/* OK, we know where to send it, allocate and build IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \t*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (inet->tos & 0xff));\n\tif (ip_dont_fragment(sk, &rt->dst) && !skb->local_df)\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->protocol = sk->sk_protocol;\n\tiph->saddr    = rt->rt_src;\n \tiph->daddr    = rt->rt_dst;\n \t/* Transport layer set skb->h.foo itself. */\n \n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen >> 2;\n\t\tip_options_build(skb, opt, inet->inet_daddr, rt, 0);\n \t}\n \n \tip_select_ident_more(iph, &rt->dst, sk,\n\t\t\t     (skb_shinfo(skb)->gso_segs ?: 1) - 1);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tres = ip_local_out(skb);\n\trcu_read_unlock();\n\treturn res;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n",
        "post_patch": "int ip_queue_xmit(struct sk_buff *skb)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *inet_opt;\n \tstruct rtable *rt;\n \tstruct iphdr *iph;\n \tint res;\n\n\t/* Skip all of this if the packet is already routed,\n \t * f.e. by something like SCTP.\n \t */\n \trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n \trt = skb_rtable(skb);\n \tif (rt != NULL)\n \t\tgoto packet_routed;\n\n\t/* Make sure we can route this packet. */\n\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\tif (rt == NULL) {\n\t\t__be32 daddr;\n \n \t\t/* Use correct destination address if we have options. */\n \t\tdaddr = inet->inet_daddr;\n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport,\n\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol,\n\t\t\t\t\t   RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n \tskb_dst_set_noref(skb, &rt->dst);\n \n packet_routed:\n\tif (inet_opt && inet_opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto no_route;\n \n \t/* OK, we know where to send it, allocate and build IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \t*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (inet->tos & 0xff));\n\tif (ip_dont_fragment(sk, &rt->dst) && !skb->local_df)\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->protocol = sk->sk_protocol;\n\tiph->saddr    = rt->rt_src;\n \tiph->daddr    = rt->rt_dst;\n \t/* Transport layer set skb->h.foo itself. */\n \n\tif (inet_opt && inet_opt->opt.optlen) {\n\t\tiph->ihl += inet_opt->opt.optlen >> 2;\n\t\tip_options_build(skb, &inet_opt->opt, inet->inet_daddr, rt, 0);\n \t}\n \n \tip_select_ident_more(iph, &rt->dst, sk,\n\t\t\t     (skb_shinfo(skb)->gso_segs ?: 1) - 1);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tres = ip_local_out(skb);\n\trcu_read_unlock();\n\treturn res;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n   Process();\n \n   if (link_)\n    link_->OwnerInserted();\n\n  return kInsertionDone;\n}\n",
        "post_patch": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n\n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n   Process();\n \n   if (link_)\n    link_->OwnerInserted();\n\n  return kInsertionDone;\n}\n",
        "label": 1
    },
    {
        "pre_patch": " static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n {\n \tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n \tstruct nat_entry *ne;\n\tint err;\n \n \t/* 0 nid should not be used */\n \tif (unlikely(nid == 0))\n \t\treturn false;\n \n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n \ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n \ti->nid = nid;\n \ti->state = NID_NEW;\n \n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n \n \tspin_lock(&nm_i->nid_list_lock);\n \terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n \tspin_unlock(&nm_i->nid_list_lock);\n \tradix_tree_preload_end();\n\tif (err) {\n \t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n }\n",
        "post_patch": " static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n {\n \tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *e;\n \tstruct nat_entry *ne;\n\tint err = -EINVAL;\n\tbool ret = false;\n \n \t/* 0 nid should not be used */\n \tif (unlikely(nid == 0))\n \t\treturn false;\n \n \ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n \ti->nid = nid;\n \ti->state = NID_NEW;\n \n\tif (radix_tree_preload(GFP_NOFS))\n\t\tgoto err;\n \n \tspin_lock(&nm_i->nid_list_lock);\n\n\tif (build) {\n\t\t/*\n\t\t *   Thread A             Thread B\n\t\t *  - f2fs_create\n\t\t *   - f2fs_new_inode\n\t\t *    - alloc_nid\n\t\t *     - __insert_nid_to_list(ALLOC_NID_LIST)\n\t\t *                     - f2fs_balance_fs_bg\n\t\t *                      - build_free_nids\n\t\t *                       - __build_free_nids\n\t\t *                        - scan_nat_page\n\t\t *                         - add_free_nid\n\t\t *                          - __lookup_nat_cache\n\t\t *  - f2fs_add_link\n\t\t *   - init_inode_metadata\n\t\t *    - new_inode_page\n\t\t *     - new_node_page\n\t\t *      - set_node_addr\n\t\t *  - alloc_nid_done\n\t\t *   - __remove_nid_from_list(ALLOC_NID_LIST)\n\t\t *                         - __insert_nid_to_list(FREE_NID_LIST)\n\t\t */\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tgoto err_out;\n\n\t\te = __lookup_free_nid_list(nm_i, nid);\n\t\tif (e) {\n\t\t\tif (e->state == NID_NEW)\n\t\t\t\tret = true;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tret = true;\n \terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\nerr_out:\n \tspin_unlock(&nm_i->nid_list_lock);\n \tradix_tree_preload_end();\nerr:\n\tif (err)\n \t\tkmem_cache_free(free_nid_slab, i);\n\treturn ret;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "void WebGLRenderingContextBase::bindBuffer(GLenum target, WebGLBuffer* buffer) {\n  if (!ValidateNullableWebGLObject(\"bindBuffer\", buffer))\n    return;\n  if (!ValidateAndUpdateBufferBindTarget(\"bindBuffer\", target, buffer))\n    return;\n  ContextGL()->BindBuffer(target, ObjectOrZero(buffer));\n}\n",
        "post_patch": "void WebGLRenderingContextBase::bindBuffer(GLenum target, WebGLBuffer* buffer) {\n  if (!ValidateNullableWebGLObject(\"bindBuffer\", buffer))\n    return;\n  if (!ValidateAndUpdateBufferBindTarget(\"bindBuffer\", target, buffer))\n    return;\n  ContextGL()->BindBuffer(target, ObjectOrZero(buffer));\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n \t\tgoto exit;\n \t}\n \n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \t/* Only copy data to userland if data was received. */\n \tif (ret < 0)\n \t\tgoto exit;\n \n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);\n\treturn ret;\n}\n",
        "post_patch": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n \t\tgoto exit;\n \t}\n \n\tif (u_cmd.outsize != s_cmd->outsize ||\n\t    u_cmd.insize != s_cmd->insize) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \t/* Only copy data to userland if data was received. */\n \tif (ret < 0)\n \t\tgoto exit;\n \n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);\n\treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void ceph_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey = prep->payload[0];\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n",
        "post_patch": "static void ceph_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey = prep->payload[0];\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n",
        "post_patch": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "  StatsResponse(const scoped_refptr<LocalRTCStatsRequest>& request,\n                scoped_refptr<base::SingleThreadTaskRunner> task_runner)\n      : request_(request.get()), main_thread_(task_runner) {\n    TRACE_EVENT_ASYNC_BEGIN0(\"webrtc\", \"getStats_Native\", this);\n    DETACH_FROM_THREAD(signaling_thread_checker_);\n  }\n",
        "post_patch": "  StatsResponse(const scoped_refptr<LocalRTCStatsRequest>& request,\n                scoped_refptr<base::SingleThreadTaskRunner> task_runner)\n      : request_(request.get()), main_thread_(task_runner) {\n    TRACE_EVENT_ASYNC_BEGIN0(\"webrtc\", \"getStats_Native\", this);\n    DETACH_FROM_THREAD(signaling_thread_checker_);\n  }\n",
        "label": 0
    },
    {
        "pre_patch": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n \t\trefs++;\n \t} while (addr += PAGE_SIZE, addr != end);\n \n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n \t\t*nr -= refs;\n \t\treturn 0;\n \t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}\n",
        "post_patch": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n \t\trefs++;\n \t} while (addr += PAGE_SIZE, addr != end);\n \n\thead = try_get_compound_head(pgd_page(orig), refs);\n\tif (!head) {\n \t\t*nr -= refs;\n \t\treturn 0;\n \t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}\n",
        "label": 1
    },
    {
        "pre_patch": " int main(int argc, char *argv[]) {\n\tp_fm_config_conx_hdlt\thdl;\n \tint\t\t\t\t\t\tinstance = 0;\n \tfm_mgr_config_errno_t\tres;\n \tchar\t\t\t\t\t*rem_addr = NULL;\n\tchar\t\t\t\t\t*community = \"public\";\n\tchar            \t\tOpts[256];\n    int             \t\targ;\n\tchar \t\t\t\t\t*command;\n\tint\t\t\t\t\t\ti;\n\n\t/* Get options at the command line (overide default values) */\n    strcpy(Opts, \"i:d:h-\");\n\n    while ((arg = getopt(argc, argv, Opts)) != EOF) {\n        switch (arg) {\n\t\tcase 'h':\n\t\tcase '-':\n\t\t\tusage(argv[0]);\n\t\t\treturn(0);\n\t\tcase 'i':\n\t\t\tinstance = atol(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\trem_addr = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n\tif(optind >= argc){\n        fprintf(stderr, \"Command required\\n\");\n\t\tusage(argv[0]);\n\t\treturn -1;\n\t}\n\n\tcommand = argv[optind++];\n\tprintf(\"Connecting to %s FM instance %d\\n\", (rem_addr==NULL) ? \"LOCAL\":rem_addr, instance);\n \tif((res = fm_mgr_config_init(&hdl,instance, rem_addr, community)) != FM_CONF_OK)\n \t{\n \t\tfprintf(stderr, \"Failed to initialize the client handle: %d\\n\", res);\n\t\tgoto die_clean;\n \t}\n \n \tif((res = fm_mgr_config_connect(hdl)) != FM_CONF_OK)\n \t{\n \t\tfprintf(stderr, \"Failed to connect: (%d) %s\\n\",res,fm_mgr_get_error_str(res));\n\t\tgoto die_clean;\n \t}\n \n \tfor(i=0;i<commandListLen;i++){\n \t\tif(strcmp(command,commandList[i].name) == 0){\n\t\t\treturn commandList[i].cmdPtr(hdl, commandList[i].mgr, (argc - optind), &argv[optind]);\n \t\t}\n \t}\n \n \tfprintf(stderr, \"Command (%s) is not valid\\n\",command);\n \tusage(argv[0]);\n \tres = -1;\n \ndie_clean:\n\tif (hdl) free(hdl);\n \treturn res;\n }\n",
        "post_patch": " int main(int argc, char *argv[]) {\n\tp_fm_config_conx_hdlt\thdl = NULL;\n \tint\t\t\t\t\t\tinstance = 0;\n \tfm_mgr_config_errno_t\tres;\n \tchar\t\t\t\t\t*rem_addr = NULL;\n\tchar\t\t\t\t\t*community = \"public\";\n\tchar            \t\tOpts[256];\n    int             \t\targ;\n\tchar \t\t\t\t\t*command;\n\tint\t\t\t\t\t\ti;\n\n\t/* Get options at the command line (overide default values) */\n    strcpy(Opts, \"i:d:h-\");\n\n    while ((arg = getopt(argc, argv, Opts)) != EOF) {\n        switch (arg) {\n\t\tcase 'h':\n\t\tcase '-':\n\t\t\tusage(argv[0]);\n\t\t\treturn(0);\n\t\tcase 'i':\n\t\t\tinstance = atol(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\trem_addr = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n\tif(optind >= argc){\n        fprintf(stderr, \"Command required\\n\");\n\t\tusage(argv[0]);\n\t\treturn -1;\n\t}\n\n\tcommand = argv[optind++];\n\tprintf(\"Connecting to %s FM instance %d\\n\", (rem_addr==NULL) ? \"LOCAL\":rem_addr, instance);\n \tif((res = fm_mgr_config_init(&hdl,instance, rem_addr, community)) != FM_CONF_OK)\n \t{\n \t\tfprintf(stderr, \"Failed to initialize the client handle: %d\\n\", res);\n\t\tgoto cleanup;\n \t}\n \n \tif((res = fm_mgr_config_connect(hdl)) != FM_CONF_OK)\n \t{\n \t\tfprintf(stderr, \"Failed to connect: (%d) %s\\n\",res,fm_mgr_get_error_str(res));\n\t\tgoto cleanup;\n \t}\n \n \tfor(i=0;i<commandListLen;i++){\n \t\tif(strcmp(command,commandList[i].name) == 0){\n\t\t\tres = commandList[i].cmdPtr(hdl, commandList[i].mgr, (argc - optind), &argv[optind]);\n\t\t\tgoto cleanup;\n \t\t}\n \t}\n \n \tfprintf(stderr, \"Command (%s) is not valid\\n\",command);\n \tusage(argv[0]);\n \tres = -1;\n \ncleanup:\n\tif (hdl)\n\t{\n\t\tif (hdl->sm_hdl)\n\t\t{\n\t\t\tif (hdl->sm_hdl->c_path[0])\n\t\t\t\tunlink(hdl->sm_hdl->c_path);\n\t\t}\n\t\tif (hdl->pm_hdl)\n\t\t{\n\t\t\tif (hdl->pm_hdl->c_path[0])\n\t\t\t\tunlink(hdl->pm_hdl->c_path);\n\t\t}\n\t\tif (hdl->fe_hdl)\n\t\t{\n\t\t\tif (hdl->fe_hdl->c_path[0])\n\t\t\t\tunlink(hdl->fe_hdl->c_path);\n\t\t}\n\t\tfree(hdl);\n\t}\n\n \treturn res;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "void DocumentLoader::DetachFromFrame() {\n  DCHECK(frame_);\n   fetcher_->StopFetching();\n   if (frame_ && !SentDidFinishLoad())\n     LoadFailed(ResourceError::CancelledError(Url()));\n   fetcher_->ClearContext();\n \n  if (!frame_)\n    return;\n\n  application_cache_host_->DetachFromDocumentLoader();\n  application_cache_host_.Clear();\n  service_worker_network_provider_ = nullptr;\n  WeakIdentifierMap<DocumentLoader>::NotifyObjectDestroyed(this);\n  ClearResource();\n  frame_ = nullptr;\n}\n",
        "post_patch": "void DocumentLoader::DetachFromFrame() {\nvoid DocumentLoader::StopLoading() {\n   fetcher_->StopFetching();\n   if (frame_ && !SentDidFinishLoad())\n     LoadFailed(ResourceError::CancelledError(Url()));\n}\n\nvoid DocumentLoader::DetachFromFrame() {\n  DCHECK(frame_);\n  StopLoading();\n   fetcher_->ClearContext();\n \n  if (!frame_)\n    return;\n\n  application_cache_host_->DetachFromDocumentLoader();\n  application_cache_host_.Clear();\n  service_worker_network_provider_ = nullptr;\n  WeakIdentifierMap<DocumentLoader>::NotifyObjectDestroyed(this);\n  ClearResource();\n  frame_ = nullptr;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n \n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n\tif (_payload) {\n \t\tret = -ENOMEM;\n \t\tpayload = kmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}\n",
        "post_patch": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n \n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static Image *ReadOnePNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  /* Read one PNG image */\n\n  /* To do: Read the tEXt/Creation Time chunk into the date:create property */\n\n  Image\n    *image;\n\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  int\n    intent, /* \"PNG Rendering intent\", which is ICC intent + 1 */\n    num_raw_profiles,\n    num_text,\n    num_text_total,\n    num_passes,\n    number_colors,\n    pass,\n    ping_bit_depth,\n    ping_color_type,\n    ping_file_depth,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans,\n    unit_type;\n\n  double\n    file_gamma;\n\n  MagickBooleanType\n    logging,\n    ping_found_cHRM,\n    ping_found_gAMA,\n    ping_found_iCCP,\n    ping_found_sRGB,\n    ping_found_sRGB_cHRM,\n    ping_preserve_iCCP,\n    status;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  PixelInfo\n    transparent_color;\n\n  PNGErrorInfo\n    error_info;\n\n  png_bytep\n     ping_trans_alpha;\n\n  png_color_16p\n     ping_background,\n     ping_trans_color;\n\n  png_info\n    *end_info,\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_textp\n    text;\n\n  png_uint_32\n    ping_height,\n    ping_width,\n    x_resolution,\n    y_resolution;\n\n  QuantumInfo\n    *quantum_info;\n\n  ssize_t\n    ping_rowbytes,\n    y;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length,\n    row_offset;\n\n  ssize_t\n    j;\n\n  unsigned char\n    *ping_pixels;\n\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n  png_byte unused_chunks[]=\n  {\n    104,  73,  83,  84, (png_byte) '\\0',   /* hIST */\n    105,  84,  88, 116, (png_byte) '\\0',   /* iTXt */\n    112,  67,  65,  76, (png_byte) '\\0',   /* pCAL */\n    115,  67,  65,  76, (png_byte) '\\0',   /* sCAL */\n    115,  80,  76,  84, (png_byte) '\\0',   /* sPLT */\n#if !defined(PNG_tIME_SUPPORTED)\n    116,  73,  77,  69, (png_byte) '\\0',   /* tIME */\n#endif\n#ifdef PNG_APNG_SUPPORTED /* libpng was built with APNG patch; */\n                          /* ignore the APNG chunks */\n     97,  99,  84,  76, (png_byte) '\\0',   /* acTL */\n    102,  99,  84,  76, (png_byte) '\\0',   /* fcTL */\n    102, 100,  65,  84, (png_byte) '\\0',   /* fdAT */\n#endif\n  };\n#endif\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,32);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,32);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  Enter ReadOnePNGImage()\\n\"\n       \"    IM version     = %s\\n\"\n       \"    Libpng version = %s\",\n       im_vers, libpng_vers);\n\n  if (logging != MagickFalse)\n  {\n    if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n    {\n   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        libpng_runv);\n    }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n        zlib_vers);\n    if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n    {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        zlib_runv);\n    }\n  }\n\n#if (PNG_LIBPNG_VER < 10200)\n  if (image_info->verbose)\n    printf(\"Your PNG library (libpng-%s) is rather old.\\n\",\n       PNG_LIBPNG_VER_STRING);\n#endif\n\n#if (PNG_LIBPNG_VER >= 10400)\n#  ifndef  PNG_TRANSFORM_GRAY_TO_RGB    /* Added at libpng-1.4.0beta67 */\n  if (image_info->verbose)\n    {\n      printf(\"Your PNG library (libpng-%s) is an old beta version.\\n\",\n           PNG_LIBPNG_VER_STRING);\n      printf(\"Please update it.\\n\");\n    }\n#  endif\n#endif\n\n\n  quantum_info = (QuantumInfo *) NULL;\n  image=mng_info->image;\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"    Before reading:\\n\"\n       \"      image->alpha_trait=%d\"\n       \"      image->rendering_intent=%d\\n\"\n       \"      image->colorspace=%d\\n\"\n       \"      image->gamma=%f\",\n       (int) image->alpha_trait, (int) image->rendering_intent,\n       (int) image->colorspace, image->gamma);\n  }\n  intent=\n    Magick_RenderingIntent_to_PNG_RenderingIntent(image->rendering_intent);\n\n  /* Set to an out-of-range color unless tRNS chunk is present */\n  transparent_color.red=65537;\n  transparent_color.green=65537;\n  transparent_color.blue=65537;\n  transparent_color.alpha=65537;\n\n  number_colors=0;\n  num_text = 0;\n  num_text_total = 0;\n  num_raw_profiles = 0;\n\n  ping_found_cHRM = MagickFalse;\n  ping_found_gAMA = MagickFalse;\n  ping_found_iCCP = MagickFalse;\n  ping_found_sRGB = MagickFalse;\n  ping_found_sRGB_cHRM = MagickFalse;\n  ping_preserve_iCCP = MagickFalse;\n\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n ping=png_create_read_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n   MagickPNGErrorHandler,MagickPNGWarningHandler, NULL,\n   (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n#else\n  ping=png_create_read_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,(png_info **) NULL,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  end_info=png_create_info_struct(ping);\n\n  if (end_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,&ping_info,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n       /*\n         PNG image is corrupt.\n       */\n       png_destroy_read_struct(&ping,&ping_info,&end_info);\n \n #ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() with error.\");\n\n      return(GetFirstImageInList(image));\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for reading.\n  */\n\n  mng_info->image_found++;\n  png_set_sig_bytes(ping,8);\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n      (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED)\n      png_permit_empty_plte(ping,MagickTrue);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n      mng_info->image=image;\n      mng_info->bytes_in_read_buffer=0;\n      mng_info->found_empty_plte=MagickFalse;\n      mng_info->have_saved_bkgd_index=MagickFalse;\n      png_set_read_fn(ping,mng_info,mng_get_data);\n#endif\n#endif\n    }\n\n  else\n    png_set_read_fn(ping,image,png_get_data);\n\n  {\n    const char\n      *value;\n\n    value=GetImageOption(image_info,\"profile:skip\");\n\n    if (IsOptionMember(\"ICC\",value) == MagickFalse)\n    {\n\n       value=GetImageOption(image_info,\"png:preserve-iCCP\");\n\n       if (value == NULL)\n          value=GetImageArtifact(image,\"png:preserve-iCCP\");\n\n       if (value != NULL)\n          ping_preserve_iCCP=MagickTrue;\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n       /* Don't let libpng check for ICC/sRGB profile because we're going\n        * to do that anyway.  This feature was added at libpng-1.6.12.\n        * If logging, go ahead and check and issue a warning as appropriate.\n        */\n       if (logging == MagickFalse)\n          png_set_option(ping, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n    }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    else\n    {\n       png_set_keep_unknown_chunks(ping, 1, (png_bytep) mng_iCCP, 1);\n    }\n#endif\n  }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n  /* Ignore unused chunks and all unknown chunks except for eXIf,\n     caNv, and vpAg */\n# if PNG_LIBPNG_VER < 10700 /* Avoid libpng16 warning */\n  png_set_keep_unknown_chunks(ping, 2, NULL, 0);\n# else\n  png_set_keep_unknown_chunks(ping, 1, NULL, 0);\n# endif\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_eXIf, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_caNv, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_vpAg, 1);\n  png_set_keep_unknown_chunks(ping, 1, unused_chunks,\n     (int)sizeof(unused_chunks)/5);\n  /* Callback for other unknown chunks */\n  png_set_read_user_chunk_fn(ping, image, read_user_chunk_callback);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n#  if (PNG_LIBPNG_VER >= 10400)\n    /* Limit the size of the chunk storage cache used for sPLT, text,\n     * and unknown chunks.\n     */\n    png_set_chunk_cache_max(ping, 32767);\n#  endif\n#endif\n\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\n    /* Disable new libpng-1.5.10 feature */\n    png_set_check_for_invalid_index (ping, 0);\n#endif\n\n#if (PNG_LIBPNG_VER < 10400)\n#  if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && \\\n   (PNG_LIBPNG_VER >= 10200) && (PNG_LIBPNG_VER < 10220) && defined(__i386__)\n  /* Disable thread-unsafe features of pnggccrd */\n  if (png_access_version_number() >= 10200)\n  {\n    png_uint_32 mmx_disable_mask=0;\n    png_uint_32 asm_flags;\n\n    mmx_disable_mask |= ( PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_SUB   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_AVG   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH );\n    asm_flags=png_get_asm_flags(ping);\n    png_set_asm_flags(ping, asm_flags & ~mmx_disable_mask);\n  }\n#  endif\n#endif\n\n  png_read_info(ping,ping_info);\n\n  png_get_IHDR(ping,ping_info,&ping_width,&ping_height,\n               &ping_bit_depth,&ping_color_type,\n               &ping_interlace_method,&ping_compression_method,\n               &ping_filter_method);\n\n  ping_file_depth = ping_bit_depth;\n\n  /* Swap bytes if requested */\n  if (ping_file_depth == 16)\n  {\n     const char\n       *value;\n\n     value=GetImageOption(image_info,\"png:swap-bytes\");\n\n     if (value == NULL)\n        value=GetImageArtifact(image,\"png:swap-bytes\");\n\n     if (value != NULL)\n        png_set_swap(ping);\n  }\n\n  /* Save bit-depth and color-type in case we later want to write a PNG00 */\n  {\n      char\n        msg[MagickPathExtent];\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_color_type);\n      (void) SetImageProperty(image,\"png:IHDR.color-type-orig\",msg,exception);\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_bit_depth);\n      (void) SetImageProperty(image,\"png:IHDR.bit-depth-orig\",msg,exception);\n  }\n\n  (void) png_get_tRNS(ping, ping_info, &ping_trans_alpha, &ping_num_trans,\n                      &ping_trans_color);\n\n  (void) png_get_bKGD(ping, ping_info, &ping_background);\n\n  if (ping_bit_depth < 8)\n    {\n       png_set_packing(ping);\n       ping_bit_depth = 8;\n    }\n\n  image->depth=ping_bit_depth;\n  image->depth=GetImageQuantumDepth(image,MagickFalse);\n  image->interlace=ping_interlace_method != 0 ? PNGInterlace : NoInterlace;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      image->rendering_intent=UndefinedIntent;\n      intent=Magick_RenderingIntent_to_PNG_RenderingIntent(UndefinedIntent);\n      (void) ResetMagickMemory(&image->chromaticity,0,\n        sizeof(image->chromaticity));\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG width: %.20g, height: %.20g\\n\"\n        \"    PNG color_type: %d, bit_depth: %d\\n\"\n        \"    PNG compression_method: %d\\n\"\n        \"    PNG interlace_method: %d, filter_method: %d\",\n        (double) ping_width, (double) ping_height,\n        ping_color_type, ping_bit_depth,\n        ping_compression_method,\n        ping_interlace_method,ping_filter_method);\n\n    }\n\n  if (png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_gAMA))\n    {\n      ping_found_gAMA=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG gAMA chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      ping_found_cHRM=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG cHRM chunk.\");\n    }\n\n  if (ping_found_iCCP != MagickTrue && png_get_valid(ping,ping_info,\n      PNG_INFO_sRGB))\n    {\n      ping_found_sRGB=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG sRGB chunk.\");\n    }\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n    if (ping_found_iCCP !=MagickTrue &&\n      ping_found_sRGB != MagickTrue &&\n      png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_iCCP))\n    {\n      int\n        compression;\n\n#if (PNG_LIBPNG_VER < 10500)\n      png_charp\n        info;\n#else\n      png_bytep\n        info;\n#endif\n\n      png_charp\n        name;\n\n      png_uint_32\n        profile_length;\n\n      (void) png_get_iCCP(ping,ping_info,&name,(int *) &compression,&info,\n        &profile_length);\n\n      if (profile_length != 0)\n        {\n          StringInfo\n            *profile;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG iCCP chunk.\");\n\n          profile=BlobToStringInfo(info,profile_length);\n\n          if (profile == (StringInfo *) NULL)\n          {\n            png_warning(ping, \"ICC profile is NULL\");\n            profile=DestroyStringInfo(profile);\n          }\n          else\n          {\n            if (ping_preserve_iCCP == MagickFalse)\n            {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                 {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n                 }\n            }\n            else /* Preserve-iCCP */\n            {\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n            }\n\n            profile=DestroyStringInfo(profile);\n          }\n      }\n    }\n#endif\n\n#if defined(PNG_READ_sRGB_SUPPORTED)\n  {\n    if (ping_found_iCCP==MagickFalse && png_get_valid(ping,ping_info,\n        PNG_INFO_sRGB))\n    {\n      if (png_get_sRGB(ping,ping_info,&intent))\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n             Magick_RenderingIntent_from_PNG_RenderingIntent (intent);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG sRGB chunk: rendering_intent: %d\",intent);\n      }\n    }\n\n    else if (mng_info->have_global_srgb)\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n            Magick_RenderingIntent_from_PNG_RenderingIntent\n            (mng_info->global_srgb_intent);\n      }\n  }\n#endif\n\n\n  {\n     if (!png_get_gAMA(ping,ping_info,&file_gamma))\n       if (mng_info->have_global_gama)\n         png_set_gAMA(ping,ping_info,mng_info->global_gamma);\n\n     if (png_get_gAMA(ping,ping_info,&file_gamma))\n       {\n         image->gamma=(float) file_gamma;\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading PNG gAMA chunk: gamma: %f\",file_gamma);\n       }\n  }\n\n  if (!png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      if (mng_info->have_global_chrm != MagickFalse)\n        {\n          (void) png_set_cHRM(ping,ping_info,\n            mng_info->global_chrm.white_point.x,\n            mng_info->global_chrm.white_point.y,\n            mng_info->global_chrm.red_primary.x,\n            mng_info->global_chrm.red_primary.y,\n            mng_info->global_chrm.green_primary.x,\n            mng_info->global_chrm.green_primary.y,\n            mng_info->global_chrm.blue_primary.x,\n            mng_info->global_chrm.blue_primary.y);\n        }\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      (void) png_get_cHRM(ping,ping_info,\n        &image->chromaticity.white_point.x,\n        &image->chromaticity.white_point.y,\n        &image->chromaticity.red_primary.x,\n        &image->chromaticity.red_primary.y,\n        &image->chromaticity.green_primary.x,\n        &image->chromaticity.green_primary.y,\n        &image->chromaticity.blue_primary.x,\n        &image->chromaticity.blue_primary.y);\n\n       ping_found_cHRM=MagickTrue;\n\n       if (image->chromaticity.red_primary.x>0.6399f &&\n           image->chromaticity.red_primary.x<0.6401f &&\n           image->chromaticity.red_primary.y>0.3299f &&\n           image->chromaticity.red_primary.y<0.3301f &&\n           image->chromaticity.green_primary.x>0.2999f &&\n           image->chromaticity.green_primary.x<0.3001f &&\n           image->chromaticity.green_primary.y>0.5999f &&\n           image->chromaticity.green_primary.y<0.6001f &&\n           image->chromaticity.blue_primary.x>0.1499f &&\n           image->chromaticity.blue_primary.x<0.1501f &&\n           image->chromaticity.blue_primary.y>0.0599f &&\n           image->chromaticity.blue_primary.y<0.0601f &&\n           image->chromaticity.white_point.x>0.3126f &&\n           image->chromaticity.white_point.x<0.3128f &&\n           image->chromaticity.white_point.y>0.3289f &&\n           image->chromaticity.white_point.y<0.3291f)\n          ping_found_sRGB_cHRM=MagickTrue;\n    }\n\n  if (image->rendering_intent != UndefinedIntent)\n    {\n      if (ping_found_sRGB != MagickTrue &&\n          (ping_found_gAMA != MagickTrue ||\n          (image->gamma > .45 && image->gamma < .46)) &&\n          (ping_found_cHRM != MagickTrue ||\n          ping_found_sRGB_cHRM != MagickFalse) &&\n          ping_found_iCCP != MagickTrue)\n      {\n         png_set_sRGB(ping,ping_info,\n            Magick_RenderingIntent_to_PNG_RenderingIntent\n            (image->rendering_intent));\n         file_gamma=1.000f/2.200f;\n         ping_found_sRGB=MagickTrue;\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"    Setting sRGB as if in input\");\n      }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n    {\n      image->page.x=(ssize_t) png_get_x_offset_pixels(ping, ping_info);\n      image->page.y=(ssize_t) png_get_y_offset_pixels(ping, ping_info);\n\n      if (logging != MagickFalse)\n        if (image->page.x || image->page.y)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG oFFs chunk: x: %.20g, y: %.20g.\",(double)\n            image->page.x,(double) image->page.y);\n    }\n#endif\n#if defined(PNG_pHYs_SUPPORTED)\n  if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      if (mng_info->have_global_phys)\n        {\n          png_set_pHYs(ping,ping_info,\n                       mng_info->global_x_pixels_per_unit,\n                       mng_info->global_y_pixels_per_unit,\n                       mng_info->global_phys_unit_type);\n        }\n    }\n\n  x_resolution=0;\n  y_resolution=0;\n  unit_type=0;\n  if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      /*\n        Set image resolution.\n      */\n      (void) png_get_pHYs(ping,ping_info,&x_resolution,&y_resolution,\n        &unit_type);\n      image->resolution.x=(double) x_resolution;\n      image->resolution.y=(double) y_resolution;\n\n      if (unit_type == PNG_RESOLUTION_METER)\n        {\n          image->units=PixelsPerCentimeterResolution;\n          image->resolution.x=(double) x_resolution/100.0;\n          image->resolution.y=(double) y_resolution/100.0;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) x_resolution,(double) y_resolution,unit_type);\n    }\n#endif\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n    {\n      png_colorp\n        palette;\n\n      (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n      if ((number_colors == 0) &&\n          ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE))\n        {\n          if (mng_info->global_plte_length)\n            {\n              png_set_PLTE(ping,ping_info,mng_info->global_plte,\n                (int) mng_info->global_plte_length);\n\n              if (!png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n              {\n                if (mng_info->global_trns_length)\n                  {\n                    png_warning(ping,\n                      \"global tRNS has more entries than global PLTE\");\n                  }\n                else\n                  {\n                     png_set_tRNS(ping,ping_info,mng_info->global_trns,\n                       (int) mng_info->global_trns_length,NULL);\n                  }\n               }\n#ifdef PNG_READ_bKGD_SUPPORTED\n              if (\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                   mng_info->have_saved_bkgd_index ||\n#endif\n                   png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n                    {\n                      png_color_16\n                         background;\n\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                      if (mng_info->have_saved_bkgd_index)\n                        background.index=mng_info->saved_bkgd_index;\n#endif\n                      if (png_get_valid(ping, ping_info, PNG_INFO_bKGD))\n                        background.index=ping_background->index;\n\n                      background.red=(png_uint_16)\n                        mng_info->global_plte[background.index].red;\n\n                      background.green=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      background.blue=(png_uint_16)\n                        mng_info->global_plte[background.index].blue;\n\n                      background.gray=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      png_set_bKGD(ping,ping_info,&background);\n                    }\n#endif\n                }\n              else\n                png_error(ping,\"No global PLTE in file\");\n            }\n        }\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n  if (mng_info->have_global_bkgd &&\n          (!png_get_valid(ping,ping_info,PNG_INFO_bKGD)))\n      image->background_color=mng_info->mng_global_bkgd;\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n    {\n      unsigned int\n        bkgd_scale;\n\n      /* Set image background color.\n       * Scale background components to 16-bit, then scale\n       * to quantum depth\n       */\n\n        bkgd_scale = 1;\n\n        if (ping_file_depth == 1)\n           bkgd_scale = 255;\n\n        else if (ping_file_depth == 2)\n           bkgd_scale = 85;\n\n        else if (ping_file_depth == 4)\n           bkgd_scale = 17;\n\n        if (ping_file_depth <= 8)\n           bkgd_scale *= 257;\n\n        ping_background->red *= bkgd_scale;\n        ping_background->green *= bkgd_scale;\n        ping_background->blue *= bkgd_scale;\n\n        if (logging != MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Reading PNG bKGD chunk, raw ping_background=(%d,%d,%d)\\n\"\n                 \"    bkgd_scale=%d.  ping_background=(%d,%d,%d)\",\n                 ping_background->red,ping_background->green,\n                 ping_background->blue,\n                 bkgd_scale,ping_background->red,\n                 ping_background->green,ping_background->blue);\n          }\n\n        image->background_color.red=\n            ScaleShortToQuantum(ping_background->red);\n\n        image->background_color.green=\n            ScaleShortToQuantum(ping_background->green);\n\n        image->background_color.blue=\n          ScaleShortToQuantum(ping_background->blue);\n\n        image->background_color.alpha=OpaqueAlpha;\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    image->background_color=(%.20g,%.20g,%.20g).\",\n            (double) image->background_color.red,\n            (double) image->background_color.green,\n            (double) image->background_color.blue);\n    }\n#endif /* PNG_READ_bKGD_SUPPORTED */\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      /*\n        Image has a tRNS chunk.\n      */\n      int\n        max_sample;\n\n      size_t\n        one=1;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG tRNS chunk.\");\n\n      max_sample = (int) ((one << ping_file_depth) - 1);\n\n      if ((ping_color_type == PNG_COLOR_TYPE_GRAY &&\n          (int)ping_trans_color->gray > max_sample) ||\n          (ping_color_type == PNG_COLOR_TYPE_RGB &&\n          ((int)ping_trans_color->red > max_sample ||\n          (int)ping_trans_color->green > max_sample ||\n          (int)ping_trans_color->blue > max_sample)))\n        {\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Ignoring PNG tRNS chunk with out-of-range sample.\");\n          png_free_data(ping, ping_info, PNG_FREE_TRNS, 0);\n          png_set_invalid(ping,ping_info,PNG_INFO_tRNS);\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n      else\n        {\n          int\n            scale_to_short;\n\n          scale_to_short = 65535L/((1UL << ping_file_depth)-1);\n\n          /* Scale transparent_color to short */\n          transparent_color.red= scale_to_short*ping_trans_color->red;\n          transparent_color.green= scale_to_short*ping_trans_color->green;\n          transparent_color.blue= scale_to_short*ping_trans_color->blue;\n          transparent_color.alpha= scale_to_short*ping_trans_color->gray;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Raw tRNS graylevel = %d, scaled graylevel = %d.\",\n                  (int) ping_trans_color->gray,(int) transparent_color.alpha);\n\n              }\n              transparent_color.red=transparent_color.alpha;\n              transparent_color.green=transparent_color.alpha;\n              transparent_color.blue=transparent_color.alpha;\n            }\n        }\n    }\n#if defined(PNG_READ_sBIT_SUPPORTED)\n  if (mng_info->have_global_sbit)\n    {\n      if (!png_get_valid(ping,ping_info,PNG_INFO_sBIT))\n        png_set_sBIT(ping,ping_info,&mng_info->global_sbit);\n    }\n#endif\n  num_passes=png_set_interlace_handling(ping);\n\n  png_read_update_info(ping,ping_info);\n\n  ping_rowbytes=png_get_rowbytes(ping,ping_info);\n\n  /*\n    Initialize image structure.\n  */\n  mng_info->image_box.left=0;\n  mng_info->image_box.right=(ssize_t) ping_width;\n  mng_info->image_box.top=0;\n  mng_info->image_box.bottom=(ssize_t) ping_height;\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=ping_width;\n      mng_info->mng_height=ping_height;\n      mng_info->frame=mng_info->image_box;\n      mng_info->clip=mng_info->image_box;\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  image->compression=ZipCompression;\n  image->columns=ping_width;\n  image->rows=ping_height;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      double\n        image_gamma = image->gamma;\n\n      (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    image->gamma=%f\",(float) image_gamma);\n\n      if (image_gamma > 0.75)\n        {\n          /* Set image->rendering_intent to Undefined,\n           * image->colorspace to GRAY, and reset image->chromaticity.\n           */\n          image->intensity = Rec709LuminancePixelIntensityMethod;\n          SetImageColorspace(image,GRAYColorspace,exception);\n        }\n      else\n        {\n          RenderingIntent\n            save_rendering_intent = image->rendering_intent;\n          ChromaticityInfo\n            save_chromaticity = image->chromaticity;\n\n          SetImageColorspace(image,GRAYColorspace,exception);\n          image->rendering_intent = save_rendering_intent;\n          image->chromaticity = save_chromaticity;\n        }\n\n      image->gamma = image_gamma;\n    }\n\n  (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    image->colorspace=%d\",(int) image->colorspace);\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n      ((int) ping_bit_depth < 16 &&\n      (int) ping_color_type == PNG_COLOR_TYPE_GRAY))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      one=1;\n      image->colors=one << ping_file_depth;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n      if (image->colors > 256)\n        image->colors=256;\n#else\n      if (image->colors > 65536L)\n        image->colors=65536L;\n#endif\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n          image->colors=(size_t) number_colors;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG PLTE chunk: number_colors: %d.\",number_colors);\n        }\n    }\n\n  if (image->storage_class == PseudoClass)\n    {\n      /*\n        Initialize image colormap.\n      */\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        png_error(ping,\"Memory allocation failed\");\n\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n          for (i=0; i < (ssize_t) number_colors; i++)\n          {\n            image->colormap[i].red=ScaleCharToQuantum(palette[i].red);\n            image->colormap[i].green=ScaleCharToQuantum(palette[i].green);\n            image->colormap[i].blue=ScaleCharToQuantum(palette[i].blue);\n          }\n\n          for ( ; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=0;\n            image->colormap[i].green=0;\n            image->colormap[i].blue=0;\n          }\n        }\n\n      else\n        {\n          Quantum\n            scale;\n\n          scale = (Quantum) (65535.0/((1UL << ping_file_depth)-1.0));\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n          scale = ScaleShortToQuantum(scale);\n#endif\n\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=(Quantum) (i*scale);\n            image->colormap[i].green=(Quantum) (i*scale);\n            image->colormap[i].blue=(Quantum) (i*scale);\n          }\n       }\n    }\n\n   /* Set some properties for reporting by \"identify\" */\n    {\n      char\n        msg[MagickPathExtent];\n\n     /* encode ping_width, ping_height, ping_file_depth, ping_color_type,\n        ping_interlace_method in value */\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\n         \"%d, %d\",(int) ping_width, (int) ping_height);\n     (void) SetImageProperty(image,\"png:IHDR.width,height\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n        (int) ping_file_depth);\n     (void) SetImageProperty(image,\"png:IHDR.bit_depth\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d (%s)\",\n         (int) ping_color_type,\n         Magick_ColorType_from_PNG_ColorType((int)ping_color_type));\n     (void) SetImageProperty(image,\"png:IHDR.color_type\",msg,exception);\n\n     if (ping_interlace_method == 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Not interlaced)\",\n            (int) ping_interlace_method);\n       }\n     else if (ping_interlace_method == 1)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Adam7 method)\",\n            (int) ping_interlace_method);\n       }\n     else\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Unknown method)\",\n            (int) ping_interlace_method);\n       }\n       (void) SetImageProperty(image,\"png:IHDR.interlace_method\",\n         msg,exception);\n\n     if (number_colors != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n            (int) number_colors);\n         (void) SetImageProperty(image,\"png:PLTE.number_colors\",msg,\n            exception);\n       }\n   }\n#if defined(PNG_tIME_SUPPORTED)\n   read_tIME_chunk(image,ping,ping_info,exception);\n#endif\n\n\n  /*\n    Read image scanlines.\n  */\n  if (image->delay != 0)\n    mng_info->scenes_found++;\n\n  if ((mng_info->mng_type == 0 && (image->ping != MagickFalse)) || (\n      (image_info->number_scenes != 0) && (mng_info->scenes_found > (ssize_t)\n      (image_info->first_scene+image_info->number_scenes))))\n    {\n      /* This happens later in non-ping decodes */\n      if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        image->storage_class=DirectClass;\n      image->alpha_trait=\n        (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n         (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Skipping PNG image data for scene %.20g\",(double)\n          mng_info->scenes_found-1);\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage().\");\n\n      return(image);\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading PNG IDAT chunk(s)\");\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (num_passes > 1)\n    pixel_info=AcquireVirtualMemory(image->rows,ping_rowbytes*\n      sizeof(*ping_pixels));\n  else\n    pixel_info=AcquireVirtualMemory(ping_rowbytes,sizeof(*ping_pixels));\n\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Memory allocation failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Converting PNG pixels to pixel packets\");\n  /*\n    Convert PNG pixels to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n\n  if (quantum_info == (QuantumInfo *) NULL)\n     png_error(ping,\"Failed to allocate quantum_info\");\n\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n\n  {\n\n   MagickBooleanType\n     found_transparent_pixel;\n\n  found_transparent_pixel=MagickFalse;\n\n  if (image->storage_class == DirectClass)\n    {\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        image->alpha_trait=\n            (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n            ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n            (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n            BlendPixelTrait : UndefinedPixelTrait;\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (num_passes > 1)\n            row_offset=ping_rowbytes*y;\n\n          else\n            row_offset=0;\n\n          png_read_row(ping,ping_pixels+row_offset,NULL);\n\n          if (pass < num_passes-1)\n            continue;\n\n          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (q == (Quantum *) NULL)\n            break;\n\n          if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayAlphaQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBAQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              IndexQuantum,ping_pixels+row_offset,exception);\n\n          else /* ping_color_type == PNG_COLOR_TYPE_RGB */\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBQuantum,ping_pixels+row_offset,exception);\n\n          if (found_transparent_pixel == MagickFalse)\n            {\n              /* Is there a transparent pixel in the row? */\n              if (y== 0 && logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Looking for cheap transparent pixel\");\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                if ((ping_color_type == PNG_COLOR_TYPE_RGBA ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) &&\n                   (GetPixelAlpha(image,q) != OpaqueAlpha))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                if ((ping_color_type == PNG_COLOR_TYPE_RGB ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY) &&\n                    (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                    transparent_color.red &&\n                    ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                    transparent_color.green &&\n                    ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                    transparent_color.blue))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                q+=GetPixelChannels(image);\n              }\n            }\n\n          if (num_passes == 1)\n            {\n              status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y, image->rows);\n\n              if (status == MagickFalse)\n                break;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n\n        if (num_passes != 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    }\n\n  else /* image->storage_class != DirectClass */\n\n    for (pass=0; pass < num_passes; pass++)\n    {\n      Quantum\n        *quantum_scanline;\n\n      register Quantum\n        *r;\n\n      /*\n        Convert grayscale image to PseudoClass pixel packets.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Converting grayscale pixels to pixel packets\");\n\n      image->alpha_trait=ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      quantum_scanline=(Quantum *) AcquireQuantumMemory(image->columns,\n        (image->alpha_trait  == BlendPixelTrait?  2 : 1)*\n        sizeof(*quantum_scanline));\n\n      if (quantum_scanline == (Quantum *) NULL)\n        png_error(ping,\"Memory allocation failed\");\n\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        Quantum\n           alpha;\n\n        if (num_passes > 1)\n          row_offset=ping_rowbytes*y;\n\n        else\n          row_offset=0;\n\n        png_read_row(ping,ping_pixels+row_offset,NULL);\n\n        if (pass < num_passes-1)\n          continue;\n\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n\n        p=ping_pixels+row_offset;\n        r=quantum_scanline;\n\n        switch (ping_bit_depth)\n        {\n          case 8:\n          {\n\n            if (ping_color_type == 4)\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                *r++=*p++;\n\n                alpha=ScaleCharToQuantum((unsigned char)*p++);\n\n                SetPixelAlpha(image,alpha,q);\n\n                if (alpha != OpaqueAlpha)\n                  found_transparent_pixel = MagickTrue;\n\n                q+=GetPixelChannels(image);\n              }\n\n            else\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                *r++=*p++;\n\n            break;\n          }\n\n          case 16:\n          {\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n#if (MAGICKCORE_QUANTUM_DEPTH >= 16)\n              unsigned short\n                quantum;\n\n              if (image->colors > 256)\n                quantum=((*p++) << 8);\n\n              else\n                quantum=0;\n\n              quantum|=(*p++);\n              *r=ScaleShortToQuantum(quantum);\n              r++;\n\n              if (ping_color_type == 4)\n                {\n                  if (image->colors > 256)\n                    quantum=((*p++) << 8);\n                  else\n                    quantum=0;\n\n                  quantum|=(*p++);\n\n                  alpha=ScaleShortToQuantum(quantum);\n                  SetPixelAlpha(image,alpha,q);\n\n                  if (alpha != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  q+=GetPixelChannels(image);\n                }\n\n#else /* MAGICKCORE_QUANTUM_DEPTH == 8 */\n              *r++=(*p++);\n              p++; /* strip low byte */\n\n              if (ping_color_type == 4)\n                {\n                  SetPixelAlpha(image,*p++,q);\n\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n#endif\n            }\n\n            break;\n          }\n\n          default:\n            break;\n        }\n\n        /*\n          Transfer image scanline.\n        */\n        r=quantum_scanline;\n\n        q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelIndex(image,*r++,q);\n          q+=GetPixelChannels(image);\n        }\n\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n\n        if (num_passes == 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n\n            if (status == MagickFalse)\n              break;\n          }\n      }\n\n      if (num_passes != 1)\n        {\n          status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n\n          if (status == MagickFalse)\n            break;\n        }\n\n      quantum_scanline=(Quantum *) RelinquishMagickMemory(quantum_scanline);\n    }\n\n    image->alpha_trait=found_transparent_pixel ? BlendPixelTrait :\n      UndefinedPixelTrait;\n\n    if (logging != MagickFalse)\n      {\n        if (found_transparent_pixel != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Found transparent pixel\");\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    No transparent pixel was found\");\n\n            ping_color_type&=0x03;\n          }\n      }\n    }\n\n  quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (image->storage_class == PseudoClass)\n    {\n      PixelTrait\n        alpha_trait;\n\n      alpha_trait=image->alpha_trait;\n      image->alpha_trait=UndefinedPixelTrait;\n      (void) SyncImage(image,exception);\n      image->alpha_trait=alpha_trait;\n    }\n\n  png_read_end(ping,end_info);\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  image->storage_class=%d\\n\",(int) image->storage_class);\n  }\n\n  if (image_info->number_scenes != 0 && mng_info->scenes_found-1 <\n      (ssize_t) image_info->first_scene && image->delay != 0)\n    {\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n      pixel_info=RelinquishVirtualMemory(pixel_info);\n      image->colors=2;\n      (void) SetImageBackgroundColor(image,exception);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() early.\");\n      return(image);\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      ClassType\n        storage_class;\n\n      /*\n        Image has a transparent background.\n      */\n      storage_class=image->storage_class;\n      image->alpha_trait=BlendPixelTrait;\n\n/* Balfour fix from imagemagick discourse server, 5 Feb 2010 */\n\n      if (storage_class == PseudoClass)\n        {\n          if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            {\n              for (x=0; x < ping_num_trans; x++)\n              {\n                 image->colormap[x].alpha_trait=BlendPixelTrait;\n                 image->colormap[x].alpha =\n                   ScaleCharToQuantum((unsigned char)ping_trans_alpha[x]);\n              }\n            }\n\n          else if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              for (x=0; x < (int) image->colors; x++)\n              {\n                 if (ScaleQuantumToShort(image->colormap[x].red) ==\n                     transparent_color.alpha)\n                 {\n                    image->colormap[x].alpha_trait=BlendPixelTrait;\n                    image->colormap[x].alpha = (Quantum) TransparentAlpha;\n                 }\n              }\n            }\n          (void) SyncImage(image,exception);\n        }\n\n#if 1 /* Should have already been done above, but glennrp problem P10\n       * needs this.\n       */\n      else\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            image->storage_class=storage_class;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (q == (Quantum *) NULL)\n              break;\n\n\n            /* Caution: on a Q8 build, this does not distinguish between\n             * 16-bit colors that differ only in the low byte\n             */\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n              if (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                  transparent_color.red &&\n                  ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                  transparent_color.green &&\n                  ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                  transparent_color.blue)\n                {\n                  SetPixelAlpha(image,TransparentAlpha,q);\n                }\n\n#if 0 /* I have not found a case where this is needed. */\n              else\n                {\n                  SetPixelAlpha(image,q)=(Quantum) OpaqueAlpha;\n                }\n#endif\n\n              q+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n#endif\n\n      image->storage_class=DirectClass;\n    }\n\n  for (j = 0; j < 2; j++)\n  {\n    if (j == 0)\n      status = png_get_text(ping,ping_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n    else\n      status = png_get_text(ping,end_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n\n    if (status != MagickFalse)\n      for (i=0; i < (ssize_t) num_text; i++)\n      {\n        /* Check for a profile */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG text chunk\");\n\n        if (strlen(text[i].key) > 16 &&\n            memcmp(text[i].key, \"Raw profile type \",17) == 0)\n          {\n            const char\n              *value;\n\n            value=GetImageOption(image_info,\"profile:skip\");\n\n            if (IsOptionMember(text[i].key+17,value) == MagickFalse)\n            {\n               (void) Magick_png_read_raw_profile(ping,image,image_info,text,\n                  (int) i,exception);\n               num_raw_profiles++;\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Read raw profile %s\",text[i].key+17);\n            }\n            else\n            {\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Skipping raw profile %s\",text[i].key+17);\n            }\n          }\n\n        else\n          {\n            char\n              *value;\n\n            length=text[i].text_length;\n            value=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n              sizeof(*value));\n            if (value == (char *) NULL)\n              {\n                png_error(ping,\"Memory allocation failed\");\n                break;\n              }\n            *value='\\0';\n            (void) ConcatenateMagickString(value,text[i].text,length+2);\n\n            /* Don't save \"density\" or \"units\" property if we have a pHYs\n             * chunk\n             */\n            if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs) ||\n                (LocaleCompare(text[i].key,\"density\") != 0 &&\n                LocaleCompare(text[i].key,\"units\") != 0))\n               (void) SetImageProperty(image,text[i].key,value,exception);\n\n            if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      length: %lu\\n\"\n                \"      Keyword: %s\",\n                (unsigned long) length,\n                text[i].key);\n            }\n\n            value=DestroyString(value);\n          }\n      }\n    num_text_total += num_text;\n  }\n\n#ifdef MNG_OBJECT_BUFFERS\n  /*\n    Store the object if necessary.\n  */\n  if (object_id && !mng_info->frozen[object_id])\n    {\n      if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n        {\n          /*\n            create a new object buffer.\n          */\n          mng_info->ob[object_id]=(MngBuffer *)\n            AcquireMagickMemory(sizeof(MngBuffer));\n\n          if (mng_info->ob[object_id] != (MngBuffer *) NULL)\n            {\n              mng_info->ob[object_id]->image=(Image *) NULL;\n              mng_info->ob[object_id]->reference_count=1;\n            }\n        }\n\n      if ((mng_info->ob[object_id] == (MngBuffer *) NULL) ||\n          mng_info->ob[object_id]->frozen)\n        {\n          if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n             png_error(ping,\"Memory allocation failed\");\n\n          if (mng_info->ob[object_id]->frozen)\n            png_error(ping,\"Cannot overwrite frozen MNG object buffer\");\n        }\n\n      else\n        {\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image=DestroyImage\n                (mng_info->ob[object_id]->image);\n\n          mng_info->ob[object_id]->image=CloneImage(image,0,0,MagickTrue,\n            exception);\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image->file=(FILE *) NULL;\n\n          else\n            png_error(ping, \"Cloning image for object buffer failed\");\n\n          if (ping_width > 250000L || ping_height > 250000L)\n             png_error(ping,\"PNG Image dimensions are too large.\");\n\n          mng_info->ob[object_id]->width=ping_width;\n          mng_info->ob[object_id]->height=ping_height;\n          mng_info->ob[object_id]->color_type=ping_color_type;\n          mng_info->ob[object_id]->sample_depth=ping_bit_depth;\n          mng_info->ob[object_id]->interlace_method=ping_interlace_method;\n          mng_info->ob[object_id]->compression_method=\n             ping_compression_method;\n          mng_info->ob[object_id]->filter_method=ping_filter_method;\n\n          if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n            {\n              png_colorp\n                plte;\n\n              /*\n                Copy the PLTE to the object buffer.\n              */\n              png_get_PLTE(ping,ping_info,&plte,&number_colors);\n              mng_info->ob[object_id]->plte_length=number_colors;\n\n              for (i=0; i < number_colors; i++)\n              {\n                mng_info->ob[object_id]->plte[i]=plte[i];\n              }\n            }\n\n          else\n              mng_info->ob[object_id]->plte_length=0;\n        }\n    }\n#endif\n\n   /* Set image->alpha_trait to MagickTrue if the input colortype supports\n    * alpha or if a valid tRNS chunk is present, no matter whether there\n    * is actual transparency present.\n    */\n    image->alpha_trait=(((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n        ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n        (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n#if 0  /* I'm not sure what's wrong here but it does not work. */\n    if (image->alpha_trait != UndefinedPixelTrait)\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        (void) SetImageType(image,GrayscaleAlphaType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n    }\n\n    else\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        (void) SetImageType(image,GrayscaleType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n    }\n#endif\n\n   /* Set more properties for identify to retrieve */\n   {\n     char\n       msg[MagickPathExtent];\n\n     if (num_text_total != 0)\n       {\n         /* libpng doesn't tell us whether they were tEXt, zTXt, or iTXt */\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d tEXt/zTXt/iTXt chunks were found\", num_text_total);\n         (void) SetImageProperty(image,\"png:text\",msg,\n                exception);\n       }\n\n     if (num_raw_profiles != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d were found\", num_raw_profiles);\n         (void) SetImageProperty(image,\"png:text-encoded profiles\",msg,\n                exception);\n       }\n\n     /* cHRM chunk: */\n     if (ping_found_cHRM != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Chromaticity, above)\");\n         (void) SetImageProperty(image,\"png:cHRM\",msg,\n                exception);\n       }\n\n     /* bKGD chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Background color, above)\");\n         (void) SetImageProperty(image,\"png:bKGD\",msg,\n                exception);\n       }\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n        \"chunk was found\");\n\n#if defined(PNG_iCCP_SUPPORTED)\n     /* iCCP chunk: */\n     if (ping_found_iCCP != MagickFalse)\n        (void) SetImageProperty(image,\"png:iCCP\",msg,\n                exception);\n#endif\n\n     if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        (void) SetImageProperty(image,\"png:tRNS\",msg,\n                exception);\n\n#if defined(PNG_sRGB_SUPPORTED)\n     /* sRGB chunk: */\n     if (ping_found_sRGB != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"intent=%d (%s)\",\n            (int) intent,\n            Magick_RenderingIntentString_from_PNG_RenderingIntent(intent));\n         (void) SetImageProperty(image,\"png:sRGB\",msg,\n                 exception);\n       }\n#endif\n\n     /* gAMA chunk: */\n     if (ping_found_gAMA != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"gamma=%.8g (See Gamma, above)\",\n            file_gamma);\n         (void) SetImageProperty(image,\"png:gAMA\",msg,\n                exception);\n       }\n\n#if defined(PNG_pHYs_SUPPORTED)\n     /* pHYs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_res=%.10g, y_res=%.10g, units=%d\",\n            (double) x_resolution,(double) y_resolution, unit_type);\n         (void) SetImageProperty(image,\"png:pHYs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_oFFs_SUPPORTED)\n     /* oFFs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_off=%.20g, y_off=%.20g\",\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:oFFs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_tIME_SUPPORTED)\n     read_tIME_chunk(image,ping,end_info,exception);\n#endif\n\n     /* caNv chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows) ||\n         (image->page.x != 0 || image->page.y != 0))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g, x_offset=%.20g, y_offset=%.20g\",\n            (double) image->page.width,(double) image->page.height,\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:caNv\",msg,\n                exception);\n       }\n\n     /* vpAg chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g\",\n            (double) image->page.width,(double) image->page.height);\n         (void) SetImageProperty(image,\"png:vpAg\",msg,\n                exception);\n       }\n   }\n\n  /*\n    Relinquish resources.\n  */\n  png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n  /* }  for navigation to beginning of SETJMP-protected block, revert to\n   *    Throwing an Exception when an error occurs.\n   */\n\n  return(image);\n\n/* end of reading one PNG image */\n}\n",
        "post_patch": "static Image *ReadOnePNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  /* Read one PNG image */\n\n  /* To do: Read the tEXt/Creation Time chunk into the date:create property */\n\n  Image\n    *image;\n\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  int\n    intent, /* \"PNG Rendering intent\", which is ICC intent + 1 */\n    num_raw_profiles,\n    num_text,\n    num_text_total,\n    num_passes,\n    number_colors,\n    pass,\n    ping_bit_depth,\n    ping_color_type,\n    ping_file_depth,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans,\n    unit_type;\n\n  double\n    file_gamma;\n\n  MagickBooleanType\n    logging,\n    ping_found_cHRM,\n    ping_found_gAMA,\n    ping_found_iCCP,\n    ping_found_sRGB,\n    ping_found_sRGB_cHRM,\n    ping_preserve_iCCP,\n    status;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  PixelInfo\n    transparent_color;\n\n  PNGErrorInfo\n    error_info;\n\n  png_bytep\n     ping_trans_alpha;\n\n  png_color_16p\n     ping_background,\n     ping_trans_color;\n\n  png_info\n    *end_info,\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_textp\n    text;\n\n  png_uint_32\n    ping_height,\n    ping_width,\n    x_resolution,\n    y_resolution;\n\n  QuantumInfo\n    *quantum_info;\n\n  ssize_t\n    ping_rowbytes,\n    y;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length,\n    row_offset;\n\n  ssize_t\n    j;\n\n  unsigned char\n    *ping_pixels;\n\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n  png_byte unused_chunks[]=\n  {\n    104,  73,  83,  84, (png_byte) '\\0',   /* hIST */\n    105,  84,  88, 116, (png_byte) '\\0',   /* iTXt */\n    112,  67,  65,  76, (png_byte) '\\0',   /* pCAL */\n    115,  67,  65,  76, (png_byte) '\\0',   /* sCAL */\n    115,  80,  76,  84, (png_byte) '\\0',   /* sPLT */\n#if !defined(PNG_tIME_SUPPORTED)\n    116,  73,  77,  69, (png_byte) '\\0',   /* tIME */\n#endif\n#ifdef PNG_APNG_SUPPORTED /* libpng was built with APNG patch; */\n                          /* ignore the APNG chunks */\n     97,  99,  84,  76, (png_byte) '\\0',   /* acTL */\n    102,  99,  84,  76, (png_byte) '\\0',   /* fcTL */\n    102, 100,  65,  84, (png_byte) '\\0',   /* fdAT */\n#endif\n  };\n#endif\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,32);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,32);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  Enter ReadOnePNGImage()\\n\"\n       \"    IM version     = %s\\n\"\n       \"    Libpng version = %s\",\n       im_vers, libpng_vers);\n\n  if (logging != MagickFalse)\n  {\n    if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n    {\n   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        libpng_runv);\n    }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n        zlib_vers);\n    if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n    {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n        zlib_runv);\n    }\n  }\n\n#if (PNG_LIBPNG_VER < 10200)\n  if (image_info->verbose)\n    printf(\"Your PNG library (libpng-%s) is rather old.\\n\",\n       PNG_LIBPNG_VER_STRING);\n#endif\n\n#if (PNG_LIBPNG_VER >= 10400)\n#  ifndef  PNG_TRANSFORM_GRAY_TO_RGB    /* Added at libpng-1.4.0beta67 */\n  if (image_info->verbose)\n    {\n      printf(\"Your PNG library (libpng-%s) is an old beta version.\\n\",\n           PNG_LIBPNG_VER_STRING);\n      printf(\"Please update it.\\n\");\n    }\n#  endif\n#endif\n\n\n  quantum_info = (QuantumInfo *) NULL;\n  image=mng_info->image;\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"    Before reading:\\n\"\n       \"      image->alpha_trait=%d\"\n       \"      image->rendering_intent=%d\\n\"\n       \"      image->colorspace=%d\\n\"\n       \"      image->gamma=%f\",\n       (int) image->alpha_trait, (int) image->rendering_intent,\n       (int) image->colorspace, image->gamma);\n  }\n  intent=\n    Magick_RenderingIntent_to_PNG_RenderingIntent(image->rendering_intent);\n\n  /* Set to an out-of-range color unless tRNS chunk is present */\n  transparent_color.red=65537;\n  transparent_color.green=65537;\n  transparent_color.blue=65537;\n  transparent_color.alpha=65537;\n\n  number_colors=0;\n  num_text = 0;\n  num_text_total = 0;\n  num_raw_profiles = 0;\n\n  ping_found_cHRM = MagickFalse;\n  ping_found_gAMA = MagickFalse;\n  ping_found_iCCP = MagickFalse;\n  ping_found_sRGB = MagickFalse;\n  ping_found_sRGB_cHRM = MagickFalse;\n  ping_preserve_iCCP = MagickFalse;\n\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n ping=png_create_read_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n   MagickPNGErrorHandler,MagickPNGWarningHandler, NULL,\n   (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n#else\n  ping=png_create_read_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,(png_info **) NULL,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  end_info=png_create_info_struct(ping);\n\n  if (end_info == (png_info *) NULL)\n    {\n      png_destroy_read_struct(&ping,&ping_info,(png_info **) NULL);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n       /*\n         PNG image is corrupt.\n       */\n      printf(\"  destroy_read_struct\\n\");\n       png_destroy_read_struct(&ping,&ping_info,&end_info);\n \n #ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() with error.\");\n\n      return(GetFirstImageInList(image));\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for reading.\n  */\n\n  mng_info->image_found++;\n  png_set_sig_bytes(ping,8);\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n      (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED)\n      png_permit_empty_plte(ping,MagickTrue);\n      png_set_read_fn(ping,image,png_get_data);\n#else\n      mng_info->image=image;\n      mng_info->bytes_in_read_buffer=0;\n      mng_info->found_empty_plte=MagickFalse;\n      mng_info->have_saved_bkgd_index=MagickFalse;\n      png_set_read_fn(ping,mng_info,mng_get_data);\n#endif\n#endif\n    }\n\n  else\n    png_set_read_fn(ping,image,png_get_data);\n\n  {\n    const char\n      *value;\n\n    value=GetImageOption(image_info,\"profile:skip\");\n\n    if (IsOptionMember(\"ICC\",value) == MagickFalse)\n    {\n\n       value=GetImageOption(image_info,\"png:preserve-iCCP\");\n\n       if (value == NULL)\n          value=GetImageArtifact(image,\"png:preserve-iCCP\");\n\n       if (value != NULL)\n          ping_preserve_iCCP=MagickTrue;\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n       /* Don't let libpng check for ICC/sRGB profile because we're going\n        * to do that anyway.  This feature was added at libpng-1.6.12.\n        * If logging, go ahead and check and issue a warning as appropriate.\n        */\n       if (logging == MagickFalse)\n          png_set_option(ping, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n    }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    else\n    {\n       png_set_keep_unknown_chunks(ping, 1, (png_bytep) mng_iCCP, 1);\n    }\n#endif\n  }\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n  /* Ignore unused chunks and all unknown chunks except for eXIf,\n     caNv, and vpAg */\n# if PNG_LIBPNG_VER < 10700 /* Avoid libpng16 warning */\n  png_set_keep_unknown_chunks(ping, 2, NULL, 0);\n# else\n  png_set_keep_unknown_chunks(ping, 1, NULL, 0);\n# endif\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_eXIf, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_caNv, 1);\n  png_set_keep_unknown_chunks(ping, 2, (png_bytep) mng_vpAg, 1);\n  png_set_keep_unknown_chunks(ping, 1, unused_chunks,\n     (int)sizeof(unused_chunks)/5);\n  /* Callback for other unknown chunks */\n  png_set_read_user_chunk_fn(ping, image, read_user_chunk_callback);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n#  if (PNG_LIBPNG_VER >= 10400)\n    /* Limit the size of the chunk storage cache used for sPLT, text,\n     * and unknown chunks.\n     */\n    png_set_chunk_cache_max(ping, 32767);\n#  endif\n#endif\n\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\n    /* Disable new libpng-1.5.10 feature */\n    png_set_check_for_invalid_index (ping, 0);\n#endif\n\n#if (PNG_LIBPNG_VER < 10400)\n#  if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && \\\n   (PNG_LIBPNG_VER >= 10200) && (PNG_LIBPNG_VER < 10220) && defined(__i386__)\n  /* Disable thread-unsafe features of pnggccrd */\n  if (png_access_version_number() >= 10200)\n  {\n    png_uint_32 mmx_disable_mask=0;\n    png_uint_32 asm_flags;\n\n    mmx_disable_mask |= ( PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_SUB   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_AVG   \\\n                        | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH );\n    asm_flags=png_get_asm_flags(ping);\n    png_set_asm_flags(ping, asm_flags & ~mmx_disable_mask);\n  }\n#  endif\n#endif\n\n  png_read_info(ping,ping_info);\n\n  png_get_IHDR(ping,ping_info,&ping_width,&ping_height,\n               &ping_bit_depth,&ping_color_type,\n               &ping_interlace_method,&ping_compression_method,\n               &ping_filter_method);\n\n  ping_file_depth = ping_bit_depth;\n\n  /* Swap bytes if requested */\n  if (ping_file_depth == 16)\n  {\n     const char\n       *value;\n\n     value=GetImageOption(image_info,\"png:swap-bytes\");\n\n     if (value == NULL)\n        value=GetImageArtifact(image,\"png:swap-bytes\");\n\n     if (value != NULL)\n        png_set_swap(ping);\n  }\n\n  /* Save bit-depth and color-type in case we later want to write a PNG00 */\n  {\n      char\n        msg[MagickPathExtent];\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_color_type);\n      (void) SetImageProperty(image,\"png:IHDR.color-type-orig\",msg,exception);\n\n      (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n         (int) ping_bit_depth);\n      (void) SetImageProperty(image,\"png:IHDR.bit-depth-orig\",msg,exception);\n  }\n\n  (void) png_get_tRNS(ping, ping_info, &ping_trans_alpha, &ping_num_trans,\n                      &ping_trans_color);\n\n  (void) png_get_bKGD(ping, ping_info, &ping_background);\n\n  if (ping_bit_depth < 8)\n    {\n       png_set_packing(ping);\n       ping_bit_depth = 8;\n    }\n\n  image->depth=ping_bit_depth;\n  image->depth=GetImageQuantumDepth(image,MagickFalse);\n  image->interlace=ping_interlace_method != 0 ? PNGInterlace : NoInterlace;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      image->rendering_intent=UndefinedIntent;\n      intent=Magick_RenderingIntent_to_PNG_RenderingIntent(UndefinedIntent);\n      (void) ResetMagickMemory(&image->chromaticity,0,\n        sizeof(image->chromaticity));\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG width: %.20g, height: %.20g\\n\"\n        \"    PNG color_type: %d, bit_depth: %d\\n\"\n        \"    PNG compression_method: %d\\n\"\n        \"    PNG interlace_method: %d, filter_method: %d\",\n        (double) ping_width, (double) ping_height,\n        ping_color_type, ping_bit_depth,\n        ping_compression_method,\n        ping_interlace_method,ping_filter_method);\n\n    }\n\n  if (png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_gAMA))\n    {\n      ping_found_gAMA=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG gAMA chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      ping_found_cHRM=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG cHRM chunk.\");\n    }\n\n  if (ping_found_iCCP != MagickTrue && png_get_valid(ping,ping_info,\n      PNG_INFO_sRGB))\n    {\n      ping_found_sRGB=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG sRGB chunk.\");\n    }\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n    if (ping_found_iCCP !=MagickTrue &&\n      ping_found_sRGB != MagickTrue &&\n      png_get_valid(ping,ping_info, PNG_INFO_iCCP))\n    {\n      ping_found_iCCP=MagickTrue;\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Found PNG iCCP chunk.\");\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_iCCP))\n    {\n      int\n        compression;\n\n#if (PNG_LIBPNG_VER < 10500)\n      png_charp\n        info;\n#else\n      png_bytep\n        info;\n#endif\n\n      png_charp\n        name;\n\n      png_uint_32\n        profile_length;\n\n      (void) png_get_iCCP(ping,ping_info,&name,(int *) &compression,&info,\n        &profile_length);\n\n      if (profile_length != 0)\n        {\n          StringInfo\n            *profile;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG iCCP chunk.\");\n\n          profile=BlobToStringInfo(info,profile_length);\n\n          if (profile == (StringInfo *) NULL)\n          {\n            png_warning(ping, \"ICC profile is NULL\");\n            profile=DestroyStringInfo(profile);\n          }\n          else\n          {\n            if (ping_preserve_iCCP == MagickFalse)\n            {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                 {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n                 }\n            }\n            else /* Preserve-iCCP */\n            {\n                    (void) SetImageProfile(image,\"icc\",profile,exception);\n            }\n\n            profile=DestroyStringInfo(profile);\n          }\n      }\n    }\n#endif\n\n#if defined(PNG_READ_sRGB_SUPPORTED)\n  {\n    if (ping_found_iCCP==MagickFalse && png_get_valid(ping,ping_info,\n        PNG_INFO_sRGB))\n    {\n      if (png_get_sRGB(ping,ping_info,&intent))\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n             Magick_RenderingIntent_from_PNG_RenderingIntent (intent);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG sRGB chunk: rendering_intent: %d\",intent);\n      }\n    }\n\n    else if (mng_info->have_global_srgb)\n      {\n        if (image->rendering_intent == UndefinedIntent)\n          image->rendering_intent=\n            Magick_RenderingIntent_from_PNG_RenderingIntent\n            (mng_info->global_srgb_intent);\n      }\n  }\n#endif\n\n\n  {\n     if (!png_get_gAMA(ping,ping_info,&file_gamma))\n       if (mng_info->have_global_gama)\n         png_set_gAMA(ping,ping_info,mng_info->global_gamma);\n\n     if (png_get_gAMA(ping,ping_info,&file_gamma))\n       {\n         image->gamma=(float) file_gamma;\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading PNG gAMA chunk: gamma: %f\",file_gamma);\n       }\n  }\n\n  if (!png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      if (mng_info->have_global_chrm != MagickFalse)\n        {\n          (void) png_set_cHRM(ping,ping_info,\n            mng_info->global_chrm.white_point.x,\n            mng_info->global_chrm.white_point.y,\n            mng_info->global_chrm.red_primary.x,\n            mng_info->global_chrm.red_primary.y,\n            mng_info->global_chrm.green_primary.x,\n            mng_info->global_chrm.green_primary.y,\n            mng_info->global_chrm.blue_primary.x,\n            mng_info->global_chrm.blue_primary.y);\n        }\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_cHRM))\n    {\n      (void) png_get_cHRM(ping,ping_info,\n        &image->chromaticity.white_point.x,\n        &image->chromaticity.white_point.y,\n        &image->chromaticity.red_primary.x,\n        &image->chromaticity.red_primary.y,\n        &image->chromaticity.green_primary.x,\n        &image->chromaticity.green_primary.y,\n        &image->chromaticity.blue_primary.x,\n        &image->chromaticity.blue_primary.y);\n\n       ping_found_cHRM=MagickTrue;\n\n       if (image->chromaticity.red_primary.x>0.6399f &&\n           image->chromaticity.red_primary.x<0.6401f &&\n           image->chromaticity.red_primary.y>0.3299f &&\n           image->chromaticity.red_primary.y<0.3301f &&\n           image->chromaticity.green_primary.x>0.2999f &&\n           image->chromaticity.green_primary.x<0.3001f &&\n           image->chromaticity.green_primary.y>0.5999f &&\n           image->chromaticity.green_primary.y<0.6001f &&\n           image->chromaticity.blue_primary.x>0.1499f &&\n           image->chromaticity.blue_primary.x<0.1501f &&\n           image->chromaticity.blue_primary.y>0.0599f &&\n           image->chromaticity.blue_primary.y<0.0601f &&\n           image->chromaticity.white_point.x>0.3126f &&\n           image->chromaticity.white_point.x<0.3128f &&\n           image->chromaticity.white_point.y>0.3289f &&\n           image->chromaticity.white_point.y<0.3291f)\n          ping_found_sRGB_cHRM=MagickTrue;\n    }\n\n  if (image->rendering_intent != UndefinedIntent)\n    {\n      if (ping_found_sRGB != MagickTrue &&\n          (ping_found_gAMA != MagickTrue ||\n          (image->gamma > .45 && image->gamma < .46)) &&\n          (ping_found_cHRM != MagickTrue ||\n          ping_found_sRGB_cHRM != MagickFalse) &&\n          ping_found_iCCP != MagickTrue)\n      {\n         png_set_sRGB(ping,ping_info,\n            Magick_RenderingIntent_to_PNG_RenderingIntent\n            (image->rendering_intent));\n         file_gamma=1.000f/2.200f;\n         ping_found_sRGB=MagickTrue;\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"    Setting sRGB as if in input\");\n      }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n    {\n      image->page.x=(ssize_t) png_get_x_offset_pixels(ping, ping_info);\n      image->page.y=(ssize_t) png_get_y_offset_pixels(ping, ping_info);\n\n      if (logging != MagickFalse)\n        if (image->page.x || image->page.y)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG oFFs chunk: x: %.20g, y: %.20g.\",(double)\n            image->page.x,(double) image->page.y);\n    }\n#endif\n#if defined(PNG_pHYs_SUPPORTED)\n  if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      if (mng_info->have_global_phys)\n        {\n          png_set_pHYs(ping,ping_info,\n                       mng_info->global_x_pixels_per_unit,\n                       mng_info->global_y_pixels_per_unit,\n                       mng_info->global_phys_unit_type);\n        }\n    }\n\n  x_resolution=0;\n  y_resolution=0;\n  unit_type=0;\n  if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n    {\n      /*\n        Set image resolution.\n      */\n      (void) png_get_pHYs(ping,ping_info,&x_resolution,&y_resolution,\n        &unit_type);\n      image->resolution.x=(double) x_resolution;\n      image->resolution.y=(double) y_resolution;\n\n      if (unit_type == PNG_RESOLUTION_METER)\n        {\n          image->units=PixelsPerCentimeterResolution;\n          image->resolution.x=(double) x_resolution/100.0;\n          image->resolution.y=(double) y_resolution/100.0;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) x_resolution,(double) y_resolution,unit_type);\n    }\n#endif\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n    {\n      png_colorp\n        palette;\n\n      (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n      if ((number_colors == 0) &&\n          ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE))\n        {\n          if (mng_info->global_plte_length)\n            {\n              png_set_PLTE(ping,ping_info,mng_info->global_plte,\n                (int) mng_info->global_plte_length);\n\n              if (!png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n              {\n                if (mng_info->global_trns_length)\n                  {\n                    png_warning(ping,\n                      \"global tRNS has more entries than global PLTE\");\n                  }\n                else\n                  {\n                     png_set_tRNS(ping,ping_info,mng_info->global_trns,\n                       (int) mng_info->global_trns_length,NULL);\n                  }\n               }\n#ifdef PNG_READ_bKGD_SUPPORTED\n              if (\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                   mng_info->have_saved_bkgd_index ||\n#endif\n                   png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n                    {\n                      png_color_16\n                         background;\n\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n                      if (mng_info->have_saved_bkgd_index)\n                        background.index=mng_info->saved_bkgd_index;\n#endif\n                      if (png_get_valid(ping, ping_info, PNG_INFO_bKGD))\n                        background.index=ping_background->index;\n\n                      background.red=(png_uint_16)\n                        mng_info->global_plte[background.index].red;\n\n                      background.green=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      background.blue=(png_uint_16)\n                        mng_info->global_plte[background.index].blue;\n\n                      background.gray=(png_uint_16)\n                        mng_info->global_plte[background.index].green;\n\n                      png_set_bKGD(ping,ping_info,&background);\n                    }\n#endif\n                }\n              else\n                png_error(ping,\"No global PLTE in file\");\n            }\n        }\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n  if (mng_info->have_global_bkgd &&\n          (!png_get_valid(ping,ping_info,PNG_INFO_bKGD)))\n      image->background_color=mng_info->mng_global_bkgd;\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n    {\n      unsigned int\n        bkgd_scale;\n\n      /* Set image background color.\n       * Scale background components to 16-bit, then scale\n       * to quantum depth\n       */\n\n        bkgd_scale = 1;\n\n        if (ping_file_depth == 1)\n           bkgd_scale = 255;\n\n        else if (ping_file_depth == 2)\n           bkgd_scale = 85;\n\n        else if (ping_file_depth == 4)\n           bkgd_scale = 17;\n\n        if (ping_file_depth <= 8)\n           bkgd_scale *= 257;\n\n        ping_background->red *= bkgd_scale;\n        ping_background->green *= bkgd_scale;\n        ping_background->blue *= bkgd_scale;\n\n        if (logging != MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Reading PNG bKGD chunk, raw ping_background=(%d,%d,%d)\\n\"\n                 \"    bkgd_scale=%d.  ping_background=(%d,%d,%d)\",\n                 ping_background->red,ping_background->green,\n                 ping_background->blue,\n                 bkgd_scale,ping_background->red,\n                 ping_background->green,ping_background->blue);\n          }\n\n        image->background_color.red=\n            ScaleShortToQuantum(ping_background->red);\n\n        image->background_color.green=\n            ScaleShortToQuantum(ping_background->green);\n\n        image->background_color.blue=\n          ScaleShortToQuantum(ping_background->blue);\n\n        image->background_color.alpha=OpaqueAlpha;\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    image->background_color=(%.20g,%.20g,%.20g).\",\n            (double) image->background_color.red,\n            (double) image->background_color.green,\n            (double) image->background_color.blue);\n    }\n#endif /* PNG_READ_bKGD_SUPPORTED */\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      /*\n        Image has a tRNS chunk.\n      */\n      int\n        max_sample;\n\n      size_t\n        one=1;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading PNG tRNS chunk.\");\n\n      max_sample = (int) ((one << ping_file_depth) - 1);\n\n      if ((ping_color_type == PNG_COLOR_TYPE_GRAY &&\n          (int)ping_trans_color->gray > max_sample) ||\n          (ping_color_type == PNG_COLOR_TYPE_RGB &&\n          ((int)ping_trans_color->red > max_sample ||\n          (int)ping_trans_color->green > max_sample ||\n          (int)ping_trans_color->blue > max_sample)))\n        {\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Ignoring PNG tRNS chunk with out-of-range sample.\");\n          png_free_data(ping, ping_info, PNG_FREE_TRNS, 0);\n          png_set_invalid(ping,ping_info,PNG_INFO_tRNS);\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n      else\n        {\n          int\n            scale_to_short;\n\n          scale_to_short = 65535L/((1UL << ping_file_depth)-1);\n\n          /* Scale transparent_color to short */\n          transparent_color.red= scale_to_short*ping_trans_color->red;\n          transparent_color.green= scale_to_short*ping_trans_color->green;\n          transparent_color.blue= scale_to_short*ping_trans_color->blue;\n          transparent_color.alpha= scale_to_short*ping_trans_color->gray;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Raw tRNS graylevel = %d, scaled graylevel = %d.\",\n                  (int) ping_trans_color->gray,(int) transparent_color.alpha);\n\n              }\n              transparent_color.red=transparent_color.alpha;\n              transparent_color.green=transparent_color.alpha;\n              transparent_color.blue=transparent_color.alpha;\n            }\n        }\n    }\n#if defined(PNG_READ_sBIT_SUPPORTED)\n  if (mng_info->have_global_sbit)\n    {\n      if (!png_get_valid(ping,ping_info,PNG_INFO_sBIT))\n        png_set_sBIT(ping,ping_info,&mng_info->global_sbit);\n    }\n#endif\n  num_passes=png_set_interlace_handling(ping);\n\n  png_read_update_info(ping,ping_info);\n\n  ping_rowbytes=png_get_rowbytes(ping,ping_info);\n\n  /*\n    Initialize image structure.\n  */\n  mng_info->image_box.left=0;\n  mng_info->image_box.right=(ssize_t) ping_width;\n  mng_info->image_box.top=0;\n  mng_info->image_box.bottom=(ssize_t) ping_height;\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=ping_width;\n      mng_info->mng_height=ping_height;\n      mng_info->frame=mng_info->image_box;\n      mng_info->clip=mng_info->image_box;\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  image->compression=ZipCompression;\n  image->columns=ping_width;\n  image->rows=ping_height;\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n      ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n    {\n      double\n        image_gamma = image->gamma;\n\n      (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    image->gamma=%f\",(float) image_gamma);\n\n      if (image_gamma > 0.75)\n        {\n          /* Set image->rendering_intent to Undefined,\n           * image->colorspace to GRAY, and reset image->chromaticity.\n           */\n          image->intensity = Rec709LuminancePixelIntensityMethod;\n          SetImageColorspace(image,GRAYColorspace,exception);\n        }\n      else\n        {\n          RenderingIntent\n            save_rendering_intent = image->rendering_intent;\n          ChromaticityInfo\n            save_chromaticity = image->chromaticity;\n\n          SetImageColorspace(image,GRAYColorspace,exception);\n          image->rendering_intent = save_rendering_intent;\n          image->chromaticity = save_chromaticity;\n        }\n\n      image->gamma = image_gamma;\n    }\n\n  (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    image->colorspace=%d\",(int) image->colorspace);\n\n  if (((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n      ((int) ping_bit_depth < 16 &&\n      (int) ping_color_type == PNG_COLOR_TYPE_GRAY))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      one=1;\n      image->colors=one << ping_file_depth;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n      if (image->colors > 256)\n        image->colors=256;\n#else\n      if (image->colors > 65536L)\n        image->colors=65536L;\n#endif\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n          image->colors=(size_t) number_colors;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Reading PNG PLTE chunk: number_colors: %d.\",number_colors);\n        }\n    }\n\n  if (image->storage_class == PseudoClass)\n    {\n      /*\n        Initialize image colormap.\n      */\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        png_error(ping,\"Memory allocation failed\");\n\n      if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n          png_colorp\n            palette;\n\n          (void) png_get_PLTE(ping,ping_info,&palette,&number_colors);\n\n          for (i=0; i < (ssize_t) number_colors; i++)\n          {\n            image->colormap[i].red=ScaleCharToQuantum(palette[i].red);\n            image->colormap[i].green=ScaleCharToQuantum(palette[i].green);\n            image->colormap[i].blue=ScaleCharToQuantum(palette[i].blue);\n          }\n\n          for ( ; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=0;\n            image->colormap[i].green=0;\n            image->colormap[i].blue=0;\n          }\n        }\n\n      else\n        {\n          Quantum\n            scale;\n\n          scale = (Quantum) (65535.0/((1UL << ping_file_depth)-1.0));\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n          scale = ScaleShortToQuantum(scale);\n#endif\n\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].red=(Quantum) (i*scale);\n            image->colormap[i].green=(Quantum) (i*scale);\n            image->colormap[i].blue=(Quantum) (i*scale);\n          }\n       }\n    }\n\n   /* Set some properties for reporting by \"identify\" */\n    {\n      char\n        msg[MagickPathExtent];\n\n     /* encode ping_width, ping_height, ping_file_depth, ping_color_type,\n        ping_interlace_method in value */\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\n         \"%d, %d\",(int) ping_width, (int) ping_height);\n     (void) SetImageProperty(image,\"png:IHDR.width,height\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n        (int) ping_file_depth);\n     (void) SetImageProperty(image,\"png:IHDR.bit_depth\",msg,exception);\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%d (%s)\",\n         (int) ping_color_type,\n         Magick_ColorType_from_PNG_ColorType((int)ping_color_type));\n     (void) SetImageProperty(image,\"png:IHDR.color_type\",msg,exception);\n\n     if (ping_interlace_method == 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Not interlaced)\",\n            (int) ping_interlace_method);\n       }\n     else if (ping_interlace_method == 1)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Adam7 method)\",\n            (int) ping_interlace_method);\n       }\n     else\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d (Unknown method)\",\n            (int) ping_interlace_method);\n       }\n       (void) SetImageProperty(image,\"png:IHDR.interlace_method\",\n         msg,exception);\n\n     if (number_colors != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%d\",\n            (int) number_colors);\n         (void) SetImageProperty(image,\"png:PLTE.number_colors\",msg,\n            exception);\n       }\n   }\n#if defined(PNG_tIME_SUPPORTED)\n   read_tIME_chunk(image,ping,ping_info,exception);\n#endif\n\n\n  /*\n    Read image scanlines.\n  */\n  if (image->delay != 0)\n    mng_info->scenes_found++;\n\n  if ((mng_info->mng_type == 0 && (image->ping != MagickFalse)) || (\n      (image_info->number_scenes != 0) && (mng_info->scenes_found > (ssize_t)\n      (image_info->first_scene+image_info->number_scenes))))\n    {\n      /* This happens later in non-ping decodes */\n      if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        image->storage_class=DirectClass;\n      image->alpha_trait=\n        (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n         (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Skipping PNG image data for scene %.20g\",(double)\n          mng_info->scenes_found-1);\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage().\");\n\n      return(image);\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading PNG IDAT chunk(s)\");\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (num_passes > 1)\n    pixel_info=AcquireVirtualMemory(image->rows,ping_rowbytes*\n      sizeof(*ping_pixels));\n  else\n    pixel_info=AcquireVirtualMemory(ping_rowbytes,sizeof(*ping_pixels));\n\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Memory allocation failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Converting PNG pixels to pixel packets\");\n  /*\n    Convert PNG pixels to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n\n  if (quantum_info == (QuantumInfo *) NULL)\n     png_error(ping,\"Failed to allocate quantum_info\");\n\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n\n  {\n\n   MagickBooleanType\n     found_transparent_pixel;\n\n  found_transparent_pixel=MagickFalse;\n\n  if (image->storage_class == DirectClass)\n    {\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        image->alpha_trait=\n            (((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n            ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n            (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n            BlendPixelTrait : UndefinedPixelTrait;\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (num_passes > 1)\n            row_offset=ping_rowbytes*y;\n\n          else\n            row_offset=0;\n\n          png_read_row(ping,ping_pixels+row_offset,NULL);\n\n          if (pass < num_passes-1)\n            continue;\n\n          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (q == (Quantum *) NULL)\n            break;\n\n          if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              GrayAlphaQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBAQuantum,ping_pixels+row_offset,exception);\n\n          else if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              IndexQuantum,ping_pixels+row_offset,exception);\n\n          else /* ping_color_type == PNG_COLOR_TYPE_RGB */\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              RGBQuantum,ping_pixels+row_offset,exception);\n\n          if (found_transparent_pixel == MagickFalse)\n            {\n              /* Is there a transparent pixel in the row? */\n              if (y== 0 && logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Looking for cheap transparent pixel\");\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                if ((ping_color_type == PNG_COLOR_TYPE_RGBA ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) &&\n                   (GetPixelAlpha(image,q) != OpaqueAlpha))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                if ((ping_color_type == PNG_COLOR_TYPE_RGB ||\n                    ping_color_type == PNG_COLOR_TYPE_GRAY) &&\n                    (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                    transparent_color.red &&\n                    ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                    transparent_color.green &&\n                    ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                    transparent_color.blue))\n                  {\n                    if (logging != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    ...got one.\");\n                    found_transparent_pixel = MagickTrue;\n                    break;\n                  }\n                q+=GetPixelChannels(image);\n              }\n            }\n\n          if (num_passes == 1)\n            {\n              status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y, image->rows);\n\n              if (status == MagickFalse)\n                break;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n\n        if (num_passes != 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    }\n\n  else /* image->storage_class != DirectClass */\n\n    for (pass=0; pass < num_passes; pass++)\n    {\n      Quantum\n        *quantum_scanline;\n\n      register Quantum\n        *r;\n\n      /*\n        Convert grayscale image to PseudoClass pixel packets.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Converting grayscale pixels to pixel packets\");\n\n      image->alpha_trait=ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n      quantum_scanline=(Quantum *) AcquireQuantumMemory(image->columns,\n        (image->alpha_trait  == BlendPixelTrait?  2 : 1)*\n        sizeof(*quantum_scanline));\n\n      if (quantum_scanline == (Quantum *) NULL)\n        png_error(ping,\"Memory allocation failed\");\n\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        Quantum\n           alpha;\n\n        if (num_passes > 1)\n          row_offset=ping_rowbytes*y;\n\n        else\n          row_offset=0;\n\n        png_read_row(ping,ping_pixels+row_offset,NULL);\n\n        if (pass < num_passes-1)\n          continue;\n\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n\n        p=ping_pixels+row_offset;\n        r=quantum_scanline;\n\n        switch (ping_bit_depth)\n        {\n          case 8:\n          {\n\n            if (ping_color_type == 4)\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                *r++=*p++;\n\n                alpha=ScaleCharToQuantum((unsigned char)*p++);\n\n                SetPixelAlpha(image,alpha,q);\n\n                if (alpha != OpaqueAlpha)\n                  found_transparent_pixel = MagickTrue;\n\n                q+=GetPixelChannels(image);\n              }\n\n            else\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                *r++=*p++;\n\n            break;\n          }\n\n          case 16:\n          {\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n#if (MAGICKCORE_QUANTUM_DEPTH >= 16)\n              unsigned short\n                quantum;\n\n              if (image->colors > 256)\n                quantum=((*p++) << 8);\n\n              else\n                quantum=0;\n\n              quantum|=(*p++);\n              *r=ScaleShortToQuantum(quantum);\n              r++;\n\n              if (ping_color_type == 4)\n                {\n                  if (image->colors > 256)\n                    quantum=((*p++) << 8);\n                  else\n                    quantum=0;\n\n                  quantum|=(*p++);\n\n                  alpha=ScaleShortToQuantum(quantum);\n                  SetPixelAlpha(image,alpha,q);\n\n                  if (alpha != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  q+=GetPixelChannels(image);\n                }\n\n#else /* MAGICKCORE_QUANTUM_DEPTH == 8 */\n              *r++=(*p++);\n              p++; /* strip low byte */\n\n              if (ping_color_type == 4)\n                {\n                  SetPixelAlpha(image,*p++,q);\n\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    found_transparent_pixel = MagickTrue;\n\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n#endif\n            }\n\n            break;\n          }\n\n          default:\n            break;\n        }\n\n        /*\n          Transfer image scanline.\n        */\n        r=quantum_scanline;\n\n        q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelIndex(image,*r++,q);\n          q+=GetPixelChannels(image);\n        }\n\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n\n        if (num_passes == 1)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n\n            if (status == MagickFalse)\n              break;\n          }\n      }\n\n      if (num_passes != 1)\n        {\n          status=SetImageProgress(image,LoadImageTag,pass,num_passes);\n\n          if (status == MagickFalse)\n            break;\n        }\n\n      quantum_scanline=(Quantum *) RelinquishMagickMemory(quantum_scanline);\n    }\n\n    image->alpha_trait=found_transparent_pixel ? BlendPixelTrait :\n      UndefinedPixelTrait;\n\n    if (logging != MagickFalse)\n      {\n        if (found_transparent_pixel != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Found transparent pixel\");\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    No transparent pixel was found\");\n\n            ping_color_type&=0x03;\n          }\n      }\n    }\n\n  quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (image->storage_class == PseudoClass)\n    {\n      PixelTrait\n        alpha_trait;\n\n      alpha_trait=image->alpha_trait;\n      image->alpha_trait=UndefinedPixelTrait;\n      (void) SyncImage(image,exception);\n      image->alpha_trait=alpha_trait;\n    }\n\n  png_read_end(ping,end_info);\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"  image->storage_class=%d\\n\",(int) image->storage_class);\n  }\n\n  if (image_info->number_scenes != 0 && mng_info->scenes_found-1 <\n      (ssize_t) image_info->first_scene && image->delay != 0)\n    {\n      png_destroy_read_struct(&ping,&ping_info,&end_info);\n      pixel_info=RelinquishVirtualMemory(pixel_info);\n      image->colors=2;\n      (void) SetImageBackgroundColor(image,exception);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  exit ReadOnePNGImage() early.\");\n      return(image);\n    }\n\n  if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n    {\n      ClassType\n        storage_class;\n\n      /*\n        Image has a transparent background.\n      */\n      storage_class=image->storage_class;\n      image->alpha_trait=BlendPixelTrait;\n\n/* Balfour fix from imagemagick discourse server, 5 Feb 2010 */\n\n      if (storage_class == PseudoClass)\n        {\n          if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n            {\n              for (x=0; x < ping_num_trans; x++)\n              {\n                 image->colormap[x].alpha_trait=BlendPixelTrait;\n                 image->colormap[x].alpha =\n                   ScaleCharToQuantum((unsigned char)ping_trans_alpha[x]);\n              }\n            }\n\n          else if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n            {\n              for (x=0; x < (int) image->colors; x++)\n              {\n                 if (ScaleQuantumToShort(image->colormap[x].red) ==\n                     transparent_color.alpha)\n                 {\n                    image->colormap[x].alpha_trait=BlendPixelTrait;\n                    image->colormap[x].alpha = (Quantum) TransparentAlpha;\n                 }\n              }\n            }\n          (void) SyncImage(image,exception);\n        }\n\n#if 1 /* Should have already been done above, but glennrp problem P10\n       * needs this.\n       */\n      else\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            image->storage_class=storage_class;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (q == (Quantum *) NULL)\n              break;\n\n\n            /* Caution: on a Q8 build, this does not distinguish between\n             * 16-bit colors that differ only in the low byte\n             */\n            for (x=(ssize_t) image->columns-1; x >= 0; x--)\n            {\n              if (ScaleQuantumToShort(GetPixelRed(image,q)) ==\n                  transparent_color.red &&\n                  ScaleQuantumToShort(GetPixelGreen(image,q)) ==\n                  transparent_color.green &&\n                  ScaleQuantumToShort(GetPixelBlue(image,q)) ==\n                  transparent_color.blue)\n                {\n                  SetPixelAlpha(image,TransparentAlpha,q);\n                }\n\n#if 0 /* I have not found a case where this is needed. */\n              else\n                {\n                  SetPixelAlpha(image,q)=(Quantum) OpaqueAlpha;\n                }\n#endif\n\n              q+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n#endif\n\n      image->storage_class=DirectClass;\n    }\n\n  for (j = 0; j < 2; j++)\n  {\n    if (j == 0)\n      status = png_get_text(ping,ping_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n    else\n      status = png_get_text(ping,end_info,&text,&num_text) != 0 ?\n          MagickTrue : MagickFalse;\n\n    if (status != MagickFalse)\n      for (i=0; i < (ssize_t) num_text; i++)\n      {\n        /* Check for a profile */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Reading PNG text chunk\");\n\n        if (strlen(text[i].key) > 16 &&\n            memcmp(text[i].key, \"Raw profile type \",17) == 0)\n          {\n            const char\n              *value;\n\n            value=GetImageOption(image_info,\"profile:skip\");\n\n            if (IsOptionMember(text[i].key+17,value) == MagickFalse)\n            {\n               (void) Magick_png_read_raw_profile(ping,image,image_info,text,\n                  (int) i,exception);\n               num_raw_profiles++;\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Read raw profile %s\",text[i].key+17);\n            }\n            else\n            {\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Skipping raw profile %s\",text[i].key+17);\n            }\n          }\n\n        else\n          {\n            char\n              *value;\n\n            length=text[i].text_length;\n            value=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n              sizeof(*value));\n            if (value == (char *) NULL)\n              {\n                png_error(ping,\"Memory allocation failed\");\n                break;\n              }\n            *value='\\0';\n            (void) ConcatenateMagickString(value,text[i].text,length+2);\n\n            /* Don't save \"density\" or \"units\" property if we have a pHYs\n             * chunk\n             */\n            if (!png_get_valid(ping,ping_info,PNG_INFO_pHYs) ||\n                (LocaleCompare(text[i].key,\"density\") != 0 &&\n                LocaleCompare(text[i].key,\"units\") != 0))\n               (void) SetImageProperty(image,text[i].key,value,exception);\n\n            if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      length: %lu\\n\"\n                \"      Keyword: %s\",\n                (unsigned long) length,\n                text[i].key);\n            }\n\n            value=DestroyString(value);\n          }\n      }\n    num_text_total += num_text;\n  }\n\n#ifdef MNG_OBJECT_BUFFERS\n  /*\n    Store the object if necessary.\n  */\n  if (object_id && !mng_info->frozen[object_id])\n    {\n      if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n        {\n          /*\n            create a new object buffer.\n          */\n          mng_info->ob[object_id]=(MngBuffer *)\n            AcquireMagickMemory(sizeof(MngBuffer));\n\n          if (mng_info->ob[object_id] != (MngBuffer *) NULL)\n            {\n              mng_info->ob[object_id]->image=(Image *) NULL;\n              mng_info->ob[object_id]->reference_count=1;\n            }\n        }\n\n      if ((mng_info->ob[object_id] == (MngBuffer *) NULL) ||\n          mng_info->ob[object_id]->frozen)\n        {\n          if (mng_info->ob[object_id] == (MngBuffer *) NULL)\n             png_error(ping,\"Memory allocation failed\");\n\n          if (mng_info->ob[object_id]->frozen)\n            png_error(ping,\"Cannot overwrite frozen MNG object buffer\");\n        }\n\n      else\n        {\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image=DestroyImage\n                (mng_info->ob[object_id]->image);\n\n          mng_info->ob[object_id]->image=CloneImage(image,0,0,MagickTrue,\n            exception);\n\n          if (mng_info->ob[object_id]->image != (Image *) NULL)\n            mng_info->ob[object_id]->image->file=(FILE *) NULL;\n\n          else\n            png_error(ping, \"Cloning image for object buffer failed\");\n\n          if (ping_width > 250000L || ping_height > 250000L)\n             png_error(ping,\"PNG Image dimensions are too large.\");\n\n          mng_info->ob[object_id]->width=ping_width;\n          mng_info->ob[object_id]->height=ping_height;\n          mng_info->ob[object_id]->color_type=ping_color_type;\n          mng_info->ob[object_id]->sample_depth=ping_bit_depth;\n          mng_info->ob[object_id]->interlace_method=ping_interlace_method;\n          mng_info->ob[object_id]->compression_method=\n             ping_compression_method;\n          mng_info->ob[object_id]->filter_method=ping_filter_method;\n\n          if (png_get_valid(ping,ping_info,PNG_INFO_PLTE))\n            {\n              png_colorp\n                plte;\n\n              /*\n                Copy the PLTE to the object buffer.\n              */\n              png_get_PLTE(ping,ping_info,&plte,&number_colors);\n              mng_info->ob[object_id]->plte_length=number_colors;\n\n              for (i=0; i < number_colors; i++)\n              {\n                mng_info->ob[object_id]->plte[i]=plte[i];\n              }\n            }\n\n          else\n              mng_info->ob[object_id]->plte_length=0;\n        }\n    }\n#endif\n\n   /* Set image->alpha_trait to MagickTrue if the input colortype supports\n    * alpha or if a valid tRNS chunk is present, no matter whether there\n    * is actual transparency present.\n    */\n    image->alpha_trait=(((int) ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA) ||\n        ((int) ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||\n        (png_get_valid(ping,ping_info,PNG_INFO_tRNS))) ?\n        BlendPixelTrait : UndefinedPixelTrait;\n\n#if 0  /* I'm not sure what's wrong here but it does not work. */\n    if (image->alpha_trait != UndefinedPixelTrait)\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        (void) SetImageType(image,GrayscaleAlphaType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteAlphaType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorAlphaType,exception);\n    }\n\n    else\n    {\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        (void) SetImageType(image,GrayscaleType,exception);\n\n      else if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        (void) SetImageType(image,PaletteType,exception);\n\n      else\n        (void) SetImageType(image,TrueColorType,exception);\n    }\n#endif\n\n   /* Set more properties for identify to retrieve */\n   {\n     char\n       msg[MagickPathExtent];\n\n     if (num_text_total != 0)\n       {\n         /* libpng doesn't tell us whether they were tEXt, zTXt, or iTXt */\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d tEXt/zTXt/iTXt chunks were found\", num_text_total);\n         (void) SetImageProperty(image,\"png:text\",msg,\n                exception);\n       }\n\n     if (num_raw_profiles != 0)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"%d were found\", num_raw_profiles);\n         (void) SetImageProperty(image,\"png:text-encoded profiles\",msg,\n                exception);\n       }\n\n     /* cHRM chunk: */\n     if (ping_found_cHRM != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Chromaticity, above)\");\n         (void) SetImageProperty(image,\"png:cHRM\",msg,\n                exception);\n       }\n\n     /* bKGD chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_bKGD))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n            \"chunk was found (see Background color, above)\");\n         (void) SetImageProperty(image,\"png:bKGD\",msg,\n                exception);\n       }\n\n     (void) FormatLocaleString(msg,MagickPathExtent,\"%s\",\n        \"chunk was found\");\n\n#if defined(PNG_iCCP_SUPPORTED)\n     /* iCCP chunk: */\n     if (ping_found_iCCP != MagickFalse)\n        (void) SetImageProperty(image,\"png:iCCP\",msg,\n                exception);\n#endif\n\n     if (png_get_valid(ping,ping_info,PNG_INFO_tRNS))\n        (void) SetImageProperty(image,\"png:tRNS\",msg,\n                exception);\n\n#if defined(PNG_sRGB_SUPPORTED)\n     /* sRGB chunk: */\n     if (ping_found_sRGB != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"intent=%d (%s)\",\n            (int) intent,\n            Magick_RenderingIntentString_from_PNG_RenderingIntent(intent));\n         (void) SetImageProperty(image,\"png:sRGB\",msg,\n                 exception);\n       }\n#endif\n\n     /* gAMA chunk: */\n     if (ping_found_gAMA != MagickFalse)\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"gamma=%.8g (See Gamma, above)\",\n            file_gamma);\n         (void) SetImageProperty(image,\"png:gAMA\",msg,\n                exception);\n       }\n\n#if defined(PNG_pHYs_SUPPORTED)\n     /* pHYs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_pHYs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_res=%.10g, y_res=%.10g, units=%d\",\n            (double) x_resolution,(double) y_resolution, unit_type);\n         (void) SetImageProperty(image,\"png:pHYs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_oFFs_SUPPORTED)\n     /* oFFs chunk: */\n     if (png_get_valid(ping,ping_info,PNG_INFO_oFFs))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"x_off=%.20g, y_off=%.20g\",\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:oFFs\",msg,\n                exception);\n       }\n#endif\n\n#if defined(PNG_tIME_SUPPORTED)\n     read_tIME_chunk(image,ping,end_info,exception);\n#endif\n\n     /* caNv chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows) ||\n         (image->page.x != 0 || image->page.y != 0))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g, x_offset=%.20g, y_offset=%.20g\",\n            (double) image->page.width,(double) image->page.height,\n            (double) image->page.x,(double) image->page.y);\n         (void) SetImageProperty(image,\"png:caNv\",msg,\n                exception);\n       }\n\n     /* vpAg chunk: */\n     if ((image->page.width != 0 && image->page.width != image->columns) ||\n         (image->page.height != 0 && image->page.height != image->rows))\n       {\n         (void) FormatLocaleString(msg,MagickPathExtent,\n            \"width=%.20g, height=%.20g\",\n            (double) image->page.width,(double) image->page.height);\n         (void) SetImageProperty(image,\"png:vpAg\",msg,\n                exception);\n       }\n   }\n\n  /*\n    Relinquish resources.\n  */\n  png_destroy_read_struct(&ping,&ping_info,&end_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n  /* }  for navigation to beginning of SETJMP-protected block, revert to\n   *    Throwing an Exception when an error occurs.\n   */\n\n  return(image);\n\n/* end of reading one PNG image */\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int parse_size_uint(const char *size, guint *bytes)\n{\n\tconst char *desc;\n\tguint number, multiplier, limit;\n\tint len;\n\n\t*bytes = 0;\n\n\t/* max. return value is about 1.6 years */\n\tnumber = 0;\n\twhile (*size != '\\0') {\n\t\tif (i_isdigit(*size)) {\n\t\t\tchar *endptr;\n\t\t\tif (!parse_uint(size, &endptr, 10, &number)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tsize = endptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\n\t\t/* get description */\n\t\tfor (len = 0, desc = size; i_isalpha(*size); size++)\n\t\t\tlen++;\n\n\t\tif (len == 0) {\n\t\t\tif (number == 0) {\n\t\t\t\t/* \"0\" - allow it */\n\t\t\t\treturn TRUE;\n\t\t\t}\n\n\t\t\t*bytes += number*1024; /* assume kilobytes */\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tmultiplier = 0;\n\t\tlimit = 0;\n\n\t\tif (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 30;\n\t\t\tlimit = 2U << 0;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 20;\n\t\t\tlimit = 2U << 10;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 10;\n\t\t\tlimit = 2U << 20;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) {\n\t\t\tmultiplier = 1;\n\t\t\tlimit = 2U << 30;\n\t\t}\n\n\t\tif (limit && number > limit) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t*bytes += number * multiplier;\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\t}\n\n\treturn TRUE;\n}\n",
        "post_patch": "static int parse_size_uint(const char *size, guint *bytes)\n{\n\tconst char *desc;\n\tguint number, multiplier, limit;\n\tint len;\n\n\t*bytes = 0;\n\n\t/* max. return value is about 1.6 years */\n\tnumber = 0;\n\twhile (*size != '\\0') {\n\t\tif (i_isdigit(*size)) {\n\t\t\tchar *endptr;\n\t\t\tif (!parse_uint(size, &endptr, 10, &number)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tsize = endptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\n\t\t/* get description */\n\t\tfor (len = 0, desc = size; i_isalpha(*size); size++)\n\t\t\tlen++;\n\n\t\tif (len == 0) {\n\t\t\tif (number == 0) {\n\t\t\t\t/* \"0\" - allow it */\n\t\t\t\treturn TRUE;\n\t\t\t}\n\n\t\t\t*bytes += number*1024; /* assume kilobytes */\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tmultiplier = 0;\n\t\tlimit = 0;\n\n\t\tif (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 30;\n\t\t\tlimit = 2U << 0;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 20;\n\t\t\tlimit = 2U << 10;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 10;\n\t\t\tlimit = 2U << 20;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) {\n\t\t\tmultiplier = 1;\n\t\t\tlimit = 2U << 30;\n\t\t}\n\n\t\tif (limit && number > limit) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t*bytes += number * multiplier;\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\t}\n\n\treturn TRUE;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "    OVS_REQUIRES(ofproto_mutex)\n{\n     const struct rule_actions *actions = rule_get_actions(rule);\n \n     /* A rule may not be reinserted. */\n    ovs_assert(rule->state == RULE_INITIALIZED);\n \n     if (rule->hard_timeout || rule->idle_timeout) {\n         ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n\n    rule->state = RULE_INSERTED;\n}\n",
        "post_patch": "    OVS_REQUIRES(ofproto_mutex)\n{\n     const struct rule_actions *actions = rule_get_actions(rule);\n \n     /* A rule may not be reinserted. */\n    ovs_assert(rule->state != RULE_INSERTED);\n \n     if (rule->hard_timeout || rule->idle_timeout) {\n         ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n\n    rule->state = RULE_INSERTED;\n}\n",
        "label": 1
    },
    {
        "pre_patch": " CoordinatorImpl::CoordinatorImpl(service_manager::Connector* connector)\n     : next_dump_id_(0),\n      client_process_timeout_(base::TimeDelta::FromSeconds(15)) {\n   process_map_ = std::make_unique<ProcessMap>(connector);\n   DCHECK(!g_coordinator_impl);\n   g_coordinator_impl = this;\n  base::trace_event::MemoryDumpManager::GetInstance()->set_tracing_process_id(\n      mojom::kServiceTracingProcessId);\n\n  tracing_observer_ = std::make_unique<TracingObserver>(\n      base::trace_event::TraceLog::GetInstance(), nullptr);\n}\n",
        "post_patch": " CoordinatorImpl::CoordinatorImpl(service_manager::Connector* connector)\n     : next_dump_id_(0),\n      client_process_timeout_(base::TimeDelta::FromSeconds(15)),\n      weak_ptr_factory_(this) {\n   process_map_ = std::make_unique<ProcessMap>(connector);\n   DCHECK(!g_coordinator_impl);\n   g_coordinator_impl = this;\n  base::trace_event::MemoryDumpManager::GetInstance()->set_tracing_process_id(\n      mojom::kServiceTracingProcessId);\n\n  tracing_observer_ = std::make_unique<TracingObserver>(\n      base::trace_event::TraceLog::GetInstance(), nullptr);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void AutofillExternalDelegate::OnSuggestionsReturned(\n    int query_id,\n    const std::vector<Suggestion>& input_suggestions,\n    bool autoselect_first_suggestion,\n    bool is_all_server_suggestions) {\n  if (query_id != query_id_)\n    return;\n\n  std::vector<Suggestion> suggestions(input_suggestions);\n\n   PossiblyRemoveAutofillWarnings(&suggestions);\n \n#if !defined(OS_ANDROID)\n  if (!suggestions.empty() && !features::ShouldUseNativeViews()) {\n    suggestions.push_back(Suggestion());\n    suggestions.back().frontend_id = POPUP_ITEM_ID_SEPARATOR;\n  }\n#endif\n   if (should_show_scan_credit_card_) {\n     Suggestion scan_credit_card(\n         l10n_util::GetStringUTF16(IDS_AUTOFILL_SCAN_CREDIT_CARD));\n    scan_credit_card.frontend_id = POPUP_ITEM_ID_SCAN_CREDIT_CARD;\n    scan_credit_card.icon = base::ASCIIToUTF16(\"scanCreditCardIcon\");\n    suggestions.push_back(scan_credit_card);\n  }\n\n  has_autofill_suggestions_ = false;\n  for (size_t i = 0; i < suggestions.size(); ++i) {\n    if (suggestions[i].frontend_id > 0) {\n      has_autofill_suggestions_ = true;\n      break;\n    }\n  }\n\n  if (should_show_cards_from_account_option_) {\n    suggestions.emplace_back(\n        l10n_util::GetStringUTF16(IDS_AUTOFILL_SHOW_ACCOUNT_CARDS));\n    suggestions.back().frontend_id = POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS;\n    suggestions.back().icon = base::ASCIIToUTF16(\"google\");\n  }\n\n  if (has_autofill_suggestions_)\n    ApplyAutofillOptions(&suggestions, is_all_server_suggestions);\n\n   if (suggestions.empty() && should_show_cc_signin_promo_) {\n#if !defined(OS_ANDROID)\n    if (has_autofill_suggestions_) {\n      suggestions.push_back(Suggestion());\n      suggestions.back().frontend_id = POPUP_ITEM_ID_SEPARATOR;\n    }\n#endif\n     Suggestion signin_promo_suggestion(\n         l10n_util::GetStringUTF16(IDS_AUTOFILL_CREDIT_CARD_SIGNIN_PROMO));\n     signin_promo_suggestion.frontend_id =\n        POPUP_ITEM_ID_CREDIT_CARD_SIGNIN_PROMO;\n    suggestions.push_back(signin_promo_suggestion);\n    signin_metrics::RecordSigninImpressionUserActionForAccessPoint(\n         signin_metrics::AccessPoint::ACCESS_POINT_AUTOFILL_DROPDOWN);\n   }\n \n#if !defined(OS_ANDROID)\n  if (!suggestions.empty() &&\n      suggestions.back().frontend_id == POPUP_ITEM_ID_SEPARATOR) {\n    suggestions.pop_back();\n  }\n#endif\n  InsertDataListValues(&suggestions);\n\n  if (suggestions.empty()) {\n    manager_->client()->HideAutofillPopup();\n    return;\n  }\n\n  if (query_field_.is_focusable) {\n    manager_->client()->ShowAutofillPopup(\n        element_bounds_, query_field_.text_direction, suggestions,\n        autoselect_first_suggestion, GetWeakPtr());\n  }\n}\n",
        "post_patch": "void AutofillExternalDelegate::OnSuggestionsReturned(\n    int query_id,\n    const std::vector<Suggestion>& input_suggestions,\n    bool autoselect_first_suggestion,\n    bool is_all_server_suggestions) {\n  if (query_id != query_id_)\n    return;\n\n  std::vector<Suggestion> suggestions(input_suggestions);\n\n   PossiblyRemoveAutofillWarnings(&suggestions);\n \n   if (should_show_scan_credit_card_) {\n     Suggestion scan_credit_card(\n         l10n_util::GetStringUTF16(IDS_AUTOFILL_SCAN_CREDIT_CARD));\n    scan_credit_card.frontend_id = POPUP_ITEM_ID_SCAN_CREDIT_CARD;\n    scan_credit_card.icon = base::ASCIIToUTF16(\"scanCreditCardIcon\");\n    suggestions.push_back(scan_credit_card);\n  }\n\n  has_autofill_suggestions_ = false;\n  for (size_t i = 0; i < suggestions.size(); ++i) {\n    if (suggestions[i].frontend_id > 0) {\n      has_autofill_suggestions_ = true;\n      break;\n    }\n  }\n\n  if (should_show_cards_from_account_option_) {\n    suggestions.emplace_back(\n        l10n_util::GetStringUTF16(IDS_AUTOFILL_SHOW_ACCOUNT_CARDS));\n    suggestions.back().frontend_id = POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS;\n    suggestions.back().icon = base::ASCIIToUTF16(\"google\");\n  }\n\n  if (has_autofill_suggestions_)\n    ApplyAutofillOptions(&suggestions, is_all_server_suggestions);\n\n   if (suggestions.empty() && should_show_cc_signin_promo_) {\n     Suggestion signin_promo_suggestion(\n         l10n_util::GetStringUTF16(IDS_AUTOFILL_CREDIT_CARD_SIGNIN_PROMO));\n     signin_promo_suggestion.frontend_id =\n        POPUP_ITEM_ID_CREDIT_CARD_SIGNIN_PROMO;\n    suggestions.push_back(signin_promo_suggestion);\n    signin_metrics::RecordSigninImpressionUserActionForAccessPoint(\n         signin_metrics::AccessPoint::ACCESS_POINT_AUTOFILL_DROPDOWN);\n   }\n \n  InsertDataListValues(&suggestions);\n\n  if (suggestions.empty()) {\n    manager_->client()->HideAutofillPopup();\n    return;\n  }\n\n  if (query_field_.is_focusable) {\n    manager_->client()->ShowAutofillPopup(\n        element_bounds_, query_field_.text_direction, suggestions,\n        autoselect_first_suggestion, GetWeakPtr());\n  }\n}\n",
        "label": 1
    },
    {
        "pre_patch": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n\t\t\t\t\t/* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n",
        "post_patch": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n\t\t\t\t\t/* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);\n                                       tree = cmap->tree;\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n",
        "label": 1
    },
    {
        "pre_patch": "gfx::Rect AutofillPopupBaseView::CalculateClippingBounds() const {\n  if (parent_widget_)\n    return parent_widget_->GetClientAreaBoundsInScreen();\n  return PopupViewCommon().GetWindowBounds(delegate_->container_view());\n}\n",
        "post_patch": "gfx::Rect AutofillPopupBaseView::CalculateClippingBounds() const {\n",
        "label": 1
    },
    {
        "pre_patch": "__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tbool\t\t\tdirect,\n\tbool\t\t\tdax_fault)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\tbool\t\t\tis_cow = false;\n\tbool\t\t\tneed_alloc = false;\n\n\tBUG_ON(create && !direct);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.\n\t */\n\tlockmode = xfs_ilock_data_map_shared(ip);\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\tif (create && direct && xfs_is_reflink_inode(ip))\n\t\tis_cow = xfs_reflink_find_cow_mapping(ip, offset, &imap,\n\t\t\t\t\t&need_alloc);\n\tif (!is_cow) {\n\t\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\t\t/*\n\t\t * Truncate an overwrite extent if there's a pending CoW\n\t\t * reservation before the end of this extent.  This\n\t\t * forces us to come back to get_blocks to take care of\n\t\t * the CoW.\n\t\t */\n\t\tif (create && direct && nimaps &&\n\t\t    imap.br_startblock != HOLESTARTBLOCK &&\n\t\t    imap.br_startblock != DELAYSTARTBLOCK &&\n\t\t    !ISUNWRITTEN(&imap))\n\t\t\txfs_reflink_trim_irec_to_next_cow(ip, offset_fsb,\n\t\t\t\t\t&imap);\n\t}\n\tASSERT(!need_alloc);\n \tif (error)\n \t\tgoto out_unlock;\n \n \t/* for DAX, we convert unwritten extents directly */\n \tif (create &&\n \t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK) ||\n\t     (IS_DAX(inode) && ISUNWRITTEN(&imap)))) {\n\t\t/*\n\t\t * xfs_iomap_write_direct() expects the shared lock. It\n\t\t * is unlocked on return.\n\t\t */\n\t\tif (lockmode == XFS_ILOCK_EXCL)\n\t\t\txfs_ilock_demote(ip, lockmode);\n\n\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t       &imap, nimaps);\n\t\tif (error)\n\t\t\treturn error;\n\t\tnew = 1;\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size,\n\t\t\t\tISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN\n\t\t\t\t\t\t   : XFS_IO_DELALLOC, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size,\n\t\t\t\tISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN\n\t\t\t\t\t\t   : XFS_IO_OVERWRITE, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (IS_DAX(inode) && create) {\n\t\tASSERT(!ISUNWRITTEN(&imap));\n\t\t/* zeroing is not needed at a higher layer */\n\t\tnew = 0;\n\t}\n\n\t/* trim mapping down to size requested */\n\txfs_map_trim_size(inode, iblock, bh_result, &imap, offset, size);\n\n\t/*\n\t * For unwritten extents do not report a disk address in the buffered\n\t * read case (treat as if we're reading into a hole).\n\t */\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK &&\n\t    (create || !ISUNWRITTEN(&imap))) {\n\t\tif (create && direct && !is_cow) {\n\t\t\terror = xfs_bounce_unaligned_dio_write(ip, offset_fsb,\n\t\t\t\t\t&imap);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (ISUNWRITTEN(&imap))\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t/* direct IO needs special help */\n\t\tif (create) {\n\t\t\tif (dax_fault)\n\t\t\t\tASSERT(!ISUNWRITTEN(&imap));\n\t\t\telse\n\t\t\t\txfs_map_direct(inode, bh_result, &imap, offset,\n\t\t\t\t\t\tis_cow);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n \t     (new || ISUNWRITTEN(&imap))))\n \t\tset_buffer_new(bh_result);\n \n\tBUG_ON(direct && imap.br_startblock == DELAYSTARTBLOCK);\n \treturn 0;\n \n out_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}\n",
        "post_patch": "__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tbool\t\t\tdirect,\n\tbool\t\t\tdax_fault)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\tbool\t\t\tis_cow = false;\n\tbool\t\t\tneed_alloc = false;\n\n\tBUG_ON(create && !direct);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.\n\t */\n\tlockmode = xfs_ilock_data_map_shared(ip);\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\tif (create && direct && xfs_is_reflink_inode(ip))\n\t\tis_cow = xfs_reflink_find_cow_mapping(ip, offset, &imap,\n\t\t\t\t\t&need_alloc);\n\tif (!is_cow) {\n\t\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\t\t/*\n\t\t * Truncate an overwrite extent if there's a pending CoW\n\t\t * reservation before the end of this extent.  This\n\t\t * forces us to come back to get_blocks to take care of\n\t\t * the CoW.\n\t\t */\n\t\tif (create && direct && nimaps &&\n\t\t    imap.br_startblock != HOLESTARTBLOCK &&\n\t\t    imap.br_startblock != DELAYSTARTBLOCK &&\n\t\t    !ISUNWRITTEN(&imap))\n\t\t\txfs_reflink_trim_irec_to_next_cow(ip, offset_fsb,\n\t\t\t\t\t&imap);\n\t}\n\tASSERT(!need_alloc);\n \tif (error)\n \t\tgoto out_unlock;\n \n\t/*\n\t * The only time we can ever safely find delalloc blocks on direct I/O\n\t * is a dio write to post-eof speculative preallocation. All other\n\t * scenarios are indicative of a problem or misuse (such as mixing\n\t * direct and mapped I/O).\n\t *\n\t * The file may be unmapped by the time we get here so we cannot\n\t * reliably fail the I/O based on mapping. Instead, fail the I/O if this\n\t * is a read or a write within eof. Otherwise, carry on but warn as a\n\t * precuation if the file happens to be mapped.\n\t */\n\tif (direct && imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tif (!create || offset < i_size_read(VFS_I(ip))) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tWARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));\n\t}\n\n \t/* for DAX, we convert unwritten extents directly */\n \tif (create &&\n \t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK) ||\n\t     (IS_DAX(inode) && ISUNWRITTEN(&imap)))) {\n\t\t/*\n\t\t * xfs_iomap_write_direct() expects the shared lock. It\n\t\t * is unlocked on return.\n\t\t */\n\t\tif (lockmode == XFS_ILOCK_EXCL)\n\t\t\txfs_ilock_demote(ip, lockmode);\n\n\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t       &imap, nimaps);\n\t\tif (error)\n\t\t\treturn error;\n\t\tnew = 1;\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size,\n\t\t\t\tISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN\n\t\t\t\t\t\t   : XFS_IO_DELALLOC, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size,\n\t\t\t\tISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN\n\t\t\t\t\t\t   : XFS_IO_OVERWRITE, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (IS_DAX(inode) && create) {\n\t\tASSERT(!ISUNWRITTEN(&imap));\n\t\t/* zeroing is not needed at a higher layer */\n\t\tnew = 0;\n\t}\n\n\t/* trim mapping down to size requested */\n\txfs_map_trim_size(inode, iblock, bh_result, &imap, offset, size);\n\n\t/*\n\t * For unwritten extents do not report a disk address in the buffered\n\t * read case (treat as if we're reading into a hole).\n\t */\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK &&\n\t    (create || !ISUNWRITTEN(&imap))) {\n\t\tif (create && direct && !is_cow) {\n\t\t\terror = xfs_bounce_unaligned_dio_write(ip, offset_fsb,\n\t\t\t\t\t&imap);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (ISUNWRITTEN(&imap))\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t/* direct IO needs special help */\n\t\tif (create) {\n\t\t\tif (dax_fault)\n\t\t\t\tASSERT(!ISUNWRITTEN(&imap));\n\t\t\telse\n\t\t\t\txfs_map_direct(inode, bh_result, &imap, offset,\n\t\t\t\t\t\tis_cow);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n \t     (new || ISUNWRITTEN(&imap))))\n \t\tset_buffer_new(bh_result);\n \n \treturn 0;\n \n out_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n \n \tif (im == NULL) {\n\t\treturn;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n\t\treturn;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\"gd-webp encoding failed\");\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n }\n",
        "post_patch": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n/* returns 0 on success, 1 on failure */\nstatic int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n    int ret = 0;\n \n \tif (im == NULL) {\n\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Palette image not supported by webp\");\n\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\"gd-webp encoding failed\");\n        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n\n    return ret;\n}\n\n\n/*\n  Function: gdImageWebpCtx\n\n    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n    for more details.\n\n  Parameters:\n\n    im      - The image to write.\n    outfile - The output sink.\n    quality - Image quality.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageWebpCtx(im, outfile, quality);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static void vga_invalidate_display(void *opaque)\n{\n    VGACommonState *s = opaque;\n\n    s->last_width = -1;\n    s->last_height = -1;\n}\n",
        "post_patch": "static void vga_invalidate_display(void *opaque)\n{\n    VGACommonState *s = opaque;\n\n    s->last_width = -1;\n    s->last_height = -1;\n}\n",
        "label": 0
    },
    {
        "pre_patch": " void KioskNextHomeInterfaceBrokerImpl::GetAppController(\n     mojom::AppControllerRequest request) {\n  app_controller_->BindRequest(std::move(request));\n }\n",
        "post_patch": " void KioskNextHomeInterfaceBrokerImpl::GetAppController(\n     mojom::AppControllerRequest request) {\n  AppControllerService::Get(context_)->BindRequest(std::move(request));\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n \t\t       sta->sta.addr, sta->sta.aid, ac);\n \t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n \t\t\tpurge_old_ps_buffers(tx->local);\n \t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n \t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n \t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n \t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n \t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n \t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n \n \t\tif (!timer_pending(&local->sta_cleanup))\n \t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t/*\n\t\t * We queued up some frames, so the TIM bit might\n\t\t * need to be set, recalculate it.\n\t\t */\n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n",
        "post_patch": "ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n \t\t       sta->sta.addr, sta->sta.aid, ac);\n \t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n \t\t\tpurge_old_ps_buffers(tx->local);\n\n\t\t/* sync with ieee80211_sta_ps_deliver_wakeup */\n\t\tspin_lock(&sta->ps_lock);\n\t\t/*\n\t\t * STA woke up the meantime and all the frames on ps_tx_buf have\n\t\t * been queued to pending queue. No reordering can happen, go\n\t\t * ahead and Tx the packet.\n\t\t */\n\t\tif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {\n\t\t\tspin_unlock(&sta->ps_lock);\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n \t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n \t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n \t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n \t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n \t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n \t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n\t\tspin_unlock(&sta->ps_lock);\n \n \t\tif (!timer_pending(&local->sta_cleanup))\n \t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t/*\n\t\t * We queued up some frames, so the TIM bit might\n\t\t * need to be set, recalculate it.\n\t\t */\n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_try_tree_read_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n \t */\n \tif (!p->leave_spinning)\n \t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n \t\tbtrfs_release_path(p);\n \treturn ret;\n }\n",
        "post_patch": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_try_tree_read_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n \t */\n \tif (!p->leave_spinning)\n \t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n \t\tbtrfs_release_path(p);\n \treturn ret;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n \tregister u_int i, l;\n \tregister const u_char *rp = NULL;\n \tregister int compress = 0;\n\tint chars_processed;\n \tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n \n \tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\treturn(NULL);\n \tif (!ND_TTEST2(*cp, 1))\n \t\treturn(NULL);\n\tchars_processed = 1;\n \tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n \t\tcompress = 0;\n \t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n \t\t\t\t}\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n \t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\t\treturn(NULL);\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n \t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n \t\t\t}\n \n \t\t\tcp += l;\n\t\t\tchars_processed += l;\n \t\t\tND_PRINT((ndo, \".\"));\n \t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\treturn(NULL);\n \t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\treturn(NULL);\n \t\t\ti = *cp++;\n\t\t\tchars_processed++;\n \t\t\tif (!compress)\n \t\t\t\trp += l + 1;\n \t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}\n",
        "post_patch": "ns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n \tregister u_int i, l;\n \tregister const u_char *rp = NULL;\n \tregister int compress = 0;\n \tint elt;\n\tu_int offset, max_offset;\n \n \tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\treturn(NULL);\n \tif (!ND_TTEST2(*cp, 1))\n \t\treturn(NULL);\n\tmax_offset = (u_int)(cp - bp);\n \tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n \t\tcompress = 0;\n \t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n \t\t\t\t}\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n\t\t\t\t/*\n\t\t\t\t * This must move backwards in the packet.\n\t\t\t\t * No RFC explicitly says that, but BIND's\n\t\t\t\t * name decompression code requires it,\n\t\t\t\t * as a way of preventing infinite loops\n\t\t\t\t * and other bad behavior, and it's probably\n\t\t\t\t * what was intended (compress by pointing\n\t\t\t\t * to domain name suffixes already seen in\n\t\t\t\t * the packet).\n\t\t\t\t */\n\t\t\t\tif (offset >= max_offset) {\n\t\t\t\t\tND_PRINT((ndo, \"<BAD PTR>\"));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmax_offset = offset;\n\t\t\t\tcp = bp + offset;\n \t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\t\treturn(NULL);\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n \t\t\t\ti = *cp++;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n \t\t\t}\n \n \t\t\tcp += l;\n \t\t\tND_PRINT((ndo, \".\"));\n \t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\treturn(NULL);\n \t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\treturn(NULL);\n \t\t\ti = *cp++;\n \t\t\tif (!compress)\n \t\t\t\trp += l + 1;\n \t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n \tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n \n \tif (q->mq_ops) {\n \t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n \t\tflush_rq->tag = -1;\n \t}\n \n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\n\t/* account completion of the flush request */\n\tfq->flush_running_idx ^= 1;\n\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\n\t/* and push the waiting requests to the next stage */\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\n\t/*\n\t * Kick the queue to avoid stall for two cases:\n\t * 1. Moving a request silently to empty queue_head may stall the\n\t * queue.\n\t * 2. When flush request is running in non-queueable queue, the\n\t * queue is hold. Restart the queue after flush request is finished\n\t * to avoid stall.\n\t * This function is called from request completion path and calling\n\t * directly into request_fn may confuse the driver.  Always use\n\t * kblockd.\n\t */\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}\n",
        "post_patch": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n \tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n \n \tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n\t\t/* release the tag's ownership to the req cloned from */\n \t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n \t\tflush_rq->tag = -1;\n \t}\n \n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\n\t/* account completion of the flush request */\n\tfq->flush_running_idx ^= 1;\n\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\n\t/* and push the waiting requests to the next stage */\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\n\t/*\n\t * Kick the queue to avoid stall for two cases:\n\t * 1. Moving a request silently to empty queue_head may stall the\n\t * queue.\n\t * 2. When flush request is running in non-queueable queue, the\n\t * queue is hold. Restart the queue after flush request is finished\n\t * to avoid stall.\n\t * This function is called from request completion path and calling\n\t * directly into request_fn may confuse the driver.  Always use\n\t * kblockd.\n\t */\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}\n",
        "post_patch": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n",
        "label": 1
    },
    {
        "pre_patch": "int mailimf_unstrict_char_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char token)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n",
        "post_patch": "int mailimf_unstrict_char_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, char token)\n{\n  size_t cur_token;\n  int r;\n\n  cur_token = * indx;\n\n  r = mailimf_cfws_parse(message, length, &cur_token);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE))\n    return r;\n\n  r = mailimf_char_parse(message, length, &cur_token, token);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n  \n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n \tconst unsigned char *p;\n \tphp_unserialize_data_t var_hash;\n \tzval *options = NULL, *classes = NULL;\n \tHashTable *class_hash = NULL;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n \t\t}\n \t}\n \n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\tif (class_hash) {\n \t\t\tzend_hash_destroy(class_hash);\n \t\t\tFREE_HASHTABLE(class_hash);\n \t\t}\n\t\tzval_ptr_dtor(return_value);\n \t\tif (!EG(exception)) {\n \t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n \t\t\t\t(zend_long)((char*)p - buf), buf_len);\n \t\t}\n \t\tRETURN_FALSE;\n \t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n \n \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n",
        "post_patch": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n \tconst unsigned char *p;\n \tphp_unserialize_data_t var_hash;\n \tzval *options = NULL, *classes = NULL;\n\tzval *retval;\n \tHashTable *class_hash = NULL;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n \t\t}\n \t}\n \n\tretval = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\tif (class_hash) {\n \t\t\tzend_hash_destroy(class_hash);\n \t\t\tFREE_HASHTABLE(class_hash);\n \t\t}\n \t\tif (!EG(exception)) {\n \t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n \t\t\t\t(zend_long)((char*)p - buf), buf_len);\n \t\t}\n \t\tRETURN_FALSE;\n \t}\n\n\tZVAL_COPY(return_value, retval);\n \n \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n",
        "label": 1
    },
    {
        "pre_patch": " bool VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::OutputPicture(\n     const scoped_refptr<VP8Picture>& pic) {\n   scoped_refptr<VaapiDecodeSurface> dec_surface =\n       VP8PictureToVaapiDecodeSurface(pic);\n   dec_surface->set_visible_rect(pic->visible_rect);\n  vaapi_dec_->SurfaceReady(dec_surface);\n  return true;\n}\n",
        "post_patch": " bool VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::OutputPicture(\n     const scoped_refptr<VP8Picture>& pic) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   scoped_refptr<VaapiDecodeSurface> dec_surface =\n       VP8PictureToVaapiDecodeSurface(pic);\n   dec_surface->set_visible_rect(pic->visible_rect);\n  vaapi_dec_->SurfaceReady(dec_surface);\n  return true;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int hns_enable_serdes_lb(struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tstruct hnae_ae_ops *ops = h->dev->ops;\n\tint speed, duplex;\n\tint ret;\n\n\tret = ops->set_loopback(h, MAC_INTERNALLOOP_SERDES, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ops->start ? ops->start(h) : 0;\n\tif (ret)\n\t\treturn ret;\n\n\t/* link adjust duplex*/\n\tif (h->phy_if != PHY_INTERFACE_MODE_XGMII)\n\t\tspeed = 1000;\n\telse\n\t\tspeed = 10000;\n\tduplex = 1;\n\n\tops->adjust_link(h, speed, duplex);\n\n\t/* wait h/w ready */\n\tmdelay(300);\n\n\treturn 0;\n}\n",
        "post_patch": "static int hns_enable_serdes_lb(struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae_handle *h = priv->ae_handle;\n\tstruct hnae_ae_ops *ops = h->dev->ops;\n\tint speed, duplex;\n\tint ret;\n\n\tret = ops->set_loopback(h, MAC_INTERNALLOOP_SERDES, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ops->start ? ops->start(h) : 0;\n\tif (ret)\n\t\treturn ret;\n\n\t/* link adjust duplex*/\n\tif (h->phy_if != PHY_INTERFACE_MODE_XGMII)\n\t\tspeed = 1000;\n\telse\n\t\tspeed = 10000;\n\tduplex = 1;\n\n\tops->adjust_link(h, speed, duplex);\n\n\t/* wait h/w ready */\n\tmdelay(300);\n\n\treturn 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\n",
        "post_patch": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "FreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n\n    while (stmt)\n    {\n        next = stmt->next;\n\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            /* stmt is already free'd here. */\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n\n        free(stmt);\n        stmt = next;\n    }\n}\n",
        "post_patch": "FreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n\n    while (stmt)\n    {\n        next = stmt->next;\n\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            /* stmt is already free'd here. */\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n\n        free(stmt);\n        stmt = next;\n    }\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int idle_balance(struct rq *this_rq, struct rq_flags *rf)\n{\n\tunsigned long next_balance = jiffies + HZ;\n\tint this_cpu = this_rq->cpu;\n\tstruct sched_domain *sd;\n\tint pulled_task = 0;\n\tu64 curr_cost = 0;\n\n\t/*\n\t * We must set idle_stamp _before_ calling idle_balance(), such that we\n\t * measure the duration of idle_balance() as idle time.\n\t */\n\tthis_rq->idle_stamp = rq_clock(this_rq);\n\n\t/*\n\t * Do not pull tasks towards !active CPUs...\n\t */\n\tif (!cpu_active(this_cpu))\n\t\treturn 0;\n\n\t/*\n\t * This is OK, because current is on_cpu, which avoids it being picked\n\t * for load-balance and preemption/IRQs are still disabled avoiding\n\t * further scheduler activity on it and we're being very careful to\n\t * re-start the picking loop.\n\t */\n\trq_unpin_lock(this_rq, rf);\n\n\tif (this_rq->avg_idle < sysctl_sched_migration_cost ||\n\t    !READ_ONCE(this_rq->rd->overload)) {\n\n\t\trcu_read_lock();\n\t\tsd = rcu_dereference_check_sched_domain(this_rq->sd);\n\t\tif (sd)\n\t\t\tupdate_next_balance(sd, &next_balance);\n\t\trcu_read_unlock();\n\n\t\tnohz_newidle_balance(this_rq);\n\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock(&this_rq->lock);\n\n\tupdate_blocked_averages(this_cpu);\n\trcu_read_lock();\n\tfor_each_domain(this_cpu, sd) {\n\t\tint continue_balancing = 1;\n\t\tu64 t0, domain_cost;\n\n\t\tif (!(sd->flags & SD_LOAD_BALANCE))\n\t\t\tcontinue;\n\n\t\tif (this_rq->avg_idle < curr_cost + sd->max_newidle_lb_cost) {\n\t\t\tupdate_next_balance(sd, &next_balance);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sd->flags & SD_BALANCE_NEWIDLE) {\n\t\t\tt0 = sched_clock_cpu(this_cpu);\n\n\t\t\tpulled_task = load_balance(this_cpu, this_rq,\n\t\t\t\t\t\t   sd, CPU_NEWLY_IDLE,\n\t\t\t\t\t\t   &continue_balancing);\n\n\t\t\tdomain_cost = sched_clock_cpu(this_cpu) - t0;\n\t\t\tif (domain_cost > sd->max_newidle_lb_cost)\n\t\t\t\tsd->max_newidle_lb_cost = domain_cost;\n\n\t\t\tcurr_cost += domain_cost;\n\t\t}\n\n\t\tupdate_next_balance(sd, &next_balance);\n\n\t\t/*\n\t\t * Stop searching for tasks to pull if there are\n\t\t * now runnable tasks on this rq.\n\t\t */\n\t\tif (pulled_task || this_rq->nr_running > 0)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\traw_spin_lock(&this_rq->lock);\n\n\tif (curr_cost > this_rq->max_idle_balance_cost)\n\t\tthis_rq->max_idle_balance_cost = curr_cost;\n\nout:\n\t/*\n\t * While browsing the domains, we released the rq lock, a task could\n\t * have been enqueued in the meantime. Since we're not going idle,\n\t * pretend we pulled a task.\n\t */\n\tif (this_rq->cfs.h_nr_running && !pulled_task)\n\t\tpulled_task = 1;\n\n\t/* Move the next balance forward */\n\tif (time_after(this_rq->next_balance, next_balance))\n\t\tthis_rq->next_balance = next_balance;\n\n\t/* Is there a task of a high priority class? */\n\tif (this_rq->nr_running != this_rq->cfs.h_nr_running)\n\t\tpulled_task = -1;\n\n\tif (pulled_task)\n\t\tthis_rq->idle_stamp = 0;\n\n\trq_repin_lock(this_rq, rf);\n\n\treturn pulled_task;\n}\n",
        "post_patch": "static int idle_balance(struct rq *this_rq, struct rq_flags *rf)\n{\n\tunsigned long next_balance = jiffies + HZ;\n\tint this_cpu = this_rq->cpu;\n\tstruct sched_domain *sd;\n\tint pulled_task = 0;\n\tu64 curr_cost = 0;\n\n\t/*\n\t * We must set idle_stamp _before_ calling idle_balance(), such that we\n\t * measure the duration of idle_balance() as idle time.\n\t */\n\tthis_rq->idle_stamp = rq_clock(this_rq);\n\n\t/*\n\t * Do not pull tasks towards !active CPUs...\n\t */\n\tif (!cpu_active(this_cpu))\n\t\treturn 0;\n\n\t/*\n\t * This is OK, because current is on_cpu, which avoids it being picked\n\t * for load-balance and preemption/IRQs are still disabled avoiding\n\t * further scheduler activity on it and we're being very careful to\n\t * re-start the picking loop.\n\t */\n\trq_unpin_lock(this_rq, rf);\n\n\tif (this_rq->avg_idle < sysctl_sched_migration_cost ||\n\t    !READ_ONCE(this_rq->rd->overload)) {\n\n\t\trcu_read_lock();\n\t\tsd = rcu_dereference_check_sched_domain(this_rq->sd);\n\t\tif (sd)\n\t\t\tupdate_next_balance(sd, &next_balance);\n\t\trcu_read_unlock();\n\n\t\tnohz_newidle_balance(this_rq);\n\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock(&this_rq->lock);\n\n\tupdate_blocked_averages(this_cpu);\n\trcu_read_lock();\n\tfor_each_domain(this_cpu, sd) {\n\t\tint continue_balancing = 1;\n\t\tu64 t0, domain_cost;\n\n\t\tif (!(sd->flags & SD_LOAD_BALANCE))\n\t\t\tcontinue;\n\n\t\tif (this_rq->avg_idle < curr_cost + sd->max_newidle_lb_cost) {\n\t\t\tupdate_next_balance(sd, &next_balance);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sd->flags & SD_BALANCE_NEWIDLE) {\n\t\t\tt0 = sched_clock_cpu(this_cpu);\n\n\t\t\tpulled_task = load_balance(this_cpu, this_rq,\n\t\t\t\t\t\t   sd, CPU_NEWLY_IDLE,\n\t\t\t\t\t\t   &continue_balancing);\n\n\t\t\tdomain_cost = sched_clock_cpu(this_cpu) - t0;\n\t\t\tif (domain_cost > sd->max_newidle_lb_cost)\n\t\t\t\tsd->max_newidle_lb_cost = domain_cost;\n\n\t\t\tcurr_cost += domain_cost;\n\t\t}\n\n\t\tupdate_next_balance(sd, &next_balance);\n\n\t\t/*\n\t\t * Stop searching for tasks to pull if there are\n\t\t * now runnable tasks on this rq.\n\t\t */\n\t\tif (pulled_task || this_rq->nr_running > 0)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\traw_spin_lock(&this_rq->lock);\n\n\tif (curr_cost > this_rq->max_idle_balance_cost)\n\t\tthis_rq->max_idle_balance_cost = curr_cost;\n\nout:\n\t/*\n\t * While browsing the domains, we released the rq lock, a task could\n\t * have been enqueued in the meantime. Since we're not going idle,\n\t * pretend we pulled a task.\n\t */\n\tif (this_rq->cfs.h_nr_running && !pulled_task)\n\t\tpulled_task = 1;\n\n\t/* Move the next balance forward */\n\tif (time_after(this_rq->next_balance, next_balance))\n\t\tthis_rq->next_balance = next_balance;\n\n\t/* Is there a task of a high priority class? */\n\tif (this_rq->nr_running != this_rq->cfs.h_nr_running)\n\t\tpulled_task = -1;\n\n\tif (pulled_task)\n\t\tthis_rq->idle_stamp = 0;\n\n\trq_repin_lock(this_rq, rf);\n\n\treturn pulled_task;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "  void OnDidAddMessageToConsole(int32_t,\n                                const base::string16& message,\n                                int32_t,\n                                const base::string16&) {\n    callback_.Run(message);\n  }\n",
        "post_patch": "  void OnDidAddMessageToConsole(int32_t,\n",
        "label": 1
    },
    {
        "pre_patch": "ofproto_get_snoops(const struct ofproto *ofproto, struct sset *snoops)\n{\n    connmgr_get_snoops(ofproto->connmgr, snoops);\n}\n",
        "post_patch": "ofproto_get_snoops(const struct ofproto *ofproto, struct sset *snoops)\n{\n    connmgr_get_snoops(ofproto->connmgr, snoops);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "SYSCALL_DEFINE2(ioprio_get, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret = -ESRCH;\n\tint tmpio;\n\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = get_task_ioprio(p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), user->uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_thread(g, p);\n\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n",
        "post_patch": "SYSCALL_DEFINE2(ioprio_get, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret = -ESRCH;\n\tint tmpio;\n\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = get_task_ioprio(p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), user->uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_thread(g, p);\n\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void php_snmp_write_property(zval *object, zval *member, zval *value, const zend_literal *key TSRMLS_DC)\n{\n\tzval tmp_member;\n\tphp_snmp_object *obj;\n\tphp_snmp_prop_handler *hnd;\n\tint ret;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\ttmp_member = *member;\n\t\tzval_copy_ctor(&tmp_member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t}\n\n\tret = FAILURE;\n\tobj = (php_snmp_object *)zend_objects_get_address(object TSRMLS_CC);\n\n\tret = zend_hash_find(&php_snmp_properties, Z_STRVAL_P(member), Z_STRLEN_P(member) + 1, (void **) &hnd);\n\n\tif (ret == SUCCESS && hnd->write_func) {\n\t\thnd->write_func(obj, value TSRMLS_CC);\n\t\tif (! PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) == 0) {\n\t\t\tZ_ADDREF_P(value);\n\t\t\tzval_ptr_dtor(&value);\n\t\t}\n\t} else {\n\t\tzend_object_handlers * std_hnd = zend_get_std_object_handlers();\n\t\tstd_hnd->write_property(object, member, value, key TSRMLS_CC);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n}\n",
        "post_patch": "void php_snmp_write_property(zval *object, zval *member, zval *value, const zend_literal *key TSRMLS_DC)\n{\n\tzval tmp_member;\n\tphp_snmp_object *obj;\n\tphp_snmp_prop_handler *hnd;\n\tint ret;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\ttmp_member = *member;\n\t\tzval_copy_ctor(&tmp_member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t}\n\n\tret = FAILURE;\n\tobj = (php_snmp_object *)zend_objects_get_address(object TSRMLS_CC);\n\n\tret = zend_hash_find(&php_snmp_properties, Z_STRVAL_P(member), Z_STRLEN_P(member) + 1, (void **) &hnd);\n\n\tif (ret == SUCCESS && hnd->write_func) {\n\t\thnd->write_func(obj, value TSRMLS_CC);\n\t\tif (! PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) == 0) {\n\t\t\tZ_ADDREF_P(value);\n\t\t\tzval_ptr_dtor(&value);\n\t\t}\n\t} else {\n\t\tzend_object_handlers * std_hnd = zend_get_std_object_handlers();\n\t\tstd_hnd->write_property(object, member, value, key TSRMLS_CC);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n}\n",
        "label": 0
    },
    {
        "pre_patch": "SYSCALL_DEFINE1(sigpending, old_sigset_t __user *, set)\n{\n\treturn do_sigpending(set, sizeof(*set));\n}\n",
        "post_patch": "SYSCALL_DEFINE1(sigpending, old_sigset_t __user *, set)\n{\n\treturn do_sigpending(set, sizeof(*set));\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}\n",
        "post_patch": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t}\n\tjas_tvparser_destroy(tvp);\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n \treturn 0;\n \n error:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}\n",
        "post_patch": "static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t}\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n\tjas_tvparser_destroy(tvp);\n \treturn 0;\n \n error:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {\n     uintptr_t receiver_id = RTCRtpReceiver::getId(\n         transceiver_state.receiver_state()->webrtc_receiver().get());\n     for (const auto& receiver : handler_->rtp_receivers_) {\n      if (receiver->Id() == receiver_id)\n        return false;\n    }\n    return true;\n  }\n",
        "post_patch": "   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {\n    DCHECK(handler_);\n     uintptr_t receiver_id = RTCRtpReceiver::getId(\n         transceiver_state.receiver_state()->webrtc_receiver().get());\n     for (const auto& receiver : handler_->rtp_receivers_) {\n      if (receiver->Id() == receiver_id)\n        return false;\n    }\n    return true;\n  }\n",
        "label": 1
    },
    {
        "pre_patch": "ofputil_decode_ofp13_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp13_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n",
        "post_patch": "ofputil_decode_ofp13_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp13_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n \t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n \t}\n \treturn change;\n }\n",
        "post_patch": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n \t} else {\n\t\tint ret = 0;\n\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (size < ue->tlv_data_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\tret = -EFAULT;\nerr_unlock:\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n \t}\n \treturn change;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "int sctp_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep = NULL;\n\tstruct sctp_ep_common *rcvr;\n\tstruct sctp_transport *transport = NULL;\n\tstruct sctp_chunk *chunk;\n\tstruct sctphdr *sh;\n\tunion sctp_addr src;\n\tunion sctp_addr dest;\n\tint family;\n\tstruct sctp_af *af;\n\n\tif (skb->pkt_type!=PACKET_HOST)\n\t\tgoto discard_it;\n\n\tSCTP_INC_STATS_BH(SCTP_MIB_INSCTPPACKS);\n\n\tif (skb_linearize(skb))\n\t\tgoto discard_it;\n\n\tsh = sctp_hdr(skb);\n\n\t/* Pull up the IP and SCTP headers. */\n\t__skb_pull(skb, skb_transport_offset(skb));\n\tif (skb->len < sizeof(struct sctphdr))\n\t\tgoto discard_it;\n\tif (!skb_csum_unnecessary(skb) && sctp_rcv_checksum(skb) < 0)\n\t\tgoto discard_it;\n\n\tskb_pull(skb, sizeof(struct sctphdr));\n\n\t/* Make sure we at least have chunk headers worth of data left. */\n\tif (skb->len < sizeof(struct sctp_chunkhdr))\n\t\tgoto discard_it;\n\n\tfamily = ipver2af(ip_hdr(skb)->version);\n\taf = sctp_get_af_specific(family);\n\tif (unlikely(!af))\n\t\tgoto discard_it;\n\n\t/* Initialize local addresses for lookups. */\n\taf->from_skb(&src, skb, 1);\n\taf->from_skb(&dest, skb, 0);\n\n\t/* If the packet is to or from a non-unicast address,\n\t * silently discard the packet.\n\t *\n\t * This is not clearly defined in the RFC except in section\n\t * 8.4 - OOTB handling.  However, based on the book \"Stream Control\n\t * Transmission Protocol\" 2.1, \"It is important to note that the\n\t * IP address of an SCTP transport address must be a routable\n\t * unicast address.  In other words, IP multicast addresses and\n\t * IP broadcast addresses cannot be used in an SCTP transport\n\t * address.\"\n\t */\n\tif (!af->addr_valid(&src, NULL, skb) ||\n\t    !af->addr_valid(&dest, NULL, skb))\n\t\tgoto discard_it;\n\n\tasoc = __sctp_rcv_lookup(skb, &src, &dest, &transport);\n\n\tif (!asoc)\n\t\tep = __sctp_rcv_lookup_endpoint(&dest);\n\n\t/* Retrieve the common input handling substructure. */\n\trcvr = asoc ? &asoc->base : &ep->base;\n\tsk = rcvr->sk;\n\n\t/*\n\t * If a frame arrives on an interface and the receiving socket is\n\t * bound to another interface, via SO_BINDTODEVICE, treat it as OOTB\n\t */\n\tif (sk->sk_bound_dev_if && (sk->sk_bound_dev_if != af->skb_iif(skb)))\n\t{\n\t\tif (asoc) {\n\t\t\tsctp_association_put(asoc);\n\t\t\tasoc = NULL;\n\t\t} else {\n\t\t\tsctp_endpoint_put(ep);\n\t\t\tep = NULL;\n\t\t}\n\t\tsk = sctp_get_ctl_sock();\n\t\tep = sctp_sk(sk)->ep;\n\t\tsctp_endpoint_hold(ep);\n\t\trcvr = &ep->base;\n\t}\n\n\t/*\n\t * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets.\n\t * An SCTP packet is called an \"out of the blue\" (OOTB)\n\t * packet if it is correctly formed, i.e., passed the\n\t * receiver's checksum check, but the receiver is not\n\t * able to identify the association to which this\n\t * packet belongs.\n\t */\n\tif (!asoc) {\n\t\tif (sctp_rcv_ootb(skb)) {\n\t\t\tSCTP_INC_STATS_BH(SCTP_MIB_OUTOFBLUES);\n\t\t\tgoto discard_release;\n\t\t}\n\t}\n\n\tif (!xfrm_policy_check(sk, XFRM_POLICY_IN, skb, family))\n\t\tgoto discard_release;\n\tnf_reset(skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_release;\n\n\t/* Create an SCTP packet structure. */\n\tchunk = sctp_chunkify(skb, asoc, sk);\n\tif (!chunk)\n\t\tgoto discard_release;\n\tSCTP_INPUT_CB(skb)->chunk = chunk;\n\n\t/* Remember what endpoint is to handle this packet. */\n\tchunk->rcvr = rcvr;\n\n\t/* Remember the SCTP header. */\n\tchunk->sctp_hdr = sh;\n\n\t/* Set the source and destination addresses of the incoming chunk.  */\n\tsctp_init_addrs(chunk, &src, &dest);\n\n\t/* Remember where we came from.  */\n\tchunk->transport = transport;\n\n\t/* Acquire access to the sock lock. Note: We are safe from other\n\t * bottom halves on this lock, but a user may be in the lock too,\n\t * so check if it is busy.\n \t */\n \tsctp_bh_lock_sock(sk);\n \n \tif (sock_owned_by_user(sk)) {\n \t\tSCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_BACKLOG);\n \t\tsctp_add_backlog(sk, skb);\n\t} else {\n\t\tSCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_SOFTIRQ);\n\t\tsctp_inq_push(&chunk->rcvr->inqueue, chunk);\n\t}\n\n\tsctp_bh_unlock_sock(sk);\n\n\t/* Release the asoc/ep ref we took in the lookup calls. */\n\tif (asoc)\n\t\tsctp_association_put(asoc);\n\telse\n\t\tsctp_endpoint_put(ep);\n\n\treturn 0;\n\ndiscard_it:\n\tSCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_DISCARDS);\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_release:\n\t/* Release the asoc/ep ref we took in the lookup calls. */\n\tif (asoc)\n\t\tsctp_association_put(asoc);\n\telse\n\t\tsctp_endpoint_put(ep);\n\n\tgoto discard_it;\n}\n",
        "post_patch": "int sctp_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep = NULL;\n\tstruct sctp_ep_common *rcvr;\n\tstruct sctp_transport *transport = NULL;\n\tstruct sctp_chunk *chunk;\n\tstruct sctphdr *sh;\n\tunion sctp_addr src;\n\tunion sctp_addr dest;\n\tint family;\n\tstruct sctp_af *af;\n\n\tif (skb->pkt_type!=PACKET_HOST)\n\t\tgoto discard_it;\n\n\tSCTP_INC_STATS_BH(SCTP_MIB_INSCTPPACKS);\n\n\tif (skb_linearize(skb))\n\t\tgoto discard_it;\n\n\tsh = sctp_hdr(skb);\n\n\t/* Pull up the IP and SCTP headers. */\n\t__skb_pull(skb, skb_transport_offset(skb));\n\tif (skb->len < sizeof(struct sctphdr))\n\t\tgoto discard_it;\n\tif (!skb_csum_unnecessary(skb) && sctp_rcv_checksum(skb) < 0)\n\t\tgoto discard_it;\n\n\tskb_pull(skb, sizeof(struct sctphdr));\n\n\t/* Make sure we at least have chunk headers worth of data left. */\n\tif (skb->len < sizeof(struct sctp_chunkhdr))\n\t\tgoto discard_it;\n\n\tfamily = ipver2af(ip_hdr(skb)->version);\n\taf = sctp_get_af_specific(family);\n\tif (unlikely(!af))\n\t\tgoto discard_it;\n\n\t/* Initialize local addresses for lookups. */\n\taf->from_skb(&src, skb, 1);\n\taf->from_skb(&dest, skb, 0);\n\n\t/* If the packet is to or from a non-unicast address,\n\t * silently discard the packet.\n\t *\n\t * This is not clearly defined in the RFC except in section\n\t * 8.4 - OOTB handling.  However, based on the book \"Stream Control\n\t * Transmission Protocol\" 2.1, \"It is important to note that the\n\t * IP address of an SCTP transport address must be a routable\n\t * unicast address.  In other words, IP multicast addresses and\n\t * IP broadcast addresses cannot be used in an SCTP transport\n\t * address.\"\n\t */\n\tif (!af->addr_valid(&src, NULL, skb) ||\n\t    !af->addr_valid(&dest, NULL, skb))\n\t\tgoto discard_it;\n\n\tasoc = __sctp_rcv_lookup(skb, &src, &dest, &transport);\n\n\tif (!asoc)\n\t\tep = __sctp_rcv_lookup_endpoint(&dest);\n\n\t/* Retrieve the common input handling substructure. */\n\trcvr = asoc ? &asoc->base : &ep->base;\n\tsk = rcvr->sk;\n\n\t/*\n\t * If a frame arrives on an interface and the receiving socket is\n\t * bound to another interface, via SO_BINDTODEVICE, treat it as OOTB\n\t */\n\tif (sk->sk_bound_dev_if && (sk->sk_bound_dev_if != af->skb_iif(skb)))\n\t{\n\t\tif (asoc) {\n\t\t\tsctp_association_put(asoc);\n\t\t\tasoc = NULL;\n\t\t} else {\n\t\t\tsctp_endpoint_put(ep);\n\t\t\tep = NULL;\n\t\t}\n\t\tsk = sctp_get_ctl_sock();\n\t\tep = sctp_sk(sk)->ep;\n\t\tsctp_endpoint_hold(ep);\n\t\trcvr = &ep->base;\n\t}\n\n\t/*\n\t * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets.\n\t * An SCTP packet is called an \"out of the blue\" (OOTB)\n\t * packet if it is correctly formed, i.e., passed the\n\t * receiver's checksum check, but the receiver is not\n\t * able to identify the association to which this\n\t * packet belongs.\n\t */\n\tif (!asoc) {\n\t\tif (sctp_rcv_ootb(skb)) {\n\t\t\tSCTP_INC_STATS_BH(SCTP_MIB_OUTOFBLUES);\n\t\t\tgoto discard_release;\n\t\t}\n\t}\n\n\tif (!xfrm_policy_check(sk, XFRM_POLICY_IN, skb, family))\n\t\tgoto discard_release;\n\tnf_reset(skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_release;\n\n\t/* Create an SCTP packet structure. */\n\tchunk = sctp_chunkify(skb, asoc, sk);\n\tif (!chunk)\n\t\tgoto discard_release;\n\tSCTP_INPUT_CB(skb)->chunk = chunk;\n\n\t/* Remember what endpoint is to handle this packet. */\n\tchunk->rcvr = rcvr;\n\n\t/* Remember the SCTP header. */\n\tchunk->sctp_hdr = sh;\n\n\t/* Set the source and destination addresses of the incoming chunk.  */\n\tsctp_init_addrs(chunk, &src, &dest);\n\n\t/* Remember where we came from.  */\n\tchunk->transport = transport;\n\n\t/* Acquire access to the sock lock. Note: We are safe from other\n\t * bottom halves on this lock, but a user may be in the lock too,\n\t * so check if it is busy.\n \t */\n \tsctp_bh_lock_sock(sk);\n \n\tif (sk != rcvr->sk) {\n\t\t/* Our cached sk is different from the rcvr->sk.  This is\n\t\t * because migrate()/accept() may have moved the association\n\t\t * to a new socket and released all the sockets.  So now we\n\t\t * are holding a lock on the old socket while the user may\n\t\t * be doing something with the new socket.  Switch our veiw\n\t\t * of the current sk.\n\t\t */\n\t\tsctp_bh_unlock_sock(sk);\n\t\tsk = rcvr->sk;\n\t\tsctp_bh_lock_sock(sk);\n\t}\n\n \tif (sock_owned_by_user(sk)) {\n \t\tSCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_BACKLOG);\n \t\tsctp_add_backlog(sk, skb);\n\t} else {\n\t\tSCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_SOFTIRQ);\n\t\tsctp_inq_push(&chunk->rcvr->inqueue, chunk);\n\t}\n\n\tsctp_bh_unlock_sock(sk);\n\n\t/* Release the asoc/ep ref we took in the lookup calls. */\n\tif (asoc)\n\t\tsctp_association_put(asoc);\n\telse\n\t\tsctp_endpoint_put(ep);\n\n\treturn 0;\n\ndiscard_it:\n\tSCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_DISCARDS);\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_release:\n\t/* Release the asoc/ep ref we took in the lookup calls. */\n\tif (asoc)\n\t\tsctp_association_put(asoc);\n\telse\n\t\tsctp_endpoint_put(ep);\n\n\tgoto discard_it;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "int main(int argc, char **argv) {\n\tint result;\n\tint error = FALSE;\n\tint display_license = FALSE;\n\tint display_help = FALSE;\n\tint c = 0;\n\tstruct tm *tm, tm_s;\n\ttime_t now;\n\tchar datestring[256];\n\tnagios_macros *mac;\n\tconst char *worker_socket = NULL;\n\tint i;\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sig_action;\n#endif\n\n#ifdef HAVE_GETOPT_H\n\tint option_index = 0;\n\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'V'},\n\t\t\t{\"license\", no_argument, 0, 'V'},\n\t\t\t{\"verify-config\", no_argument, 0, 'v'},\n\t\t\t{\"daemon\", no_argument, 0, 'd'},\n\t\t\t{\"test-scheduling\", no_argument, 0, 's'},\n\t\t\t{\"precache-objects\", no_argument, 0, 'p'},\n\t\t\t{\"use-precached-objects\", no_argument, 0, 'u'},\n\t\t\t{\"enable-timing-point\", no_argument, 0, 'T'},\n\t\t\t{\"worker\", required_argument, 0, 'W'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)\n#endif\n\n\tmemset(&loadctl, 0, sizeof(loadctl));\n\tmac = get_global_macros();\n\n\t/* make sure we have the correct number of command line arguments */\n\tif(argc < 2)\n\t\terror = TRUE;\n\n\t/* get all command line arguments */\n\twhile(1) {\n\t\tc = getopt(argc, argv, \"+hVvdspuxTW\");\n\n\t\tif(c == -1 || c == EOF)\n\t\t\tbreak;\n\n\t\tswitch(c) {\n\n\t\t\tcase '?': /* usage */\n\t\t\tcase 'h':\n\t\t\t\tdisplay_help = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'V': /* version */\n\t\t\t\tdisplay_license = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v': /* verify */\n\t\t\t\tverify_config++;\n\t\t\t\tbreak;\n\n\t\t\tcase 's': /* scheduling check */\n\t\t\t\ttest_scheduling = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd': /* daemon mode */\n\t\t\t\tdaemon_mode = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p': /* precache object config */\n\t\t\t\tprecache_objects = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u': /* use precached object config */\n\t\t\t\tuse_precached_objects = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tenable_timing_point = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tworker_socket = optarg;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\n\t\t\t\tprintf(\"Warning: -x is deprecated and will be removed\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n#ifdef DEBUG_MEMORY\n\tmtrace();\n#endif\n\t/* if we're a worker we can skip everything below */\n\tif(worker_socket) {\n\t\texit(nagios_core_worker(worker_socket));\n\t}\n\n\t/* Initialize configuration variables */                             \n\tinit_main_cfg_vars(1);\n\tinit_shared_cfg_vars(1);\n\n\tif(daemon_mode == FALSE) {\n\t\tprintf(\"\\nNagios Core %s\\n\", PROGRAM_VERSION);\n\t\tprintf(\"Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\\n\");\n\t\tprintf(\"Copyright (c) 1999-2009 Ethan Galstad\\n\");\n\t\tprintf(\"Last Modified: %s\\n\", PROGRAM_MODIFICATION_DATE);\n\t\tprintf(\"License: GPL\\n\\n\");\n\t\tprintf(\"Website: https://www.nagios.org\\n\");\n\t\t}\n\n\t/* just display the license */\n\tif(display_license == TRUE) {\n\n\t\tprintf(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\tprintf(\"it under the terms of the GNU General Public License version 2 as\\n\");\n\t\tprintf(\"published by the Free Software Foundation.\\n\\n\");\n\t\tprintf(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\tprintf(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\tprintf(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\");\n\t\tprintf(\"GNU General Public License for more details.\\n\\n\");\n\t\tprintf(\"You should have received a copy of the GNU General Public License\\n\");\n\t\tprintf(\"along with this program; if not, write to the Free Software\\n\");\n\t\tprintf(\"Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\\n\\n\");\n\n\t\texit(OK);\n\t\t}\n\n\t/* make sure we got the main config file on the command line... */\n\tif(optind >= argc)\n\t\terror = TRUE;\n\n\t/* if there are no command line options (or if we encountered an error), print usage */\n\tif(error == TRUE || display_help == TRUE) {\n\n\t\tprintf(\"Usage: %s [options] <main_config_file>\\n\", argv[0]);\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Options:\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"  -v, --verify-config          Verify all configuration data (-v -v for more info)\\n\");\n\t\tprintf(\"  -s, --test-scheduling        Shows projected/recommended check scheduling and other\\n\");\n\t\tprintf(\"                               diagnostic info based on the current configuration files.\\n\");\n\t\tprintf(\"  -T, --enable-timing-point    Enable timed commentary on initialization\\n\");\n\t\tprintf(\"  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\\n\");\n\t\tprintf(\"  -p, --precache-objects       Precache object configuration\\n\");\n\t\tprintf(\"  -u, --use-precached-objects  Use precached object config file\\n\");\n\t\tprintf(\"  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\\n\");\n\t\tprintf(\"  -W, --worker /path/to/socket Act as a worker for an already running daemon\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\\n\");\n\t\tprintf(\"releases, online documentation, FAQs, information on subscribing to\\n\");\n\t\tprintf(\"the mailing lists, and commercial support options for Nagios.\\n\");\n\t\tprintf(\"\\n\");\n\n\t\texit(ERROR);\n\t\t}\n\n\n\t/*\n\t * config file is last argument specified.\n\t * Make sure it uses an absolute path\n\t */\n\tconfig_file = nspath_absolute(argv[optind], NULL);\n\tif(config_file == NULL) {\n\t\tprintf(\"Error allocating memory.\\n\");\n\t\texit(ERROR);\n\t\t}\n\n\tconfig_file_dir = nspath_absolute_dirname(config_file, NULL);\n\n\t/* \n\t * Set the signal handler for the SIGXFSZ signal here because\n\t * we may encounter this signal before the other signal handlers\n\t * are set.\n\t */\n#ifdef HAVE_SIGACTION\n\tsig_action.sa_sigaction = NULL;\n\tsig_action.sa_handler = handle_sigxfsz;\n\tsigfillset(&sig_action.sa_mask);\n\tsig_action.sa_flags = SA_NODEFER|SA_RESTART;\n\tsigaction(SIGXFSZ, &sig_action, NULL);\n#else\n\tsignal(SIGXFSZ, handle_sigxfsz);\n#endif\n\n\t/*\n\t * let's go to town. We'll be noisy if we're verifying config\n\t * or running scheduling tests.\n\t */\n\tif(verify_config || test_scheduling || precache_objects) {\n\t\treset_variables();\n\t\t/*\n\t\t * if we don't beef up our resource limits as much as\n\t\t * we can, it's quite possible we'll run headlong into\n\t\t * EAGAIN due to too many processes when we try to\n\t\t * drop privileges later.\n\t\t */\n\t\tset_loadctl_defaults();\n\n\t\tif(verify_config)\n\t\t\tprintf(\"Reading configuration data...\\n\");\n\n\t\t/* read our config file */\n\t\tresult = read_main_config_file(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing main config file!\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config)\n\t\t\tprintf(\"   Read main config file okay...\\n\");\n\n\t\t/* drop privileges */\n\t\tif((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {\n\t\t\tprintf(\"   Failed to drop privileges.  Aborting.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/*\n\t\t * this must come after dropping privileges, so we make\n\t\t * sure to test access permissions as the right user.\n\t\t */\n\t\tif (!verify_config && test_configured_paths() == ERROR) {\n\t\t\tprintf(\"   One or more path problems detected. Aborting.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* read object config files */\n\t\tresult = read_all_object_data(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing object config files!\\n\\n\");\n\t\t\t/* if the config filename looks fishy, warn the user */\n\t\t\tif(!strstr(config_file, \"nagios.cfg\")) {\n\t\t\t\tprintf(\"\\n***> The name of the main configuration file looks suspicious...\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"     Make sure you are specifying the name of the MAIN configuration file on\\n\");\n\t\t\t\tprintf(\"     the command line and not the name of another configuration file.  The\\n\");\n\t\t\t\tprintf(\"     main configuration file is typically '%s'\\n\", DEFAULT_CONFIG_FILE);\n\t\t\t\t}\n\n\t\t\tprintf(\"\\n***> One or more problems was encountered while processing the config files...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"   Read object config files okay...\\n\\n\");\n\t\t\tprintf(\"Running pre-flight check on configuration data...\\n\\n\");\n\t\t\t}\n\n\t\t/* run the pre-flight check to make sure things look okay... */\n\t\tresult = pre_flight_check();\n\n\t\tif(result != OK) {\n\t\t\tprintf(\"\\n***> One or more problems was encountered while running the pre-flight check...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"\\nThings look okay - No serious problems were detected during the pre-flight check\\n\");\n\t\t\t}\n\n\t\t/* scheduling tests need a bit more than config verifications */\n\t\tif(test_scheduling == TRUE) {\n\n\t\t\t/* we'll need the event queue here so we can time insertions */\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Done initializing event queue\\n\");\n\n\t\t\t/* read initial service and host state information */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Retention data and initial state parsed\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Timing loop initialized\\n\");\n\n\t\t\t/* display scheduling information */\n\t\t\tdisplay_scheduling_info();\n\t\t\t}\n\n\t\tif(precache_objects) {\n\t\t\tresult = fcache_objects(object_precache_file);\n\t\t\ttiming_point(\"Done precaching objects\\n\");\n\t\t\tif(result == OK) {\n\t\t\t\tprintf(\"Object precache file created:\\n%s\\n\", object_precache_file);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Failed to precache objects to '%s': %s\\n\", object_precache_file, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* clean up after ourselves */\n\t\tcleanup();\n\n\t\t/* exit */\n\t\ttiming_point(\"Exiting\\n\");\n\n\t\t/* make valgrind shut up about still reachable memory */\n\t\tneb_free_module_list();\n\t\tfree(config_file_dir);\n\t\tfree(config_file);\n\n\t\texit(result);\n\t\t}\n\n\n\t/* else start to monitor things... */\n\telse {\n\n\t\t/*\n\t\t * if we're called with a relative path we must make\n\t\t * it absolute so we can launch our workers.\n\t\t * If not, we needn't bother, as we're using execvp()\n\t\t */\n\t\tif (strchr(argv[0], '/'))\n\t\t\tnagios_binary_path = nspath_absolute(argv[0], NULL);\n\t\telse\n\t\t\tnagios_binary_path = strdup(argv[0]);\n\n\t\tif (!nagios_binary_path) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Unable to allocate memory for nagios_binary_path\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif (!(nagios_iobs = iobroker_create())) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to create IO broker set: %s\\n\",\n\t\t\t\t  strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* keep monitoring things until we get a shutdown command */\n\t\tdo {\n\t\t\t/* reset internal book-keeping (in case we're restarting) */\n\t\t\twproc_num_workers_spawned = wproc_num_workers_online = 0;\n\t\t\tcaught_signal = sigshutdown = FALSE;\n\t\t\tsig_id = 0;\n\n\t\t\t/* reset program variables */\n\t\t\treset_variables();\n\t\t\ttiming_point(\"Variables reset\\n\");\n\n\t\t\t/* get PID */\n\t\t\tnagios_pid = (int)getpid();\n\n\t\t\t/* read in the configuration files (main and resource config files) */\n\t\t\tresult = read_main_config_file(config_file);\n\t\t\tif (result != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n \t\t\tprogram_start = time(NULL);\n \t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n \t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n \n \t\t\t/* drop privileges */\n \t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n \t\t\t\t/* error has already been logged */\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t\t}\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\t\t\t\tresult = daemon_init();\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n \n \t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n \t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);\n\n\t\t\t/* write log version/info */\n\t\t\twrite_log_file_info(NULL);\n\n\t\t\t/* open debug log now that we're the right user */\n\t\t\topen_debug_log();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* initialize modules */\n\t\t\tneb_init_modules();\n\t\t\tneb_init_callback_list();\n#endif\n\t\t\ttiming_point(\"NEB module API initialized\\n\");\n\n\t\t\t/* handle signals (interrupts) before we do any socket I/O */\n\t\t\tsetup_sighandler();\n\n\t\t\t/*\n\t\t\t * Initialize query handler and event subscription service.\n\t\t\t * This must be done before modules are initialized, so\n\t\t\t * the modules can use our in-core stuff properly\n\t\t\t */\n\t\t\tif (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to initialize query handler. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"Query handler initialized\\n\");\n\t\t\tnerd_init();\n\t\t\ttiming_point(\"NERD initialized\\n\");\n\n\t\t\t/* initialize check workers */\n\t\t\tif(init_workers(num_check_workers) < 0) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Failed to spawn workers. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"%u workers spawned\\n\", wproc_num_workers_spawned);\n\t\t\ti = 0;\n\t\t\twhile (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {\n\t\t\t\tiobroker_poll(nagios_iobs, 50);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ttiming_point(\"%u workers connected\\n\", wproc_num_workers_online);\n\n\t\t\t/* now that workers have arrived we can set the defaults */\n\t\t\tset_loadctl_defaults();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* load modules */\n\t\t\tif (neb_load_all_modules() != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, ERROR, \"Error: Module loading failed. Aborting.\\n\");\n\t\t\t\t/* if we're dumping core, we must remove all dl-files */\n\t\t\t\tif (daemon_dumps_core)\n\t\t\t\t\tneb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Modules loaded\\n\");\n\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\ttiming_point(\"First callback made\\n\");\n#endif\n\n\t\t\t/* read in all object config data */\n\t\t\tif(result == OK)\n\t\t\t\tresult = read_all_object_data(config_file);\n\n\t\t\t/* there was a problem reading the config files */\n\t\t\tif(result != OK)\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\", (int)getpid());\n\n\t\t\telse {\n\n\t\t\t\t/* run the pre-flight check to make sure everything looks okay*/\n\t\t\t\tif((result = pre_flight_check()) != OK)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, \"Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* an error occurred that prevented us from (re)starting */\n\t\t\tif(result != OK) {\n\n\t\t\t\t/* if we were restarting, we need to cleanup from the previous run */\n\t\t\t\tif(sigrestart == TRUE) {\n\n\t\t\t\t\t/* clean up the status data */\n\t\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t\t/* send program data to broker */\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);\n#endif\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\ttiming_point(\"Object configuration parsed and understood\\n\");\n\n\t\t\t/* write the objects.cache file */\n\t\t\tfcache_objects(object_cache_file);\n\t\t\ttiming_point(\"Objects cached\\n\");\n\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Event queue initialized\\n\");\n\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* initialize status data unless we're starting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tinitialize_status_data(config_file);\n\t\t\t\ttiming_point(\"Status data initialized\\n\");\n\t\t\t\t}\n\n\t\t\t/* initialize scheduled downtime data */\n\t\t\tinitialize_downtime_data();\n\t\t\ttiming_point(\"Downtime data initialized\\n\");\n\n\t\t\t/* read initial service and host state information  */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\ttiming_point(\"Retention data initialized\\n\");\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Initial state information read\\n\");\n\n\t\t\t/* initialize comment data */\n\t\t\tinitialize_comment_data();\n\t\t\ttiming_point(\"Comment data initialized\\n\");\n\n\t\t\t/* initialize performance data */\n\t\t\tinitialize_performance_data(config_file);\n\t\t\ttiming_point(\"Performance data initialized\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Event timing loop initialized\\n\");\n\n\t\t\t/* initialize check statistics */\n\t\t\tinit_check_stats();\n\t\t\ttiming_point(\"check stats initialized\\n\");\n\n\t\t\t/* check for updates */\n\t\t\tcheck_for_nagios_updates(FALSE, TRUE);\n\t\t\ttiming_point(\"Update check concluded\\n\");\n\n\t\t\t/* update all status data (with retained information) */\n\t\t\tupdate_all_status_data();\n\t\t\ttiming_point(\"Status data updated\\n\");\n\n\t\t\t/* log initial host and service state */\n\t\t\tlog_host_states(INITIAL_STATES, NULL);\n\t\t\tlog_service_states(INITIAL_STATES, NULL);\n\t\t\ttiming_point(\"Initial states logged\\n\");\n\n\t\t\t/* reset the restart flag */\n\t\t\tsigrestart = FALSE;\n\n\t\t\t/* fire up command file worker */\n\t\t\tlaunch_command_file_worker();\n\t\t\ttiming_point(\"Command file worker launched\\n\");\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* get event start time and save as macro */\n\t\t\tevent_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_EVENTSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_EVENTSTARTTIME], \"%llu\", (unsigned long long)event_start);\n\n\t\t\ttiming_point(\"Entering event execution loop\\n\");\n\t\t\t/***** start monitoring all services *****/\n\t\t\t/* (doesn't return until a restart or shutdown signal is encountered) */\n\t\t\tevent_execution_loop();\n\n\t\t\t/*\n\t\t\t * immediately deinitialize the query handler so it\n\t\t\t * can remove modules that have stashed data with it\n\t\t\t */\n\t\t\tqh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);\n\n\t\t\t/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */\n\t\t\t/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */\n\t\t\t/* did we catch a signal? */\n\t\t\tif(caught_signal == TRUE) {\n\n\t\t\t\tif(sig_id == SIGHUP)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Caught SIGHUP, restarting...\\n\");\n\n\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\tif(sigshutdown == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);\n\t\t\telse if(sigrestart == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);\n#endif\n\n\t\t\t/* save service and host state information */\n\t\t\tsave_state_information(FALSE);\n\t\t\tcleanup_retention_data();\n\n\t\t\t/* clean up performance data */\n\t\t\tcleanup_performance_data();\n\n\t\t\t/* clean up the scheduled downtime data */\n\t\t\tcleanup_downtime_data();\n\n\t\t\t/* clean up the status data unless we're restarting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t}\n\n\t\t\tfree_worker_memory(WPROC_FORCE);\n\t\t\t/* shutdown stuff... */\n\t\t\tif(sigshutdown == TRUE) {\n\t\t\t\tiobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);\n\t\t\t\tnagios_iobs = NULL;\n\n\t\t\t\t/* log a shutdown message */\n\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Successfully shutdown... (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* clean up after ourselves */\n\t\t\tcleanup();\n\n\t\t\t/* close debug log */\n\t\t\tclose_debug_log();\n\n\t\t\t}\n\t\twhile(sigrestart == TRUE && sigshutdown == FALSE);\n\n\t\tif(daemon_mode == TRUE)\n\t\t\tunlink(lock_file);\n\n\t\t/* free misc memory */\n\t\tmy_free(lock_file);\n\t\tmy_free(config_file);\n\t\tmy_free(config_file_dir);\n\t\tmy_free(nagios_binary_path);\n\t\t}\n\n\treturn OK;\n\t}\n",
        "post_patch": "int main(int argc, char **argv) {\n\tint result;\n\tint error = FALSE;\n\tint display_license = FALSE;\n\tint display_help = FALSE;\n\tint c = 0;\n\tstruct tm *tm, tm_s;\n\ttime_t now;\n\tchar datestring[256];\n\tnagios_macros *mac;\n\tconst char *worker_socket = NULL;\n\tint i;\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sig_action;\n#endif\n\n#ifdef HAVE_GETOPT_H\n\tint option_index = 0;\n\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'V'},\n\t\t\t{\"license\", no_argument, 0, 'V'},\n\t\t\t{\"verify-config\", no_argument, 0, 'v'},\n\t\t\t{\"daemon\", no_argument, 0, 'd'},\n\t\t\t{\"test-scheduling\", no_argument, 0, 's'},\n\t\t\t{\"precache-objects\", no_argument, 0, 'p'},\n\t\t\t{\"use-precached-objects\", no_argument, 0, 'u'},\n\t\t\t{\"enable-timing-point\", no_argument, 0, 'T'},\n\t\t\t{\"worker\", required_argument, 0, 'W'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)\n#endif\n\n\tmemset(&loadctl, 0, sizeof(loadctl));\n\tmac = get_global_macros();\n\n\t/* make sure we have the correct number of command line arguments */\n\tif(argc < 2)\n\t\terror = TRUE;\n\n\t/* get all command line arguments */\n\twhile(1) {\n\t\tc = getopt(argc, argv, \"+hVvdspuxTW\");\n\n\t\tif(c == -1 || c == EOF)\n\t\t\tbreak;\n\n\t\tswitch(c) {\n\n\t\t\tcase '?': /* usage */\n\t\t\tcase 'h':\n\t\t\t\tdisplay_help = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'V': /* version */\n\t\t\t\tdisplay_license = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v': /* verify */\n\t\t\t\tverify_config++;\n\t\t\t\tbreak;\n\n\t\t\tcase 's': /* scheduling check */\n\t\t\t\ttest_scheduling = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd': /* daemon mode */\n\t\t\t\tdaemon_mode = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p': /* precache object config */\n\t\t\t\tprecache_objects = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u': /* use precached object config */\n\t\t\t\tuse_precached_objects = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tenable_timing_point = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tworker_socket = optarg;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\n\t\t\t\tprintf(\"Warning: -x is deprecated and will be removed\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n#ifdef DEBUG_MEMORY\n\tmtrace();\n#endif\n\t/* if we're a worker we can skip everything below */\n\tif(worker_socket) {\n\t\texit(nagios_core_worker(worker_socket));\n\t}\n\n\t/* Initialize configuration variables */                             \n\tinit_main_cfg_vars(1);\n\tinit_shared_cfg_vars(1);\n\n\tif(daemon_mode == FALSE) {\n\t\tprintf(\"\\nNagios Core %s\\n\", PROGRAM_VERSION);\n\t\tprintf(\"Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\\n\");\n\t\tprintf(\"Copyright (c) 1999-2009 Ethan Galstad\\n\");\n\t\tprintf(\"Last Modified: %s\\n\", PROGRAM_MODIFICATION_DATE);\n\t\tprintf(\"License: GPL\\n\\n\");\n\t\tprintf(\"Website: https://www.nagios.org\\n\");\n\t\t}\n\n\t/* just display the license */\n\tif(display_license == TRUE) {\n\n\t\tprintf(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\tprintf(\"it under the terms of the GNU General Public License version 2 as\\n\");\n\t\tprintf(\"published by the Free Software Foundation.\\n\\n\");\n\t\tprintf(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\tprintf(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\tprintf(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\");\n\t\tprintf(\"GNU General Public License for more details.\\n\\n\");\n\t\tprintf(\"You should have received a copy of the GNU General Public License\\n\");\n\t\tprintf(\"along with this program; if not, write to the Free Software\\n\");\n\t\tprintf(\"Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\\n\\n\");\n\n\t\texit(OK);\n\t\t}\n\n\t/* make sure we got the main config file on the command line... */\n\tif(optind >= argc)\n\t\terror = TRUE;\n\n\t/* if there are no command line options (or if we encountered an error), print usage */\n\tif(error == TRUE || display_help == TRUE) {\n\n\t\tprintf(\"Usage: %s [options] <main_config_file>\\n\", argv[0]);\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Options:\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"  -v, --verify-config          Verify all configuration data (-v -v for more info)\\n\");\n\t\tprintf(\"  -s, --test-scheduling        Shows projected/recommended check scheduling and other\\n\");\n\t\tprintf(\"                               diagnostic info based on the current configuration files.\\n\");\n\t\tprintf(\"  -T, --enable-timing-point    Enable timed commentary on initialization\\n\");\n\t\tprintf(\"  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\\n\");\n\t\tprintf(\"  -p, --precache-objects       Precache object configuration\\n\");\n\t\tprintf(\"  -u, --use-precached-objects  Use precached object config file\\n\");\n\t\tprintf(\"  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\\n\");\n\t\tprintf(\"  -W, --worker /path/to/socket Act as a worker for an already running daemon\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\\n\");\n\t\tprintf(\"releases, online documentation, FAQs, information on subscribing to\\n\");\n\t\tprintf(\"the mailing lists, and commercial support options for Nagios.\\n\");\n\t\tprintf(\"\\n\");\n\n\t\texit(ERROR);\n\t\t}\n\n\n\t/*\n\t * config file is last argument specified.\n\t * Make sure it uses an absolute path\n\t */\n\tconfig_file = nspath_absolute(argv[optind], NULL);\n\tif(config_file == NULL) {\n\t\tprintf(\"Error allocating memory.\\n\");\n\t\texit(ERROR);\n\t\t}\n\n\tconfig_file_dir = nspath_absolute_dirname(config_file, NULL);\n\n\t/* \n\t * Set the signal handler for the SIGXFSZ signal here because\n\t * we may encounter this signal before the other signal handlers\n\t * are set.\n\t */\n#ifdef HAVE_SIGACTION\n\tsig_action.sa_sigaction = NULL;\n\tsig_action.sa_handler = handle_sigxfsz;\n\tsigfillset(&sig_action.sa_mask);\n\tsig_action.sa_flags = SA_NODEFER|SA_RESTART;\n\tsigaction(SIGXFSZ, &sig_action, NULL);\n#else\n\tsignal(SIGXFSZ, handle_sigxfsz);\n#endif\n\n\t/*\n\t * let's go to town. We'll be noisy if we're verifying config\n\t * or running scheduling tests.\n\t */\n\tif(verify_config || test_scheduling || precache_objects) {\n\t\treset_variables();\n\t\t/*\n\t\t * if we don't beef up our resource limits as much as\n\t\t * we can, it's quite possible we'll run headlong into\n\t\t * EAGAIN due to too many processes when we try to\n\t\t * drop privileges later.\n\t\t */\n\t\tset_loadctl_defaults();\n\n\t\tif(verify_config)\n\t\t\tprintf(\"Reading configuration data...\\n\");\n\n\t\t/* read our config file */\n\t\tresult = read_main_config_file(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing main config file!\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config)\n\t\t\tprintf(\"   Read main config file okay...\\n\");\n\n\t\t/* drop privileges */\n\t\tif((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {\n\t\t\tprintf(\"   Failed to drop privileges.  Aborting.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/*\n\t\t * this must come after dropping privileges, so we make\n\t\t * sure to test access permissions as the right user.\n\t\t */\n\t\tif (!verify_config && test_configured_paths() == ERROR) {\n\t\t\tprintf(\"   One or more path problems detected. Aborting.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* read object config files */\n\t\tresult = read_all_object_data(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing object config files!\\n\\n\");\n\t\t\t/* if the config filename looks fishy, warn the user */\n\t\t\tif(!strstr(config_file, \"nagios.cfg\")) {\n\t\t\t\tprintf(\"\\n***> The name of the main configuration file looks suspicious...\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"     Make sure you are specifying the name of the MAIN configuration file on\\n\");\n\t\t\t\tprintf(\"     the command line and not the name of another configuration file.  The\\n\");\n\t\t\t\tprintf(\"     main configuration file is typically '%s'\\n\", DEFAULT_CONFIG_FILE);\n\t\t\t\t}\n\n\t\t\tprintf(\"\\n***> One or more problems was encountered while processing the config files...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"   Read object config files okay...\\n\\n\");\n\t\t\tprintf(\"Running pre-flight check on configuration data...\\n\\n\");\n\t\t\t}\n\n\t\t/* run the pre-flight check to make sure things look okay... */\n\t\tresult = pre_flight_check();\n\n\t\tif(result != OK) {\n\t\t\tprintf(\"\\n***> One or more problems was encountered while running the pre-flight check...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"\\nThings look okay - No serious problems were detected during the pre-flight check\\n\");\n\t\t\t}\n\n\t\t/* scheduling tests need a bit more than config verifications */\n\t\tif(test_scheduling == TRUE) {\n\n\t\t\t/* we'll need the event queue here so we can time insertions */\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Done initializing event queue\\n\");\n\n\t\t\t/* read initial service and host state information */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Retention data and initial state parsed\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Timing loop initialized\\n\");\n\n\t\t\t/* display scheduling information */\n\t\t\tdisplay_scheduling_info();\n\t\t\t}\n\n\t\tif(precache_objects) {\n\t\t\tresult = fcache_objects(object_precache_file);\n\t\t\ttiming_point(\"Done precaching objects\\n\");\n\t\t\tif(result == OK) {\n\t\t\t\tprintf(\"Object precache file created:\\n%s\\n\", object_precache_file);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Failed to precache objects to '%s': %s\\n\", object_precache_file, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* clean up after ourselves */\n\t\tcleanup();\n\n\t\t/* exit */\n\t\ttiming_point(\"Exiting\\n\");\n\n\t\t/* make valgrind shut up about still reachable memory */\n\t\tneb_free_module_list();\n\t\tfree(config_file_dir);\n\t\tfree(config_file);\n\n\t\texit(result);\n\t\t}\n\n\n\t/* else start to monitor things... */\n\telse {\n\n\t\t/*\n\t\t * if we're called with a relative path we must make\n\t\t * it absolute so we can launch our workers.\n\t\t * If not, we needn't bother, as we're using execvp()\n\t\t */\n\t\tif (strchr(argv[0], '/'))\n\t\t\tnagios_binary_path = nspath_absolute(argv[0], NULL);\n\t\telse\n\t\t\tnagios_binary_path = strdup(argv[0]);\n\n\t\tif (!nagios_binary_path) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Unable to allocate memory for nagios_binary_path\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif (!(nagios_iobs = iobroker_create())) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to create IO broker set: %s\\n\",\n\t\t\t\t  strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* keep monitoring things until we get a shutdown command */\n\t\tdo {\n\t\t\t/* reset internal book-keeping (in case we're restarting) */\n\t\t\twproc_num_workers_spawned = wproc_num_workers_online = 0;\n\t\t\tcaught_signal = sigshutdown = FALSE;\n\t\t\tsig_id = 0;\n\n\t\t\t/* reset program variables */\n\t\t\treset_variables();\n\t\t\ttiming_point(\"Variables reset\\n\");\n\n\t\t\t/* get PID */\n\t\t\tnagios_pid = (int)getpid();\n\n\t\t\t/* read in the configuration files (main and resource config files) */\n\t\t\tresult = read_main_config_file(config_file);\n\t\t\tif (result != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n \t\t\tprogram_start = time(NULL);\n \t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n \t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\t\t\t\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n \n \t\t\t/* drop privileges */\n \t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n \t\t\t\t/* error has already been logged */\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t\t}\n \n \t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n \t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);\n\n\t\t\t/* write log version/info */\n\t\t\twrite_log_file_info(NULL);\n\n\t\t\t/* open debug log now that we're the right user */\n\t\t\topen_debug_log();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* initialize modules */\n\t\t\tneb_init_modules();\n\t\t\tneb_init_callback_list();\n#endif\n\t\t\ttiming_point(\"NEB module API initialized\\n\");\n\n\t\t\t/* handle signals (interrupts) before we do any socket I/O */\n\t\t\tsetup_sighandler();\n\n\t\t\t/*\n\t\t\t * Initialize query handler and event subscription service.\n\t\t\t * This must be done before modules are initialized, so\n\t\t\t * the modules can use our in-core stuff properly\n\t\t\t */\n\t\t\tif (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to initialize query handler. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"Query handler initialized\\n\");\n\t\t\tnerd_init();\n\t\t\ttiming_point(\"NERD initialized\\n\");\n\n\t\t\t/* initialize check workers */\n\t\t\tif(init_workers(num_check_workers) < 0) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Failed to spawn workers. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"%u workers spawned\\n\", wproc_num_workers_spawned);\n\t\t\ti = 0;\n\t\t\twhile (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {\n\t\t\t\tiobroker_poll(nagios_iobs, 50);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ttiming_point(\"%u workers connected\\n\", wproc_num_workers_online);\n\n\t\t\t/* now that workers have arrived we can set the defaults */\n\t\t\tset_loadctl_defaults();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* load modules */\n\t\t\tif (neb_load_all_modules() != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, ERROR, \"Error: Module loading failed. Aborting.\\n\");\n\t\t\t\t/* if we're dumping core, we must remove all dl-files */\n\t\t\t\tif (daemon_dumps_core)\n\t\t\t\t\tneb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Modules loaded\\n\");\n\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\ttiming_point(\"First callback made\\n\");\n#endif\n\n\t\t\t/* read in all object config data */\n\t\t\tif(result == OK)\n\t\t\t\tresult = read_all_object_data(config_file);\n\n\t\t\t/* there was a problem reading the config files */\n\t\t\tif(result != OK)\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\", (int)getpid());\n\n\t\t\telse {\n\n\t\t\t\t/* run the pre-flight check to make sure everything looks okay*/\n\t\t\t\tif((result = pre_flight_check()) != OK)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, \"Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* an error occurred that prevented us from (re)starting */\n\t\t\tif(result != OK) {\n\n\t\t\t\t/* if we were restarting, we need to cleanup from the previous run */\n\t\t\t\tif(sigrestart == TRUE) {\n\n\t\t\t\t\t/* clean up the status data */\n\t\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t\t/* send program data to broker */\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);\n#endif\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\ttiming_point(\"Object configuration parsed and understood\\n\");\n\n\t\t\t/* write the objects.cache file */\n\t\t\tfcache_objects(object_cache_file);\n\t\t\ttiming_point(\"Objects cached\\n\");\n\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Event queue initialized\\n\");\n\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* initialize status data unless we're starting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tinitialize_status_data(config_file);\n\t\t\t\ttiming_point(\"Status data initialized\\n\");\n\t\t\t\t}\n\n\t\t\t/* initialize scheduled downtime data */\n\t\t\tinitialize_downtime_data();\n\t\t\ttiming_point(\"Downtime data initialized\\n\");\n\n\t\t\t/* read initial service and host state information  */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\ttiming_point(\"Retention data initialized\\n\");\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Initial state information read\\n\");\n\n\t\t\t/* initialize comment data */\n\t\t\tinitialize_comment_data();\n\t\t\ttiming_point(\"Comment data initialized\\n\");\n\n\t\t\t/* initialize performance data */\n\t\t\tinitialize_performance_data(config_file);\n\t\t\ttiming_point(\"Performance data initialized\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Event timing loop initialized\\n\");\n\n\t\t\t/* initialize check statistics */\n\t\t\tinit_check_stats();\n\t\t\ttiming_point(\"check stats initialized\\n\");\n\n\t\t\t/* check for updates */\n\t\t\tcheck_for_nagios_updates(FALSE, TRUE);\n\t\t\ttiming_point(\"Update check concluded\\n\");\n\n\t\t\t/* update all status data (with retained information) */\n\t\t\tupdate_all_status_data();\n\t\t\ttiming_point(\"Status data updated\\n\");\n\n\t\t\t/* log initial host and service state */\n\t\t\tlog_host_states(INITIAL_STATES, NULL);\n\t\t\tlog_service_states(INITIAL_STATES, NULL);\n\t\t\ttiming_point(\"Initial states logged\\n\");\n\n\t\t\t/* reset the restart flag */\n\t\t\tsigrestart = FALSE;\n\n\t\t\t/* fire up command file worker */\n\t\t\tlaunch_command_file_worker();\n\t\t\ttiming_point(\"Command file worker launched\\n\");\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* get event start time and save as macro */\n\t\t\tevent_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_EVENTSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_EVENTSTARTTIME], \"%llu\", (unsigned long long)event_start);\n\n\t\t\ttiming_point(\"Entering event execution loop\\n\");\n\t\t\t/***** start monitoring all services *****/\n\t\t\t/* (doesn't return until a restart or shutdown signal is encountered) */\n\t\t\tevent_execution_loop();\n\n\t\t\t/*\n\t\t\t * immediately deinitialize the query handler so it\n\t\t\t * can remove modules that have stashed data with it\n\t\t\t */\n\t\t\tqh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);\n\n\t\t\t/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */\n\t\t\t/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */\n\t\t\t/* did we catch a signal? */\n\t\t\tif(caught_signal == TRUE) {\n\n\t\t\t\tif(sig_id == SIGHUP)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Caught SIGHUP, restarting...\\n\");\n\n\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\tif(sigshutdown == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);\n\t\t\telse if(sigrestart == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);\n#endif\n\n\t\t\t/* save service and host state information */\n\t\t\tsave_state_information(FALSE);\n\t\t\tcleanup_retention_data();\n\n\t\t\t/* clean up performance data */\n\t\t\tcleanup_performance_data();\n\n\t\t\t/* clean up the scheduled downtime data */\n\t\t\tcleanup_downtime_data();\n\n\t\t\t/* clean up the status data unless we're restarting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t}\n\n\t\t\tfree_worker_memory(WPROC_FORCE);\n\t\t\t/* shutdown stuff... */\n\t\t\tif(sigshutdown == TRUE) {\n\t\t\t\tiobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);\n\t\t\t\tnagios_iobs = NULL;\n\n\t\t\t\t/* log a shutdown message */\n\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Successfully shutdown... (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* clean up after ourselves */\n\t\t\tcleanup();\n\n\t\t\t/* close debug log */\n\t\t\tclose_debug_log();\n\n\t\t\t}\n\t\twhile(sigrestart == TRUE && sigshutdown == FALSE);\n\n\t\tif(daemon_mode == TRUE)\n\t\t\tunlink(lock_file);\n\n\t\t/* free misc memory */\n\t\tmy_free(lock_file);\n\t\tmy_free(config_file);\n\t\tmy_free(config_file_dir);\n\t\tmy_free(nagios_binary_path);\n\t\t}\n\n\treturn OK;\n\t}\n",
        "label": 1
    },
    {
        "pre_patch": "pseudo_ulog( ClassAd *ad )\n{\n\tULogEvent *event = instantiateEvent(ad);\n\tint result = 0;\n\tchar const *critical_error = NULL;\n\tMyString CriticalErrorBuf;\n\tbool event_already_logged = false;\n\tbool put_job_on_hold = false;\n\tchar const *hold_reason = NULL;\n\tchar *hold_reason_buf = NULL;\n\tint hold_reason_code = 0;\n\tint hold_reason_sub_code = 0;\n\n\tif(!event) {\n\t\tMyString add_str;\n\t\tad->sPrint(add_str);\n\t\tdprintf(\n\t\t  D_ALWAYS,\n\t\t  \"invalid event ClassAd in pseudo_ulog: %s\\n\",\n\t\t  add_str.Value());\n\t\treturn -1;\n\t}\n\n\tif(ad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code)) {\n\t\tput_job_on_hold = true;\n\t\tad->LookupInteger(ATTR_HOLD_REASON_SUBCODE,hold_reason_sub_code);\n\t\tad->LookupString(ATTR_HOLD_REASON,&hold_reason_buf);\n\t\tif(hold_reason_buf) {\n\t\t\thold_reason = hold_reason_buf;\n\t\t}\n\t}\n\n\tif( event->eventNumber == ULOG_REMOTE_ERROR ) {\n\t\tRemoteErrorEvent *err = (RemoteErrorEvent *)event;\n\n\t\tif(!err->getExecuteHost() || !*err->getExecuteHost()) {\n\t\t\tchar *execute_host = NULL;\n\t\t\tthisRemoteResource->getMachineName(execute_host);\n\t\t\terr->setExecuteHost(execute_host);\n\t\t\tdelete[] execute_host;\n\t\t}\n\n\t\tif(err->isCriticalError()) {\n\t\t\tCriticalErrorBuf.sprintf(\n\t\t\t  \"Error from %s: %s\",\n\t\t\t  err->getExecuteHost(),\n\t\t\t  err->getErrorText());\n\n\t\t\tcritical_error = CriticalErrorBuf.Value();\n\t\t\tif(!hold_reason) {\n\t\t\t\thold_reason = critical_error;\n\t\t\t}\n\n\t\t\tBaseShadow::log_except(critical_error);\n\t\t\tevent_already_logged = true;\n\t\t}\n\t}\n\n\tif( !event_already_logged && !Shadow->uLog.writeEvent( event, ad ) ) {\n\t\tMyString add_str;\n\t\tad->sPrint(add_str);\n\t\tdprintf(\n\t\t  D_ALWAYS,\n\t\t  \"unable to log event in pseudo_ulog: %s\\n\",\n\t\t  add_str.Value());\n\t\tresult = -1;\n\t}\n\n\tif(put_job_on_hold) {\n\t\thold_reason = critical_error;\n\t\tif(!hold_reason) {\n\t\t\thold_reason = \"Job put on hold by remote host.\";\n\t\t}\n\t\tShadow->holdJobAndExit(hold_reason,hold_reason_code,hold_reason_sub_code);\n\t}\n\n\tif( critical_error ) {\n                Shadow->exception_already_logged = true;\n \n               EXCEPT(critical_error);\n        }\n \n        delete event;\n\treturn result;\n}\n",
        "post_patch": "pseudo_ulog( ClassAd *ad )\n{\n\tULogEvent *event = instantiateEvent(ad);\n\tint result = 0;\n\tchar const *critical_error = NULL;\n\tMyString CriticalErrorBuf;\n\tbool event_already_logged = false;\n\tbool put_job_on_hold = false;\n\tchar const *hold_reason = NULL;\n\tchar *hold_reason_buf = NULL;\n\tint hold_reason_code = 0;\n\tint hold_reason_sub_code = 0;\n\n\tif(!event) {\n\t\tMyString add_str;\n\t\tad->sPrint(add_str);\n\t\tdprintf(\n\t\t  D_ALWAYS,\n\t\t  \"invalid event ClassAd in pseudo_ulog: %s\\n\",\n\t\t  add_str.Value());\n\t\treturn -1;\n\t}\n\n\tif(ad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code)) {\n\t\tput_job_on_hold = true;\n\t\tad->LookupInteger(ATTR_HOLD_REASON_SUBCODE,hold_reason_sub_code);\n\t\tad->LookupString(ATTR_HOLD_REASON,&hold_reason_buf);\n\t\tif(hold_reason_buf) {\n\t\t\thold_reason = hold_reason_buf;\n\t\t}\n\t}\n\n\tif( event->eventNumber == ULOG_REMOTE_ERROR ) {\n\t\tRemoteErrorEvent *err = (RemoteErrorEvent *)event;\n\n\t\tif(!err->getExecuteHost() || !*err->getExecuteHost()) {\n\t\t\tchar *execute_host = NULL;\n\t\t\tthisRemoteResource->getMachineName(execute_host);\n\t\t\terr->setExecuteHost(execute_host);\n\t\t\tdelete[] execute_host;\n\t\t}\n\n\t\tif(err->isCriticalError()) {\n\t\t\tCriticalErrorBuf.sprintf(\n\t\t\t  \"Error from %s: %s\",\n\t\t\t  err->getExecuteHost(),\n\t\t\t  err->getErrorText());\n\n\t\t\tcritical_error = CriticalErrorBuf.Value();\n\t\t\tif(!hold_reason) {\n\t\t\t\thold_reason = critical_error;\n\t\t\t}\n\n\t\t\tBaseShadow::log_except(critical_error);\n\t\t\tevent_already_logged = true;\n\t\t}\n\t}\n\n\tif( !event_already_logged && !Shadow->uLog.writeEvent( event, ad ) ) {\n\t\tMyString add_str;\n\t\tad->sPrint(add_str);\n\t\tdprintf(\n\t\t  D_ALWAYS,\n\t\t  \"unable to log event in pseudo_ulog: %s\\n\",\n\t\t  add_str.Value());\n\t\tresult = -1;\n\t}\n\n\tif(put_job_on_hold) {\n\t\thold_reason = critical_error;\n\t\tif(!hold_reason) {\n\t\t\thold_reason = \"Job put on hold by remote host.\";\n\t\t}\n\t\tShadow->holdJobAndExit(hold_reason,hold_reason_code,hold_reason_sub_code);\n\t}\n\n\tif( critical_error ) {\n                Shadow->exception_already_logged = true;\n \n               EXCEPT(\"%s\", critical_error);\n        }\n \n        delete event;\n\treturn result;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static bool trap_debug32(struct kvm_vcpu *vcpu,\n\t\t\t struct sys_reg_params *p,\n\t\t\t const struct sys_reg_desc *r)\n{\n\tif (p->is_write) {\n\t\tvcpu_cp14(vcpu, r->reg) = p->regval;\n\t\tvcpu->arch.debug_flags |= KVM_ARM64_DEBUG_DIRTY;\n\t} else {\n\t\tp->regval = vcpu_cp14(vcpu, r->reg);\n\t}\n\n\treturn true;\n}\n",
        "post_patch": "static bool trap_debug32(struct kvm_vcpu *vcpu,\n\t\t\t struct sys_reg_params *p,\n\t\t\t const struct sys_reg_desc *r)\n{\n\tif (p->is_write) {\n\t\tvcpu_cp14(vcpu, r->reg) = p->regval;\n\t\tvcpu->arch.debug_flags |= KVM_ARM64_DEBUG_DIRTY;\n\t} else {\n\t\tp->regval = vcpu_cp14(vcpu, r->reg);\n\t}\n\n\treturn true;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "base::trace_event::TraceConfig GetBackgroundTracingConfig() {\n  base::trace_event::TraceConfig trace_config(\n      \"-*,disabled-by-default-memory-infra\",\n      base::trace_event::RECORD_UNTIL_FULL);\n\n  trace_config.EnableArgumentFilter();\n\n  base::trace_event::TraceConfig::MemoryDumpConfig memory_config;\n  memory_config.allowed_dump_modes.insert(\n      base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND);\n  base::trace_event::TraceConfig::MemoryDumpConfig::Trigger trigger;\n  trigger.min_time_between_dumps_ms = 1 << 30;\n  trigger.level_of_detail =\n      base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND;\n  trigger.trigger_type = base::trace_event::MemoryDumpType::PERIODIC_INTERVAL;\n  memory_config.triggers.clear();\n  memory_config.triggers.push_back(trigger);\n  trace_config.ResetMemoryDumpConfig(memory_config);\n  return trace_config;\n}\n",
        "post_patch": "base::trace_event::TraceConfig GetBackgroundTracingConfig() {\n  base::trace_event::TraceConfig trace_config(\n      \"-*,disabled-by-default-memory-infra\",\n      base::trace_event::RECORD_UNTIL_FULL);\n\n  trace_config.EnableArgumentFilter();\n\n  base::trace_event::TraceConfig::MemoryDumpConfig memory_config;\n  memory_config.allowed_dump_modes.insert(\n      base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND);\n  base::trace_event::TraceConfig::MemoryDumpConfig::Trigger trigger;\n  trigger.min_time_between_dumps_ms = 1 << 30;\n  trigger.level_of_detail =\n      base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND;\n  trigger.trigger_type = base::trace_event::MemoryDumpType::PERIODIC_INTERVAL;\n  memory_config.triggers.clear();\n  memory_config.triggers.push_back(trigger);\n  trace_config.ResetMemoryDumpConfig(memory_config);\n  return trace_config;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static void blk_mq_queue_exit(struct request_queue *q)\n{\n\tpercpu_ref_put(&q->mq_usage_counter);\n}\n",
        "post_patch": "static void blk_mq_queue_exit(struct request_queue *q)\n{\n\tpercpu_ref_put(&q->mq_usage_counter);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "String Document::domain() const {\n  return GetSecurityOrigin()->Domain();\n}\n",
        "post_patch": "String Document::domain() const {\n  return GetSecurityOrigin()->Domain();\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n",
        "post_patch": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)\n\n {\n     ALOGV(\"setDataSource\");\n     status_t err = UNKNOWN_ERROR;\n    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(source))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n",
        "post_patch": "status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)\n\n {\n     ALOGV(\"setDataSource\");\n     status_t err = UNKNOWN_ERROR;\n    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(source))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "find_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n",
        "post_patch": "find_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "srpt_set_ch_state(struct srpt_rdma_ch *ch, enum rdma_ch_state new_state)\n{\n\tunsigned long flags;\n\tenum rdma_ch_state prev;\n\n\tspin_lock_irqsave(&ch->spinlock, flags);\n\tprev = ch->state;\n\tch->state = new_state;\n\tspin_unlock_irqrestore(&ch->spinlock, flags);\n\treturn prev;\n}\n",
        "post_patch": "srpt_set_ch_state(struct srpt_rdma_ch *ch, enum rdma_ch_state new_state)\n{\n\tunsigned long flags;\n\tenum rdma_ch_state prev;\n\n\tspin_lock_irqsave(&ch->spinlock, flags);\n\tprev = ch->state;\n\tch->state = new_state;\n\tspin_unlock_irqrestore(&ch->spinlock, flags);\n\treturn prev;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n \tstruct socket *ssocket = server->ssocket;\n \tint val = 1;\n \n \tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n \tdump_smb(iov[0].iov_base, iov[0].iov_len);\n \n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}\n",
        "post_patch": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n \tstruct socket *ssocket = server->ssocket;\n \tint val = 1;\n \n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n \tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n \tdump_smb(iov[0].iov_base, iov[0].iov_len);\n \n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
        "post_patch": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "ScriptProcessorHandler::ScriptProcessorHandler(\n    AudioNode& node,\n    float sample_rate,\n    size_t buffer_size,\n    unsigned number_of_input_channels,\n    unsigned number_of_output_channels)\n    : AudioHandler(kNodeTypeScriptProcessor, node, sample_rate),\n      double_buffer_index_(0),\n      buffer_size_(buffer_size),\n      buffer_read_write_index_(0),\n      number_of_input_channels_(number_of_input_channels),\n      number_of_output_channels_(number_of_output_channels),\n      internal_input_bus_(AudioBus::Create(number_of_input_channels,\n                                           AudioUtilities::kRenderQuantumFrames,\n                                           false)) {\n  if (buffer_size_ < AudioUtilities::kRenderQuantumFrames)\n    buffer_size_ = AudioUtilities::kRenderQuantumFrames;\n\n  DCHECK_LE(number_of_input_channels, BaseAudioContext::MaxNumberOfChannels());\n\n  AddInput();\n  AddOutput(number_of_output_channels);\n\n  channel_count_ = number_of_input_channels;\n  SetInternalChannelCountMode(kExplicit);\n\n  Initialize();\n}\n",
        "post_patch": "ScriptProcessorHandler::ScriptProcessorHandler(\n    AudioNode& node,\n    float sample_rate,\n    size_t buffer_size,\n    unsigned number_of_input_channels,\n    unsigned number_of_output_channels)\n    : AudioHandler(kNodeTypeScriptProcessor, node, sample_rate),\n      double_buffer_index_(0),\n      buffer_size_(buffer_size),\n      buffer_read_write_index_(0),\n      number_of_input_channels_(number_of_input_channels),\n      number_of_output_channels_(number_of_output_channels),\n      internal_input_bus_(AudioBus::Create(number_of_input_channels,\n                                           AudioUtilities::kRenderQuantumFrames,\n                                           false)) {\n  if (buffer_size_ < AudioUtilities::kRenderQuantumFrames)\n    buffer_size_ = AudioUtilities::kRenderQuantumFrames;\n\n  DCHECK_LE(number_of_input_channels, BaseAudioContext::MaxNumberOfChannels());\n\n  AddInput();\n  AddOutput(number_of_output_channels);\n\n  channel_count_ = number_of_input_channels;\n  SetInternalChannelCountMode(kExplicit);\n\n  Initialize();\n}\n",
        "label": 0
    },
    {
        "pre_patch": "namecmp(const void *key, const void *name)\n{\n\treturn strcmp((char *)key, *(char **)name);\n}\n",
        "post_patch": "namecmp(const void *key, const void *name)\n{\n\treturn strcmp((char *)key, *(char **)name);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "kex_input_newkeys(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tdebug(\"SSH2_MSG_NEWKEYS received\");\n \tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);\n \tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\treturn r;\n \tkex->done = 1;\n \tsshbuf_reset(kex->peer);\n \t/* sshbuf_reset(kex->my); */\n\tkex->name = NULL;\n\treturn 0;\n}\n",
        "post_patch": "kex_input_newkeys(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tdebug(\"SSH2_MSG_NEWKEYS received\");\n \tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);\n \tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\treturn r;\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)\n\t\treturn r;\n \tkex->done = 1;\n \tsshbuf_reset(kex->peer);\n \t/* sshbuf_reset(kex->my); */\n\tkex->name = NULL;\n\treturn 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n \n \t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n \n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n \n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n \n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \n\t/* filesystem's fallocate may need to take i_mutex */\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }\n",
        "post_patch": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n\tstruct file *f;\n \n \t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n \n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n \n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n \n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \n\t/*\n\t * Filesystem's fallocate may need to take i_mutex.  We need to\n\t * explicitly grab a reference because the vma (and hence the\n\t * vma's reference to the file) can go away as soon as we drop\n\t * mmap_sem.\n\t */\n\tget_file(f);\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(f,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n\tfput(f);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int klv_read_packet(KLVPacket *klv, AVIOContext *pb)\n{\n    if (!mxf_read_sync(pb, mxf_klv_key, 4))\n        return AVERROR_INVALIDDATA;\n    klv->offset = avio_tell(pb) - 4;\n    memcpy(klv->key, mxf_klv_key, 4);\n    avio_read(pb, klv->key + 4, 12);\n    klv->length = klv_decode_ber_length(pb);\n    return klv->length == -1 ? -1 : 0;\n}\n",
        "post_patch": "static int klv_read_packet(KLVPacket *klv, AVIOContext *pb)\n{\n    if (!mxf_read_sync(pb, mxf_klv_key, 4))\n        return AVERROR_INVALIDDATA;\n    klv->offset = avio_tell(pb) - 4;\n    memcpy(klv->key, mxf_klv_key, 4);\n    avio_read(pb, klv->key + 4, 12);\n    klv->length = klv_decode_ber_length(pb);\n    return klv->length == -1 ? -1 : 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}\n",
        "post_patch": "unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static size_t ZSTD_encodeSequences(\n            void* dst, size_t dstCapacity,\n            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\n            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\n             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n             seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)\n {\n #if DYNAMIC_BMI2\n     if (bmi2) {\n         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,\n                                         CTable_MatchLength, mlCodeTable,\n                                         CTable_OffsetBits, ofCodeTable,\n                                         CTable_LitLength, llCodeTable,\n                                         sequences, nbSeq, longOffsets);\n    }\n#endif\n    (void)bmi2;\n    return ZSTD_encodeSequences_default(dst, dstCapacity,\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq, longOffsets);\n}\n",
        "post_patch": "static size_t ZSTD_encodeSequences(\n            void* dst, size_t dstCapacity,\n            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\n            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\n             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n             seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)\n {\n    DEBUGLOG(5, \"ZSTD_encodeSequences: dstCapacity = %u\", (unsigned)dstCapacity);\n #if DYNAMIC_BMI2\n     if (bmi2) {\n         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,\n                                         CTable_MatchLength, mlCodeTable,\n                                         CTable_OffsetBits, ofCodeTable,\n                                         CTable_LitLength, llCodeTable,\n                                         sequences, nbSeq, longOffsets);\n    }\n#endif\n    (void)bmi2;\n    return ZSTD_encodeSequences_default(dst, dstCapacity,\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq, longOffsets);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n \t{\n \t\tfprintf(stderr, \"client authentication failure\\n\");\n \t\tcredssp_free(transport->credssp);\n \t\treturn FALSE;\n \t}\n \n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}\n",
        "post_patch": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n \t{\n \t\tfprintf(stderr, \"client authentication failure\\n\");\n \t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "  explicit RegisteringObject(ObjectRegistry* registry)\n      : RegisteringMixin(registry) {}\n",
        "post_patch": "  explicit RegisteringObject(ObjectRegistry* registry)\n      : RegisteringMixin(registry) {}\n",
        "label": 0
    },
    {
        "pre_patch": "int tls_get_message_header(SSL *s, int *mt)\n{\n    /* s->init_num < SSL3_HM_HEADER_LENGTH */\n    int skip_message, i, recvd_type, al;\n    unsigned char *p;\n    unsigned long l;\n\n    p = (unsigned char *)s->init_buf->data;\n\n    do {\n        while (s->init_num < SSL3_HM_HEADER_LENGTH) {\n            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type,\n                                          &p[s->init_num],\n                                          SSL3_HM_HEADER_LENGTH - s->init_num,\n                                          0);\n            if (i <= 0) {\n                s->rwstate = SSL_READING;\n                return 0;\n            }\n            if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n                /*\n                 * A ChangeCipherSpec must be a single byte and may not occur\n                 * in the middle of a handshake message.\n                 */\n                if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) {\n                    al = SSL_AD_UNEXPECTED_MESSAGE;\n                    SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER,\n                           SSL_R_BAD_CHANGE_CIPHER_SPEC);\n                    goto f_err;\n                }\n                s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC;\n                s->init_num = i - 1;\n                s->s3->tmp.message_size = i;\n                return 1;\n            } else if (recvd_type != SSL3_RT_HANDSHAKE) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY);\n                goto f_err;\n            }\n            s->init_num += i;\n        }\n\n        skip_message = 0;\n        if (!s->server)\n            if (p[0] == SSL3_MT_HELLO_REQUEST)\n                /*\n                 * The server may always send 'Hello Request' messages --\n                 * we are doing a handshake anyway now, so ignore them if\n                 * their format is correct. Does not count for 'Finished'\n                 * MAC.\n                 */\n                if (p[1] == 0 && p[2] == 0 && p[3] == 0) {\n                    s->init_num = 0;\n                    skip_message = 1;\n\n                    if (s->msg_callback)\n                        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                                        p, SSL3_HM_HEADER_LENGTH, s,\n                                        s->msg_callback_arg);\n                }\n    } while (skip_message);\n    /* s->init_num == SSL3_HM_HEADER_LENGTH */\n\n    *mt = *p;\n    s->s3->tmp.message_type = *(p++);\n\n    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {\n        /*\n         * Only happens with SSLv3+ in an SSLv2 backward compatible\n         * ClientHello\n         *\n         * Total message size is the remaining record bytes to read\n         * plus the SSL3_HM_HEADER_LENGTH bytes that we already read\n          */\n         l = RECORD_LAYER_get_rrec_length(&s->rlayer)\n             + SSL3_HM_HEADER_LENGTH;\n        if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) {\n            SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);\n            goto err;\n        }\n         s->s3->tmp.message_size = l;\n \n         s->init_msg = s->init_buf->data;\n        }\n        s->s3->tmp.message_size = l;\n\n        s->init_msg = s->init_buf->data;\n        s->init_num = SSL3_HM_HEADER_LENGTH;\n    } else {\n             SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n             goto f_err;\n         }\n",
        "post_patch": "int tls_get_message_header(SSL *s, int *mt)\n{\n    /* s->init_num < SSL3_HM_HEADER_LENGTH */\n    int skip_message, i, recvd_type, al;\n    unsigned char *p;\n    unsigned long l;\n\n    p = (unsigned char *)s->init_buf->data;\n\n    do {\n        while (s->init_num < SSL3_HM_HEADER_LENGTH) {\n            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type,\n                                          &p[s->init_num],\n                                          SSL3_HM_HEADER_LENGTH - s->init_num,\n                                          0);\n            if (i <= 0) {\n                s->rwstate = SSL_READING;\n                return 0;\n            }\n            if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n                /*\n                 * A ChangeCipherSpec must be a single byte and may not occur\n                 * in the middle of a handshake message.\n                 */\n                if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) {\n                    al = SSL_AD_UNEXPECTED_MESSAGE;\n                    SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER,\n                           SSL_R_BAD_CHANGE_CIPHER_SPEC);\n                    goto f_err;\n                }\n                s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC;\n                s->init_num = i - 1;\n                s->s3->tmp.message_size = i;\n                return 1;\n            } else if (recvd_type != SSL3_RT_HANDSHAKE) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY);\n                goto f_err;\n            }\n            s->init_num += i;\n        }\n\n        skip_message = 0;\n        if (!s->server)\n            if (p[0] == SSL3_MT_HELLO_REQUEST)\n                /*\n                 * The server may always send 'Hello Request' messages --\n                 * we are doing a handshake anyway now, so ignore them if\n                 * their format is correct. Does not count for 'Finished'\n                 * MAC.\n                 */\n                if (p[1] == 0 && p[2] == 0 && p[3] == 0) {\n                    s->init_num = 0;\n                    skip_message = 1;\n\n                    if (s->msg_callback)\n                        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                                        p, SSL3_HM_HEADER_LENGTH, s,\n                                        s->msg_callback_arg);\n                }\n    } while (skip_message);\n    /* s->init_num == SSL3_HM_HEADER_LENGTH */\n\n    *mt = *p;\n    s->s3->tmp.message_type = *(p++);\n\n    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {\n        /*\n         * Only happens with SSLv3+ in an SSLv2 backward compatible\n         * ClientHello\n         *\n         * Total message size is the remaining record bytes to read\n         * plus the SSL3_HM_HEADER_LENGTH bytes that we already read\n          */\n         l = RECORD_LAYER_get_rrec_length(&s->rlayer)\n             + SSL3_HM_HEADER_LENGTH;\n         s->s3->tmp.message_size = l;\n \n         s->init_msg = s->init_buf->data;\n        }\n        s->s3->tmp.message_size = l;\n\n        s->init_msg = s->init_buf->data;\n        s->init_num = SSL3_HM_HEADER_LENGTH;\n    } else {\n             SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n             goto f_err;\n         }\n",
        "label": 1
    },
    {
        "pre_patch": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp.name[sizeof(tmp.name)-1] = 0;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}\n",
        "post_patch": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp.name[sizeof(tmp.name)-1] = 0;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }\n",
        "post_patch": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n \n \treturn 0;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int __init xfrm6_tunnel_init(void)\n {\n \tint rv;\n \n \trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n \tif (rv < 0)\n\t\tgoto err;\n \trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n \tif (rv < 0)\n\t\tgoto unreg;\n \trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n \tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n \treturn 0;\n \nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n \txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n \txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n \treturn rv;\n }\n",
        "post_patch": "static int __init xfrm6_tunnel_init(void)\n {\n \tint rv;\n \n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto out_pernet;\n \trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n \tif (rv < 0)\n\t\tgoto out_type;\n \trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n \tif (rv < 0)\n\t\tgoto out_xfrm6;\n \trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n \tif (rv < 0)\n\t\tgoto out_xfrm46;\n \treturn 0;\n \nout_xfrm46:\n \txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nout_xfrm6:\n \txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nout_type:\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\nout_pernet:\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n \treturn rv;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n \n   (*re_ast)->flags = 0;\n   (*re_ast)->root_node = NULL;\n \n   return ERROR_SUCCESS;\n}\n",
        "post_patch": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n \n   (*re_ast)->flags = 0;\n  (*re_ast)->levels = 0;\n   (*re_ast)->root_node = NULL;\n \n   return ERROR_SUCCESS;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n \n    FreeStmt((ParseCommon *) &append);\n \n     return expr;\n }\n",
        "post_patch": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n \n    FreeStmt((ParseCommon *) append);\n \n     return expr;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[8] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (child->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t\t    child->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[8];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx->%016llx-?->%016llx \"\n\t\t\t\t\t    \"diverges from subtractive \"\n\t\t\t\t\t    \"boundary %016llx\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t\t    SAS_ADDR(s2),\n\t\t\t\t\t    SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "post_patch": "static int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[8] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (child->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t\t    child->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[8];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx->%016llx-?->%016llx \"\n\t\t\t\t\t    \"diverges from subtractive \"\n\t\t\t\t\t    \"boundary %016llx\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t\t    SAS_ADDR(s2),\n\t\t\t\t\t    SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static void release_tty(struct tty_struct *tty, int idx)\n{\n\t/* This should always be true but check for the moment */\n\tWARN_ON(tty->index != idx);\n\tWARN_ON(!mutex_is_locked(&tty_mutex));\n\tif (tty->ops->shutdown)\n\t\ttty->ops->shutdown(tty);\n\ttty_free_termios(tty);\n\ttty_driver_remove_tty(tty->driver, tty);\n\ttty->port->itty = NULL;\n\tif (tty->link)\n\t\ttty->link->port->itty = NULL;\n\ttty_buffer_cancel_work(tty->port);\n\n\ttty_kref_put(tty->link);\n\ttty_kref_put(tty);\n}\n",
        "post_patch": "static void release_tty(struct tty_struct *tty, int idx)\n{\n\t/* This should always be true but check for the moment */\n\tWARN_ON(tty->index != idx);\n\tWARN_ON(!mutex_is_locked(&tty_mutex));\n\tif (tty->ops->shutdown)\n\t\ttty->ops->shutdown(tty);\n\ttty_free_termios(tty);\n\ttty_driver_remove_tty(tty->driver, tty);\n\ttty->port->itty = NULL;\n\tif (tty->link)\n\t\ttty->link->port->itty = NULL;\n\ttty_buffer_cancel_work(tty->port);\n\n\ttty_kref_put(tty->link);\n\ttty_kref_put(tty);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "pdf_copy_gstate(fz_context *ctx, pdf_gstate *gs, pdf_gstate *old)\n{\n\tpdf_drop_gstate(ctx, gs);\n\t*gs = *old;\n\tpdf_keep_gstate(ctx, gs);\n}\n",
        "post_patch": "pdf_copy_gstate(fz_context *ctx, pdf_gstate *gs, pdf_gstate *old)\n{\n\tpdf_drop_gstate(ctx, gs);\n\t*gs = *old;\n\tpdf_keep_gstate(ctx, gs);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void RenderFrameImpl::DidObserveLoadingBehavior(\n    blink::WebLoadingBehaviorFlag behavior) {\n  for (auto& observer : observers_)\n    observer.DidObserveLoadingBehavior(behavior);\n}\n",
        "post_patch": "void RenderFrameImpl::DidObserveLoadingBehavior(\n    blink::WebLoadingBehaviorFlag behavior) {\n  for (auto& observer : observers_)\n    observer.DidObserveLoadingBehavior(behavior);\n}\n",
        "label": 0
    },
    {
        "pre_patch": " void TabletModeWindowManager::ArrangeWindowsForClamshellMode(\n    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview) {\n   int divider_position = CalculateCarryOverDividerPostion(windows_in_splitview);\n \n   while (window_state_map_.size()) {\n     aura::Window* window = window_state_map_.begin()->first;\n    ForgetWindow(window, /*destroyed=*/false);\n   }\n \n   if (IsClamshellSplitViewModeEnabled()) {\n    DoSplitViewTransition(windows_in_splitview, divider_position);\n  }\n}\n",
        "post_patch": " void TabletModeWindowManager::ArrangeWindowsForClamshellMode(\n    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview,\n    bool was_in_overview) {\n   int divider_position = CalculateCarryOverDividerPostion(windows_in_splitview);\n \n   while (window_state_map_.size()) {\n     aura::Window* window = window_state_map_.begin()->first;\n    ForgetWindow(window, /*destroyed=*/false, was_in_overview);\n   }\n \n   if (IsClamshellSplitViewModeEnabled()) {\n    DoSplitViewTransition(windows_in_splitview, divider_position);\n  }\n}\n",
        "label": 1
    },
    {
        "pre_patch": " static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n {\n\tchar *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \t/* FIXME: string-size_t */\n \tunsigned int new_vlen;\n\n\tif (var->ptr >= var->end) {\n \t\treturn 0;\n \t}\n \n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n \tif (!vsep) {\n \t\tif (!eof) {\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t/* \"foo=bar&\" or \"foo=&\" */\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t/* \"foo&\" */\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n \tefree(val);\n \n \tvar->ptr = vsep + (vsep != var->end);\n \treturn 1;\n }\n",
        "post_patch": " static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n {\n\tchar *start, *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \t/* FIXME: string-size_t */\n \tunsigned int new_vlen;\n\n\tif (var->ptr >= var->end) {\n \t\treturn 0;\n \t}\n \n\tstart = var->ptr + var->already_scanned;\n\tvsep = memchr(start, '&', var->end - start);\n \tif (!vsep) {\n \t\tif (!eof) {\n\t\t\tvar->already_scanned = var->end - var->ptr;\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t/* \"foo=bar&\" or \"foo=&\" */\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t/* \"foo&\" */\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n \tefree(val);\n \n \tvar->ptr = vsep + (vsep != var->end);\n\tvar->already_scanned = 0;\n \treturn 1;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "AudioOutputDevice::AudioOutputDevice(\n    AudioOutputIPC* ipc,\n    const scoped_refptr<base::MessageLoopProxy>& io_loop)\n    : ScopedLoopObserver(io_loop),\n      input_channels_(0),\n      callback_(NULL),\n       ipc_(ipc),\n       stream_id_(0),\n       play_on_start_(true),\n      is_started_(false),\n      audio_thread_(new AudioDeviceThread()) {\n   CHECK(ipc_);\n }\n",
        "post_patch": "AudioOutputDevice::AudioOutputDevice(\n    AudioOutputIPC* ipc,\n    const scoped_refptr<base::MessageLoopProxy>& io_loop)\n    : ScopedLoopObserver(io_loop),\n      input_channels_(0),\n      callback_(NULL),\n       ipc_(ipc),\n       stream_id_(0),\n       play_on_start_(true),\n      is_started_(false) {\n   CHECK(ipc_);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,\n                              ZSTD_entropyCTables_t const* prevEntropy,\n                              ZSTD_entropyCTables_t* nextEntropy,\n                              ZSTD_CCtx_params const* cctxParams,\n                              void* dst, size_t dstCapacity,\n                              void* workspace, size_t wkspSize,\n                              const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    U32 count[MaxSeq+1];\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    U32 LLtype, Offtype, MLtype;   /* compressed, raw or rle */\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    BYTE* seqHead;\n    BYTE* lastNCount = NULL;\n\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const litSize = seqStorePtr->lit - literals;\n        int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy, disableLiteralCompression,\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    workspace, wkspSize,\n                                    bmi2);\n        if (ZSTD_isError(cSize))\n          return cSize;\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    if ((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/) return ERROR(dstSize_tooSmall);\n    if (nbSeq < 0x7F)\n        *op++ = (BYTE)nbSeq;\n    else if (nbSeq < LONGNBSEQ)\n        op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;\n    else\n        op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return op - ostart;\n    }\n\n    /* seqHead : flags for FSE encoding type */\n    seqHead = op++;\n\n    /* convert length/distances into codes */\n    ZSTD_seqToCodes(seqStorePtr);\n    /* build CTable for Literal Lengths */\n    {   U32 max = MaxLL;\n        size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building LL table\");\n        nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;\n        LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);\n        assert(set_basic < set_compressed && set_rle < set_compressed);\n        assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,\n                                                    count, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                                                    prevEntropy->fse.litlengthCTable, sizeof(prevEntropy->fse.litlengthCTable),\n                                                    workspace, wkspSize);\n            if (ZSTD_isError(countSize)) return countSize;\n            if (LLtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n    }   }\n    /* build CTable for Offsets */\n    {   U32 max = MaxOff;\n        size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);  /* can't fail */\n        /* We can only use the basic table if max <= DefaultMaxOff, otherwise the offsets are too large */\n        ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;\n        DEBUGLOG(5, \"Building OF table\");\n        nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;\n        Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);\n        assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,\n                                                    count, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                                                    prevEntropy->fse.offcodeCTable, sizeof(prevEntropy->fse.offcodeCTable),\n                                                    workspace, wkspSize);\n            if (ZSTD_isError(countSize)) return countSize;\n            if (Offtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n    }   }\n     /* build CTable for MatchLengths */\n     {   U32 max = MaxML;\n         size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building ML table\");\n         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;\n         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);\n         assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,\n                                                    count, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,\n                                                    prevEntropy->fse.matchlengthCTable, sizeof(prevEntropy->fse.matchlengthCTable),\n                                                    workspace, wkspSize);\n            if (ZSTD_isError(countSize)) return countSize;\n            if (MLtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n    }   }\n\n    *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, oend - op,\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        if (ZSTD_isError(bitstreamSize)) return bitstreamSize;\n        op += bitstreamSize;\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() recieves a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastNCount && (op - lastNCount) < 4) {\n            /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(op - lastNCount == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    return op - ostart;\n}\n",
        "post_patch": "ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,\n                              ZSTD_entropyCTables_t const* prevEntropy,\n                              ZSTD_entropyCTables_t* nextEntropy,\n                              ZSTD_CCtx_params const* cctxParams,\n                              void* dst, size_t dstCapacity,\n                              void* workspace, size_t wkspSize,\n                              const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    U32 count[MaxSeq+1];\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    U32 LLtype, Offtype, MLtype;   /* compressed, raw or rle */\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    BYTE* seqHead;\n    BYTE* lastNCount = NULL;\n\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const litSize = seqStorePtr->lit - literals;\n        int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy, disableLiteralCompression,\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    workspace, wkspSize,\n                                    bmi2);\n        if (ZSTD_isError(cSize))\n          return cSize;\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    if ((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/) return ERROR(dstSize_tooSmall);\n    if (nbSeq < 0x7F)\n        *op++ = (BYTE)nbSeq;\n    else if (nbSeq < LONGNBSEQ)\n        op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;\n    else\n        op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return op - ostart;\n    }\n\n    /* seqHead : flags for FSE encoding type */\n    seqHead = op++;\n\n    /* convert length/distances into codes */\n    ZSTD_seqToCodes(seqStorePtr);\n    /* build CTable for Literal Lengths */\n    {   U32 max = MaxLL;\n        size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building LL table\");\n        nextEntropy->fse.litlength_repeatMode = prevEntropy->fse.litlength_repeatMode;\n        LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);\n        assert(set_basic < set_compressed && set_rle < set_compressed);\n        assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,\n                                                    count, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                                                    prevEntropy->fse.litlengthCTable, sizeof(prevEntropy->fse.litlengthCTable),\n                                                    workspace, wkspSize);\n            if (ZSTD_isError(countSize)) return countSize;\n            if (LLtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n    }   }\n    /* build CTable for Offsets */\n    {   U32 max = MaxOff;\n        size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);  /* can't fail */\n        /* We can only use the basic table if max <= DefaultMaxOff, otherwise the offsets are too large */\n        ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;\n        DEBUGLOG(5, \"Building OF table\");\n        nextEntropy->fse.offcode_repeatMode = prevEntropy->fse.offcode_repeatMode;\n        Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);\n        assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,\n                                                    count, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                                                    prevEntropy->fse.offcodeCTable, sizeof(prevEntropy->fse.offcodeCTable),\n                                                    workspace, wkspSize);\n            if (ZSTD_isError(countSize)) return countSize;\n            if (Offtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n    }   }\n     /* build CTable for MatchLengths */\n     {   U32 max = MaxML;\n         size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building ML table (remaining space : %i)\", (int)(oend-op));\n         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;\n         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);\n         assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,\n                                                    count, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,\n                                                    prevEntropy->fse.matchlengthCTable, sizeof(prevEntropy->fse.matchlengthCTable),\n                                                    workspace, wkspSize);\n            if (ZSTD_isError(countSize)) return countSize;\n            if (MLtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n    }   }\n\n    *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, oend - op,\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        if (ZSTD_isError(bitstreamSize)) return bitstreamSize;\n        op += bitstreamSize;\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() recieves a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastNCount && (op - lastNCount) < 4) {\n            /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(op - lastNCount == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    return op - ostart;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void spl_ptr_llist_zval_ctor(spl_ptr_llist_element *elem) { /* {{{ */\n\tif (Z_REFCOUNTED(elem->data)) {\n\t\tZ_ADDREF(elem->data);\n\t}\n}\n/* }}} */\n",
        "post_patch": "static void spl_ptr_llist_zval_ctor(spl_ptr_llist_element *elem) { /* {{{ */\n\tif (Z_REFCOUNTED(elem->data)) {\n\t\tZ_ADDREF(elem->data);\n\t}\n}\n/* }}} */\n",
        "label": 0
    },
    {
        "pre_patch": "static inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n",
        "post_patch": "static inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "HistogramBase* Histogram::Factory::Build() {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);\n  if (!histogram) {\n    const BucketRanges* created_ranges = CreateRanges();\n    const BucketRanges* registered_ranges =\n        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);\n\n    if (bucket_count_ == 0) {\n      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());\n      minimum_ = registered_ranges->range(1);\n      maximum_ = registered_ranges->range(bucket_count_ - 1);\n    }\n\n    PersistentHistogramAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          histogram_type_,\n          name_,\n          minimum_,\n          maximum_,\n          registered_ranges,\n          flags_,\n          &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  // Should never have been set.\n      DCHECK(!allocator);  // Shouldn't have failed.\n      flags_ &= ~HistogramBase::kIsPersistent;\n      tentative_histogram = HeapAlloc(registered_ranges);\n      tentative_histogram->SetFlags(flags_);\n    }\n\n    FillHistogram(tentative_histogram.get());\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n   if (bucket_count_ != 0 &&\n       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {\n    DLOG(ERROR) << \"Histogram \" << name_ << \" has bad construction arguments\";\n    return nullptr;\n  }\n  return histogram;\n}\n",
        "post_patch": "HistogramBase* Histogram::Factory::Build() {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);\n  if (!histogram) {\n    const BucketRanges* created_ranges = CreateRanges();\n    const BucketRanges* registered_ranges =\n        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);\n\n    if (bucket_count_ == 0) {\n      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());\n      minimum_ = registered_ranges->range(1);\n      maximum_ = registered_ranges->range(bucket_count_ - 1);\n    }\n\n    PersistentHistogramAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          histogram_type_,\n          name_,\n          minimum_,\n          maximum_,\n          registered_ranges,\n          flags_,\n          &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  // Should never have been set.\n      DCHECK(!allocator);  // Shouldn't have failed.\n      flags_ &= ~HistogramBase::kIsPersistent;\n      tentative_histogram = HeapAlloc(registered_ranges);\n      tentative_histogram->SetFlags(flags_);\n    }\n\n    FillHistogram(tentative_histogram.get());\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n   if (bucket_count_ != 0 &&\n       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {\n    DLOG(ERROR) << \"Histogram \" << name_ << \" has bad construction arguments\";\n    return nullptr;\n  }\n  return histogram;\n}\n",
        "label": 1
    },
    {
        "pre_patch": " void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n\tif (serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}\n}\n",
        "post_patch": " void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int var_read_int(AVIOContext *pb, int size)\n{\n    int v;\n    char *s = var_read_string(pb, size);\n    if (!s)\n        return 0;\n    v = strtol(s, NULL, 10);\n    av_free(s);\n    return v;\n}\n",
        "post_patch": "static int var_read_int(AVIOContext *pb, int size)\n{\n    int v;\n    char *s = var_read_string(pb, size);\n    if (!s)\n        return 0;\n    v = strtol(s, NULL, 10);\n    av_free(s);\n    return v;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "find_section_to_relocate(Dwarf_Debug dbg,Dwarf_Half section_index,\n   struct Dwarf_Section_s **relocatablesec, int *error)\n{\n    MATCH_REL_SEC(section_index,dbg->de_debug_info,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_abbrev,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_line,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_loc,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_aranges,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_macinfo,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_pubnames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_ranges,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_frame,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_frame_eh_gnu,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_pubtypes,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_funcnames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_typenames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_varnames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_weaknames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_types,relocatablesec);\n    /* dbg-> de_debug_tu_index,reloctablesec); */\n    /* dbg-> de_debug_cu_index,reloctablesec); */\n    /* dbg-> de_debug_gdbindex,reloctablesec); */\n    /* dbg-> de_debug_str,syms); */\n    /* de_elf_symtab,syms); */\n    /* de_elf_strtab,syms); */\n    *error = DW_DLE_RELOC_SECTION_MISMATCH;\n    return DW_DLV_ERROR;\n\n}\n",
        "post_patch": "find_section_to_relocate(Dwarf_Debug dbg,Dwarf_Half section_index,\n   struct Dwarf_Section_s **relocatablesec, int *error)\n{\n    MATCH_REL_SEC(section_index,dbg->de_debug_info,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_abbrev,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_line,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_loc,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_aranges,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_macinfo,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_pubnames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_ranges,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_frame,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_frame_eh_gnu,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_pubtypes,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_funcnames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_typenames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_varnames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_weaknames,relocatablesec);\n    MATCH_REL_SEC(section_index,dbg->de_debug_types,relocatablesec);\n    /* dbg-> de_debug_tu_index,reloctablesec); */\n    /* dbg-> de_debug_cu_index,reloctablesec); */\n    /* dbg-> de_debug_gdbindex,reloctablesec); */\n    /* dbg-> de_debug_str,syms); */\n    /* de_elf_symtab,syms); */\n    /* de_elf_strtab,syms); */\n    *error = DW_DLE_RELOC_SECTION_MISMATCH;\n    return DW_DLV_ERROR;\n\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int connect_namedsocket(const char *path)\n{\n    int sockfd, size;\n    struct sockaddr_un helper;\n\n    if (strlen(path) >= sizeof(helper.sun_path)) {\n        error_report(\"Socket name too long\");\n        return -1;\n    }\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        error_report(\"Failed to create socket: %s\", strerror(errno));\n        return -1;\n    }\n    strcpy(helper.sun_path, path);\n    helper.sun_family = AF_UNIX;\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n        error_report(\"Failed to connect to %s: %s\", path, strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n\n    /* remove the socket for security reasons */\n    unlink(path);\n    return sockfd;\n}\n",
        "post_patch": "static int connect_namedsocket(const char *path)\n{\n    int sockfd, size;\n    struct sockaddr_un helper;\n\n    if (strlen(path) >= sizeof(helper.sun_path)) {\n        error_report(\"Socket name too long\");\n        return -1;\n    }\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        error_report(\"Failed to create socket: %s\", strerror(errno));\n        return -1;\n    }\n    strcpy(helper.sun_path, path);\n    helper.sun_family = AF_UNIX;\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n        error_report(\"Failed to connect to %s: %s\", path, strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n\n    /* remove the socket for security reasons */\n    unlink(path);\n    return sockfd;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,\n \t\t\t       struct buffer_head *bh_result, int create)\n {\n \tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n \t * while file size will be changed.\n \t */\n \tif (pos + total_len <= i_size_read(inode)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\t\tup_read(&oi->ip_alloc_sem);\n \n \t\tif (buffer_mapped(bh_result) &&\n \t\t    !buffer_new(bh_result) &&\n \t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n",
        "post_patch": "static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,\nstatic int ocfs2_dio_wr_get_block(struct inode *inode, sector_t iblock,\n \t\t\t       struct buffer_head *bh_result, int create)\n {\n \tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n \t * while file size will be changed.\n \t */\n \tif (pos + total_len <= i_size_read(inode)) {\n \n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_lock_get_block(inode, iblock, bh_result, create);\n \t\tif (buffer_mapped(bh_result) &&\n \t\t    !buffer_new(bh_result) &&\n \t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[r] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}\n",
        "post_patch": "sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "bool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);\n\n\tif (!memslot || memslot->id >= KVM_USER_MEM_SLOTS ||\n\t      memslot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\n\treturn true;\n}\n",
        "post_patch": "bool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);\n\n\tif (!memslot || memslot->id >= KVM_USER_MEM_SLOTS ||\n\t      memslot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\n\treturn true;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}\n",
        "post_patch": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n",
        "label": 1
    },
    {
        "pre_patch": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n     gx_color_index drawn_comps = pdev->drawn_comps;\n     bool nonicc_conversion = true;\n \n     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n     tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}\n",
        "post_patch": "pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n    const pdf14_nonseparable_blending_procs_t * pblend_procs,\n    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)\n{\n    pdf14_buf *tos = ctx->stack;\n    pdf14_buf *nos = tos->saved;\n    pdf14_mask_t *mask_stack = tos->mask_stack;\n    pdf14_buf *maskbuf;\n    int x0, x1, y0, y1;\n    byte *new_data_buf = NULL;\n    int num_noncolor_planes, new_num_planes;\n    int num_cols, num_rows, nos_num_color_comp;\n    bool icc_match;\n    gsicc_rendering_param_t rendering_params;\n    gsicc_link_t *icc_link;\n    gsicc_bufferdesc_t input_buff_desc;\n    gsicc_bufferdesc_t output_buff_desc;\n    pdf14_device *pdev = (pdf14_device *)dev;\n    bool overprint = pdev->overprint;\n     gx_color_index drawn_comps = pdev->drawn_comps;\n     bool nonicc_conversion = true;\n \n    if (nos == NULL)\n        return_error(gs_error_unknownerror);  /* Unmatched group pop */\n\n     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n     tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n    if (mask_stack == NULL) {\n        maskbuf = NULL;\n    } else {\n        maskbuf = mask_stack->rc_mask->mask_buf;\n    }\n    if (nos == NULL)\n        return_error(gs_error_rangecheck);\n    /* Sanitise the dirty rectangles, in case some of the drawing routines\n     * have made them overly large. */\n    rect_intersect(tos->dirty, tos->rect);\n    rect_intersect(nos->dirty, nos->rect);\n    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */\n    /* Everything marked on tos that fits onto nos needs to be merged down. */\n    y0 = max(tos->dirty.p.y, nos->rect.p.y);\n    y1 = min(tos->dirty.q.y, nos->rect.q.y);\n    x0 = max(tos->dirty.p.x, nos->rect.p.x);\n    x1 = min(tos->dirty.q.x, nos->rect.q.x);\n    if (ctx->mask_stack) {\n        /* This can occur when we have a situation where we are ending out of\n           a group that has internal to it a soft mask and another group.\n           The soft mask left over from the previous trans group pop is put\n           into ctx->masbuf, since it is still active if another trans group\n           push occurs to use it.  If one does not occur, but instead we find\n           ourselves popping from a parent group, then this softmask is no\n           longer needed.  We will rc_decrement and set it to NULL. */\n        rc_decrement(ctx->mask_stack->rc_mask, \"pdf14_pop_transparency_group\");\n        if (ctx->mask_stack->rc_mask == NULL ){\n            gs_free_object(ctx->memory, ctx->mask_stack, \"pdf14_pop_transparency_group\");\n        }\n        ctx->mask_stack = NULL;\n    }\n    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */\n    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */\n    if (tos->idle)\n        goto exit;\n    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)\n        goto exit;\n\n#if RAW_DUMP\n    /* Dump the current buffer to see what we have. */\n    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                ctx->stack->rowstride, ctx->stack->n_planes,\n                ctx->stack->planestride, ctx->stack->rowstride,\n                \"aaTrans_Group_Pop\",ctx->stack->data);\n#endif\n/* Note currently if a pattern space has transparency, the ICC profile is not used\n   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.\n   This is partially due to the fact that pdf14_pop_transparency_group and\n   pdf14_push_transparnecy_group have no real ICC interaction and those are the\n   operations called in the tile transparency code.  Instead we may want to\n   look at pdf14_begin_transparency_group and pdf14_end_transparency group which\n   is where all the ICC information is handled.  We will return to look at that later */\n    if (nos->parent_color_info_procs->icc_profile != NULL) {\n        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=\n                        curr_icc_profile->hashcode);\n    } else {\n        /* Let the other tests make the decision if we need to transform */\n        icc_match = false;\n    }\n    /* If the color spaces are different and we actually did do a swap of\n       the procs for color */\n    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&\n        nos_num_color_comp != tos_num_color_comp) || icc_match) {\n        if (x0 < x1 && y0 < y1) {\n            /* The NOS blending color space is different than that of the\n               TOS.  It is necessary to transform the TOS buffer data to the\n               color space of the NOS prior to doing the pdf14_compose_group\n               operation.  */\n            num_noncolor_planes = tos->n_planes - tos_num_color_comp;\n            new_num_planes = num_noncolor_planes + nos_num_color_comp;\n\n            /* See if we are doing ICC based conversion */\n            if (nos->parent_color_info_procs->icc_profile != NULL &&\n                curr_icc_profile != NULL) {\n                /* Use the ICC color management for buffer color conversion */\n                /* Define the rendering intents */\n                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;\n                rendering_params.graphics_type_tag = GS_IMAGE_TAG;\n                rendering_params.override_icc = false;\n                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;\n                rendering_params.rendering_intent = gsPERCEPTUAL;\n                rendering_params.cmm = gsCMM_DEFAULT;\n                /* Request the ICC link for the transform that we will need to use */\n                /* Note that if pgs is NULL we assume the same color space.  This\n                   is due to a call to pop the group from fill_mask when filling\n                   with a mask with transparency.  In that case, the parent\n                   and the child will have the same color space anyway */\n                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,\n                                    nos->parent_color_info_procs->icc_profile,\n                                    &rendering_params, pgs->memory, false);\n                if (icc_link != NULL) {\n                    /* if problem with link we will do non-ICC approach */\n                    nonicc_conversion = false;\n                    /* If the link is the identity, then we don't need to do\n                       any color conversions */\n                    if ( !(icc_link->is_identity) ) {\n                        /* Before we do any allocations check if we can get away with\n                           reusing the existing buffer if it is the same size ( if it is\n                           smaller go ahead and allocate).  We could reuse it in this\n                           case too.  We need to do a bit of testing to determine what\n                           would be best.  */\n                        /* FIXME: RJW: Could we get away with just color converting\n                         * the area that's actually active (i.e. dirty, not rect)?\n                         */\n                        if(nos_num_color_comp != tos_num_color_comp) {\n                            /* Different size.  We will need to allocate */\n                            new_data_buf = gs_alloc_bytes(ctx->memory,\n                                                tos->planestride * new_num_planes,\n                                                    \"pdf14_pop_transparency_group\");\n                            if (new_data_buf == NULL)\n                                return_error(gs_error_VMerror);\n                            /* Copy over the noncolor planes. */\n                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,\n                                   tos->data + tos->planestride * tos_num_color_comp,\n                                   tos->planestride * num_noncolor_planes);\n                        } else {\n                            /* In place color conversion! */\n                            new_data_buf = tos->data;\n                        }\n                        /* Set up the buffer descriptors. Note that pdf14 always has\n                           the alpha channels at the back end (last planes).\n                           We will just handle that here and let the CMM know\n                           nothing about it */\n                        num_rows = tos->rect.q.y - tos->rect.p.y;\n                        num_cols = tos->rect.q.x - tos->rect.p.x;\n                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,\n                                          false, false, true,\n                                          tos->planestride, tos->rowstride,\n                                          num_rows, num_cols);\n                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,\n                                          1, false, false, true, tos->planestride,\n                                          tos->rowstride, num_rows, num_cols);\n                        /* Transform the data. Since the pdf14 device should be\n                           using RGB, CMYK or Gray buffers, this transform\n                           does not need to worry about the cmap procs of\n                           the target device.  Those are handled when we do\n                           the pdf14 put image operation */\n                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,\n                                                     &output_buff_desc, tos->data,\n                                                     new_data_buf);\n                    }\n                    /* Release the link */\n                    gsicc_release_link(icc_link);\n                    /* free the old object if the color spaces were different sizes */\n                    if(!(icc_link->is_identity) &&\n                        nos_num_color_comp != tos_num_color_comp) {\n                        gs_free_object(ctx->memory, tos->data,\n                            \"pdf14_pop_transparency_group\");\n                        tos->data = new_data_buf;\n                    }\n                }\n            }\n            if (nonicc_conversion) {\n                /* Non ICC based transform */\n                new_data_buf = gs_alloc_bytes(ctx->memory,\n                                    tos->planestride * new_num_planes,\n                                    \"pdf14_pop_transparency_group\");\n                if (new_data_buf == NULL)\n                    return_error(gs_error_VMerror);\n                gs_transform_color_buffer_generic(tos->data, tos->rowstride,\n                            tos->planestride, tos_num_color_comp, tos->rect,\n                            new_data_buf, nos_num_color_comp, num_noncolor_planes);\n                /* Free the old object */\n                gs_free_object(ctx->memory, tos->data,\n                                \"pdf14_pop_transparency_group\");\n                 tos->data = new_data_buf;\n            }\n             /* Adjust the plane and channel size now */\n             tos->n_chan = nos->n_chan;\n             tos->n_planes = nos->n_planes;\n#if RAW_DUMP\n            /* Dump the current buffer to see what we have. */\n            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,\n                            ctx->stack->rowstride, ctx->stack->n_chan,\n                            ctx->stack->planestride, ctx->stack->rowstride,\n                            \"aCMTrans_Group_ColorConv\",ctx->stack->data);\n#endif\n             /* compose. never do overprint in this case */\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                 nos->parent_color_info_procs->isadditive,\n                 nos->parent_color_info_procs->parent_blending_procs,\n                 false, drawn_comps, ctx->memory, dev);\n        }\n    } else {\n        /* Group color spaces are the same.  No color conversions needed */\n        if (x0 < x1 && y0 < y1)\n            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,\n                                ctx->additive, pblend_procs, overprint,\n                                drawn_comps, ctx->memory, dev);\n    }\nexit:\n    ctx->stack = nos;\n    /* We want to detect the cases where we have luminosity soft masks embedded\n       within one another.  The \"alpha\" channel really needs to be merged into\n       the luminosity channel in this case.  This will occur during the mask pop */\n    if (ctx->smask_depth > 0 && maskbuf != NULL) {\n        /* Set the trigger so that we will blend if not alpha. Since\n           we have softmasks embedded in softmasks */\n        ctx->smask_blend = true;\n    }\n    if_debug1m('v', ctx->memory, \"[v]pop buf, idle=%d\\n\", tos->idle);\n    pdf14_buf_free(tos, ctx->memory);\n    return 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void __init vfs_caches_init_early(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(in_lookup_hashtable); i++)\n\t\tINIT_HLIST_BL_HEAD(&in_lookup_hashtable[i]);\n\n\tdcache_init_early();\n\tinode_init_early();\n}\n",
        "post_patch": "void __init vfs_caches_init_early(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(in_lookup_hashtable); i++)\n\t\tINIT_HLIST_BL_HEAD(&in_lookup_hashtable[i]);\n\n\tdcache_init_early();\n\tinode_init_early();\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}\n",
        "post_patch": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/\n   if (handle == 0) {\n      return;\n   }\n\n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "ofputil_parse_key_value(char **stringp, char **keyp, char **valuep)\n{\n    /* Skip white space and delimiters.  If that brings us to the end of the\n     * input string, we are done and there are no more key-value pairs. */\n    *stringp += strspn(*stringp, \", \\t\\r\\n\");\n    if (**stringp == '\\0') {\n        *keyp = *valuep = NULL;\n        return false;\n    }\n\n    /* Extract the key and the delimiter that ends the key-value pair or begins\n     * the value.  Advance the input position past the key and delimiter. */\n    char *key = *stringp;\n    size_t key_len = strcspn(key, \":=(, \\t\\r\\n\");\n    char key_delim = key[key_len];\n    key[key_len] = '\\0';\n    *stringp += key_len + (key_delim != '\\0');\n\n    /* Figure out what delimiter ends the value:\n     *\n     *     - If key_delim is \":\" or \"=\", the value extends until white space\n     *       or a comma.\n     *\n     *     - If key_delim is \"(\", the value extends until \")\".\n     *\n     * If there is no value, we are done. */\n    const char *value_delims;\n    if (key_delim == ':' || key_delim == '=') {\n        value_delims = \", \\t\\r\\n\";\n    } else if (key_delim == '(') {\n        value_delims = \")\";\n    } else {\n        *keyp = key;\n        *valuep = key + key_len; /* Empty string. */\n        return true;\n    }\n\n    /* Extract the value.  Advance the input position past the value and\n     * delimiter. */\n    char *value = *stringp;\n    size_t value_len = parse_value(value, value_delims);\n    char value_delim = value[value_len];\n    value[value_len] = '\\0';\n    *stringp += value_len + (value_delim != '\\0');\n\n    *keyp = key;\n    *valuep = value;\n    return true;\n}\n",
        "post_patch": "ofputil_parse_key_value(char **stringp, char **keyp, char **valuep)\n{\n    /* Skip white space and delimiters.  If that brings us to the end of the\n     * input string, we are done and there are no more key-value pairs. */\n    *stringp += strspn(*stringp, \", \\t\\r\\n\");\n    if (**stringp == '\\0') {\n        *keyp = *valuep = NULL;\n        return false;\n    }\n\n    /* Extract the key and the delimiter that ends the key-value pair or begins\n     * the value.  Advance the input position past the key and delimiter. */\n    char *key = *stringp;\n    size_t key_len = strcspn(key, \":=(, \\t\\r\\n\");\n    char key_delim = key[key_len];\n    key[key_len] = '\\0';\n    *stringp += key_len + (key_delim != '\\0');\n\n    /* Figure out what delimiter ends the value:\n     *\n     *     - If key_delim is \":\" or \"=\", the value extends until white space\n     *       or a comma.\n     *\n     *     - If key_delim is \"(\", the value extends until \")\".\n     *\n     * If there is no value, we are done. */\n    const char *value_delims;\n    if (key_delim == ':' || key_delim == '=') {\n        value_delims = \", \\t\\r\\n\";\n    } else if (key_delim == '(') {\n        value_delims = \")\";\n    } else {\n        *keyp = key;\n        *valuep = key + key_len; /* Empty string. */\n        return true;\n    }\n\n    /* Extract the value.  Advance the input position past the value and\n     * delimiter. */\n    char *value = *stringp;\n    size_t value_len = parse_value(value, value_delims);\n    char value_delim = value[value_len];\n    value[value_len] = '\\0';\n    *stringp += value_len + (value_delim != '\\0');\n\n    *keyp = key;\n    *valuep = value;\n    return true;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\n\t\t/* Get an arbitrary mm pointer that hasn't been cleaned yet */\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\n\t\t/*\n\t\t * The umap_lock is nested under mmap_sem since it used within\n\t\t * the vma_ops callbacks, so we have to clean the list one mm\n\t\t * at a time to get the lock ordering right. Typically there\n \t\t * will only be one mm, so no big deal.\n \t\t */\n \t\tdown_write(&mm->mmap_sem);\n \t\tmutex_lock(&ufile->umap_lock);\n \t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n \t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n \t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n \t\t}\n \t\tmutex_unlock(&ufile->umap_lock);\n \t\tup_write(&mm->mmap_sem);\n \t\tmmput(mm);\n \t}\n}\n",
        "post_patch": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\n\t\t/* Get an arbitrary mm pointer that hasn't been cleaned yet */\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\n\t\t/*\n\t\t * The umap_lock is nested under mmap_sem since it used within\n\t\t * the vma_ops callbacks, so we have to clean the list one mm\n\t\t * at a time to get the lock ordering right. Typically there\n \t\t * will only be one mm, so no big deal.\n \t\t */\n \t\tdown_write(&mm->mmap_sem);\n\t\tif (!mmget_still_valid(mm))\n\t\t\tgoto skip_mm;\n \t\tmutex_lock(&ufile->umap_lock);\n \t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n \t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n \t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n \t\t}\n \t\tmutex_unlock(&ufile->umap_lock);\n\tskip_mm:\n \t\tup_write(&mm->mmap_sem);\n \t\tmmput(mm);\n \t}\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int ext4_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext4_journal_start(d_inode(sb->s_root), EXT4_HT_QUOTA, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n",
        "post_patch": "static int ext4_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext4_journal_start(d_inode(sb->s_root), EXT4_HT_QUOTA, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n                             const E1000E_RxRing *rxr,\n                             const E1000E_RSSInfo *rss_info)\n{\n    PCIDevice *d = core->owner;\n    dma_addr_t base;\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n    size_t desc_size;\n    size_t desc_offset = 0;\n    size_t iov_ofs = 0;\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n    size_t size = net_rx_pkt_get_total_len(pkt);\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n    const E1000E_RingInfo *rxi;\n    size_t ps_hdr_len = 0;\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n    bool is_first = true;\n\n    rxi = rxr->i;\n\n    do {\n        hwaddr ba[MAX_PS_BUFFERS];\n        e1000e_ba_state bastate = { { 0 } };\n        bool is_last = false;\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > core->rx_desc_buf_size) {\n            desc_size = core->rx_desc_buf_size;\n             desc_size = core->rx_desc_buf_size;\n         }\n \n         base = e1000e_ring_head_descr(core, rxi);\n \n         pci_dma_read(d, base, &desc, core->rx_desc_len);\n        if (ba[0]) {\n            if (desc_offset < size) {\n                static const uint32_t fcs_pad;\n                size_t iov_copy;\n                size_t copy_size = size - desc_offset;\n                if (copy_size > core->rx_desc_buf_size) {\n                    copy_size = core->rx_desc_buf_size;\n                }\n\n                /* For PS mode copy the packet header first */\n                if (do_ps) {\n                    if (is_first) {\n                        size_t ps_hdr_copied = 0;\n                        do {\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n                                           iov->iov_len - iov_ofs);\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                      iov->iov_base, iov_copy);\n\n                            copy_size -= iov_copy;\n                            ps_hdr_copied += iov_copy;\n\n                            iov_ofs += iov_copy;\n                            if (iov_ofs == iov->iov_len) {\n                                iov++;\n                                iov_ofs = 0;\n                            }\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n                        is_first = false;\n                    } else {\n                        /* Leave buffer 0 of each descriptor except first */\n                        /* empty as per spec 7.1.5.1                      */\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                       NULL, 0);\n                    }\n                }\n\n                /* Copy packet payload */\n                while (copy_size) {\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n                    iov_ofs += iov_copy;\n                    if (iov_ofs == iov->iov_len) {\n                        iov++;\n                        iov_ofs = 0;\n                    }\n                }\n\n                if (desc_offset + desc_size >= total_size) {\n                    /* Simulate FCS checksum presence in the last descriptor */\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n                }\n            }\n            desc_offset += desc_size;\n            if (desc_offset >= total_size) {\n                is_last = true;\n            }\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n            trace_e1000e_rx_null_descriptor();\n        }\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n        e1000e_ring_advance(core, rxi,\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n    } while (desc_offset < total_size);\n\n    e1000e_update_rx_stats(core, size, total_size);\n}\n",
        "post_patch": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n                             const E1000E_RxRing *rxr,\n                             const E1000E_RSSInfo *rss_info)\n{\n    PCIDevice *d = core->owner;\n    dma_addr_t base;\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n    size_t desc_size;\n    size_t desc_offset = 0;\n    size_t iov_ofs = 0;\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n    size_t size = net_rx_pkt_get_total_len(pkt);\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n    const E1000E_RingInfo *rxi;\n    size_t ps_hdr_len = 0;\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n    bool is_first = true;\n\n    rxi = rxr->i;\n\n    do {\n        hwaddr ba[MAX_PS_BUFFERS];\n        e1000e_ba_state bastate = { { 0 } };\n        bool is_last = false;\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > core->rx_desc_buf_size) {\n            desc_size = core->rx_desc_buf_size;\n             desc_size = core->rx_desc_buf_size;\n         }\n \n        if (e1000e_ring_empty(core, rxi)) {\n            return;\n        }\n\n         base = e1000e_ring_head_descr(core, rxi);\n \n         pci_dma_read(d, base, &desc, core->rx_desc_len);\n        if (ba[0]) {\n            if (desc_offset < size) {\n                static const uint32_t fcs_pad;\n                size_t iov_copy;\n                size_t copy_size = size - desc_offset;\n                if (copy_size > core->rx_desc_buf_size) {\n                    copy_size = core->rx_desc_buf_size;\n                }\n\n                /* For PS mode copy the packet header first */\n                if (do_ps) {\n                    if (is_first) {\n                        size_t ps_hdr_copied = 0;\n                        do {\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n                                           iov->iov_len - iov_ofs);\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                      iov->iov_base, iov_copy);\n\n                            copy_size -= iov_copy;\n                            ps_hdr_copied += iov_copy;\n\n                            iov_ofs += iov_copy;\n                            if (iov_ofs == iov->iov_len) {\n                                iov++;\n                                iov_ofs = 0;\n                            }\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n                        is_first = false;\n                    } else {\n                        /* Leave buffer 0 of each descriptor except first */\n                        /* empty as per spec 7.1.5.1                      */\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                       NULL, 0);\n                    }\n                }\n\n                /* Copy packet payload */\n                while (copy_size) {\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n                    iov_ofs += iov_copy;\n                    if (iov_ofs == iov->iov_len) {\n                        iov++;\n                        iov_ofs = 0;\n                    }\n                }\n\n                if (desc_offset + desc_size >= total_size) {\n                    /* Simulate FCS checksum presence in the last descriptor */\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n                }\n            }\n            desc_offset += desc_size;\n            if (desc_offset >= total_size) {\n                is_last = true;\n            }\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n            trace_e1000e_rx_null_descriptor();\n        }\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n        e1000e_ring_advance(core, rxi,\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n    } while (desc_offset < total_size);\n\n    e1000e_update_rx_stats(core, size, total_size);\n}\n",
        "label": 1
    },
    {
        "pre_patch": " void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n \trcu_read_lock();\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n \trcu_read_unlock();\n }\n",
        "post_patch": " void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \n \trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n \trcu_read_unlock();\n }\n",
        "label": 1
    },
    {
        "pre_patch": " int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n \t\tseed = buf;\n \t}\n \n\terr = tfm->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n}\n",
        "post_patch": " int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n \t\tseed = buf;\n \t}\n \n\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "error::Error GLES2DecoderPassthroughImpl::DoClearDepthf(GLclampf depth) {\n  api()->glClearDepthfFn(depth);\n  return error::kNoError;\n}\n",
        "post_patch": "error::Error GLES2DecoderPassthroughImpl::DoClearDepthf(GLclampf depth) {\n  api()->glClearDepthfFn(depth);\n  return error::kNoError;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int ip_options_get(struct net *net, struct ip_options **optp,\n \t\t   unsigned char *data, int optlen)\n {\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n \tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n",
        "post_patch": "int ip_options_get(struct net *net, struct ip_options **optp,\nint ip_options_get(struct net *net, struct ip_options_rcu **optp,\n \t\t   unsigned char *data, int optlen)\n {\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n \tif (optlen)\n\t\tmemcpy(opt->opt.__data, data, optlen);\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n",
        "label": 1
    },
    {
        "pre_patch": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n \n \treturn new_port;\n }\n",
        "post_patch": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n\tsprintf(new_port->name, \"port-%d\", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n \n \treturn new_port;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n \n \tre = js_toregexp(J, -1);\n \n\tif (!js_regexec(re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n}\n",
        "post_patch": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n \n \tre = js_toregexp(J, -1);\n \n\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n {\n \tstruct user_element *ue = kcontrol->private_data;\n \n \tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n \treturn 0;\n }\n",
        "post_patch": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n {\n \tstruct user_element *ue = kcontrol->private_data;\n \n\tmutex_lock(&ue->card->user_ctl_lock);\n \tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n \treturn 0;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static inline void ion_buffer_page_dirty(struct page **page)\n{\n\t*page = (struct page *)((unsigned long)(*page) | 1UL);\n}\n",
        "post_patch": "static inline void ion_buffer_page_dirty(struct page **page)\n{\n\t*page = (struct page *)((unsigned long)(*page) | 1UL);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n",
        "post_patch": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void RenderThreadImpl::OnTempCrashWithData(const GURL& data) {\n  GetContentClient()->SetActiveURL(data);\n  CHECK(false);\n}\n",
        "post_patch": "void RenderThreadImpl::OnTempCrashWithData(const GURL& data) {\n  GetContentClient()->SetActiveURL(data);\n  CHECK(false);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "MATCHER_P(CreditCardMatches, card, \"\") {\n  return !arg.Compare(card);\n}\n",
        "post_patch": "MATCHER_P(CreditCardMatches, card, \"\") {\n  return !arg.Compare(card);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n \tmemset(fl6, 0, sizeof(*fl6));\n \tfl6->flowi6_proto = proto;\n \tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n \tfl6->saddr = ireq->ir_v6_loc_addr;\n \tfl6->flowi6_oif = ireq->ir_iif;\n \tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}\n",
        "post_patch": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n \tmemset(fl6, 0, sizeof(*fl6));\n \tfl6->flowi6_proto = proto;\n \tfl6->daddr = ireq->ir_v6_rmt_addr;\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n \tfl6->saddr = ireq->ir_v6_loc_addr;\n \tfl6->flowi6_oif = ireq->ir_iif;\n \tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void dbstmt_prop_write(zval *object, zval *member, zval *value, const zend_literal *key TSRMLS_DC)\n{\n\tpdo_stmt_t * stmt = (pdo_stmt_t *) zend_object_store_get_object(object TSRMLS_CC);\n\n\tconvert_to_string(member);\n\n\tif(strcmp(Z_STRVAL_P(member), \"queryString\") == 0) {\n\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"property queryString is read only\" TSRMLS_CC);\n\t} else {\n\t\tstd_object_handlers.write_property(object, member, value, key TSRMLS_CC);\n\t}\n}\n",
        "post_patch": "static void dbstmt_prop_write(zval *object, zval *member, zval *value, const zend_literal *key TSRMLS_DC)\n{\n\tpdo_stmt_t * stmt = (pdo_stmt_t *) zend_object_store_get_object(object TSRMLS_CC);\n\n\tconvert_to_string(member);\n\n\tif(strcmp(Z_STRVAL_P(member), \"queryString\") == 0) {\n\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"property queryString is read only\" TSRMLS_CC);\n\t} else {\n\t\tstd_object_handlers.write_property(object, member, value, key TSRMLS_CC);\n\t}\n}\n",
        "label": 0
    },
    {
        "pre_patch": "error::Error GLES2DecoderImpl::HandleBeginQueryEXT(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::BeginQueryEXT& c =\n      *static_cast<const volatile gles2::cmds::BeginQueryEXT*>(cmd_data);\n  GLenum target = static_cast<GLenum>(c.target);\n  GLuint client_id = static_cast<GLuint>(c.id);\n  int32_t sync_shm_id = static_cast<int32_t>(c.sync_data_shm_id);\n  uint32_t sync_shm_offset = static_cast<uint32_t>(c.sync_data_shm_offset);\n\n  switch (target) {\n    case GL_COMMANDS_ISSUED_CHROMIUM:\n    case GL_LATENCY_QUERY_CHROMIUM:\n    case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM:\n    case GL_GET_ERROR_QUERY_CHROMIUM:\n      break;\n    case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n    case GL_COMMANDS_COMPLETED_CHROMIUM:\n      if (!features().chromium_sync_query) {\n        LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for commands completed queries\");\n         return error::kNoError;\n       }\n       break;\n     case GL_SAMPLES_PASSED_ARB:\n       if (!features().occlusion_query) {\n         LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for occlusion queries\");\n        return error::kNoError;\n      }\n      break;\n    case GL_ANY_SAMPLES_PASSED:\n    case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:\n      if (!features().occlusion_query_boolean) {\n        LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for boolean occlusion queries\");\n        return error::kNoError;\n      }\n      break;\n    case GL_TIME_ELAPSED:\n      if (!query_manager_->GPUTimingAvailable()) {\n        LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for timing queries\");\n        return error::kNoError;\n      }\n      break;\n    case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:\n      if (feature_info_->IsWebGL2OrES3Context()) {\n        break;\n      }\n      FALLTHROUGH;\n    default:\n      LOCAL_SET_GL_ERROR(\n          GL_INVALID_ENUM, \"glBeginQueryEXT\",\n          \"unknown query target\");\n      return error::kNoError;\n  }\n\n  if (query_manager_->GetActiveQuery(target)) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"query already in progress\");\n    return error::kNoError;\n  }\n\n  if (client_id == 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"id is 0\");\n    return error::kNoError;\n  }\n\n  scoped_refptr<gpu::Buffer> buffer = GetSharedMemoryBuffer(sync_shm_id);\n  if (!buffer)\n    return error::kInvalidArguments;\n  QuerySync* sync = static_cast<QuerySync*>(\n      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));\n  if (!sync)\n    return error::kOutOfBounds;\n\n  QueryManager::Query* query = query_manager_->GetQuery(client_id);\n  if (!query) {\n    if (!query_manager_->IsValidQuery(client_id)) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                         \"glBeginQueryEXT\",\n                         \"id not made by glGenQueriesEXT\");\n      return error::kNoError;\n    }\n\n    query =\n        query_manager_->CreateQuery(target, client_id, std::move(buffer), sync);\n  } else {\n    if (query->target() != target) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                         \"target does not match\");\n      return error::kNoError;\n    } else if (query->sync() != sync) {\n      DLOG(ERROR) << \"Shared memory used by query not the same as before\";\n      return error::kInvalidArguments;\n    }\n  }\n\n  query_manager_->BeginQuery(query);\n  return error::kNoError;\n}\n",
        "post_patch": "error::Error GLES2DecoderImpl::HandleBeginQueryEXT(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::BeginQueryEXT& c =\n      *static_cast<const volatile gles2::cmds::BeginQueryEXT*>(cmd_data);\n  GLenum target = static_cast<GLenum>(c.target);\n  GLuint client_id = static_cast<GLuint>(c.id);\n  int32_t sync_shm_id = static_cast<int32_t>(c.sync_data_shm_id);\n  uint32_t sync_shm_offset = static_cast<uint32_t>(c.sync_data_shm_offset);\n\n  switch (target) {\n    case GL_COMMANDS_ISSUED_CHROMIUM:\n    case GL_LATENCY_QUERY_CHROMIUM:\n    case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM:\n    case GL_GET_ERROR_QUERY_CHROMIUM:\n      break;\n    case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n    case GL_COMMANDS_COMPLETED_CHROMIUM:\n      if (!features().chromium_sync_query) {\n        LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for commands completed queries\");\n         return error::kNoError;\n       }\n       break;\n    case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM:\n      if (!features().chromium_completion_query) {\n        LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                           \"not enabled for program completion queries\");\n        return error::kNoError;\n      }\n      break;\n     case GL_SAMPLES_PASSED_ARB:\n       if (!features().occlusion_query) {\n         LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for occlusion queries\");\n        return error::kNoError;\n      }\n      break;\n    case GL_ANY_SAMPLES_PASSED:\n    case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:\n      if (!features().occlusion_query_boolean) {\n        LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for boolean occlusion queries\");\n        return error::kNoError;\n      }\n      break;\n    case GL_TIME_ELAPSED:\n      if (!query_manager_->GPUTimingAvailable()) {\n        LOCAL_SET_GL_ERROR(\n            GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n            \"not enabled for timing queries\");\n        return error::kNoError;\n      }\n      break;\n    case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:\n      if (feature_info_->IsWebGL2OrES3Context()) {\n        break;\n      }\n      FALLTHROUGH;\n    default:\n      LOCAL_SET_GL_ERROR(\n          GL_INVALID_ENUM, \"glBeginQueryEXT\",\n          \"unknown query target\");\n      return error::kNoError;\n  }\n\n  if (query_manager_->GetActiveQuery(target)) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"query already in progress\");\n    return error::kNoError;\n  }\n\n  if (client_id == 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"glBeginQueryEXT\", \"id is 0\");\n    return error::kNoError;\n  }\n\n  scoped_refptr<gpu::Buffer> buffer = GetSharedMemoryBuffer(sync_shm_id);\n  if (!buffer)\n    return error::kInvalidArguments;\n  QuerySync* sync = static_cast<QuerySync*>(\n      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));\n  if (!sync)\n    return error::kOutOfBounds;\n\n  QueryManager::Query* query = query_manager_->GetQuery(client_id);\n  if (!query) {\n    if (!query_manager_->IsValidQuery(client_id)) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                         \"glBeginQueryEXT\",\n                         \"id not made by glGenQueriesEXT\");\n      return error::kNoError;\n    }\n\n    query =\n        query_manager_->CreateQuery(target, client_id, std::move(buffer), sync);\n  } else {\n    if (query->target() != target) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"glBeginQueryEXT\",\n                         \"target does not match\");\n      return error::kNoError;\n    } else if (query->sync() != sync) {\n      DLOG(ERROR) << \"Shared memory used by query not the same as before\";\n      return error::kInvalidArguments;\n    }\n  }\n\n  query_manager_->BeginQuery(query);\n  return error::kNoError;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "ModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n             if (image->debug != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      layer data is empty\");\n             continue;\n           }\n \n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n",
        "post_patch": "ModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n             if (image->debug != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n             continue;\n           }\n \n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "status_t MediaPlayer::getPlaybackSettings(AudioPlaybackRate* rate /* nonnull */)\n{\n Mutex::Autolock _l(mLock);\n if (mPlayer == 0) return INVALID_OPERATION;\n return mPlayer->getPlaybackSettings(rate);\n}\n",
        "post_patch": "status_t MediaPlayer::getPlaybackSettings(AudioPlaybackRate* rate /* nonnull */)\n{\n Mutex::Autolock _l(mLock);\n if (mPlayer == 0) return INVALID_OPERATION;\n return mPlayer->getPlaybackSettings(rate);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n                                           int32_t flags) {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);\n  if (!histogram) {\n    PersistentMemoryAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  // Should never have been set.\n      DCHECK(!allocator);      // Shouldn't have failed.\n      flags &= ~HistogramBase::kIsPersistent;\n      tentative_histogram.reset(new SparseHistogram(name));\n      tentative_histogram->SetFlags(flags);\n    }\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n",
        "post_patch": "HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n                                           int32_t flags) {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);\n  if (!histogram) {\n    PersistentMemoryAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  // Should never have been set.\n      DCHECK(!allocator);      // Shouldn't have failed.\n      flags &= ~HistogramBase::kIsPersistent;\n      tentative_histogram.reset(new SparseHistogram(name));\n      tentative_histogram->SetFlags(flags);\n    }\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n \t\t\t\t\t\tint id)\n {\n \tstruct ion_handle *handle;\n \n\tmutex_lock(&client->lock);\n \thandle = idr_find(&client->idr, id);\n \tif (handle)\n \t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n \n \treturn handle ? handle : ERR_PTR(-EINVAL);\n }\n",
        "post_patch": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\nstatic struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n \t\t\t\t\t\tint id)\n {\n \tstruct ion_handle *handle;\n \n \thandle = idr_find(&client->idr, id);\n \tif (handle)\n \t\tion_handle_get(handle);\n \n \treturn handle ? handle : ERR_PTR(-EINVAL);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "void GLES2DecoderImpl::DoCopySubTextureCHROMIUM(\n    GLuint source_id,\n    GLint source_level,\n    GLenum dest_target,\n    GLuint dest_id,\n    GLint dest_level,\n    GLint xoffset,\n    GLint yoffset,\n    GLint x,\n    GLint y,\n    GLsizei width,\n    GLsizei height,\n    GLboolean unpack_flip_y,\n    GLboolean unpack_premultiply_alpha,\n    GLboolean unpack_unmultiply_alpha) {\n  TRACE_EVENT0(\"gpu\", \"GLES2DecoderImpl::DoCopySubTextureCHROMIUM\");\n  static const char kFunctionName[] = \"glCopySubTextureCHROMIUM\";\n  CopySubTextureHelper(kFunctionName, source_id, source_level, dest_target,\n                       dest_id, dest_level, xoffset, yoffset, x, y, width,\n                       height, unpack_flip_y, unpack_premultiply_alpha,\n                       unpack_unmultiply_alpha, GL_FALSE /* dither */);\n}\n",
        "post_patch": "void GLES2DecoderImpl::DoCopySubTextureCHROMIUM(\n    GLuint source_id,\n    GLint source_level,\n    GLenum dest_target,\n    GLuint dest_id,\n    GLint dest_level,\n    GLint xoffset,\n    GLint yoffset,\n    GLint x,\n    GLint y,\n    GLsizei width,\n    GLsizei height,\n    GLboolean unpack_flip_y,\n    GLboolean unpack_premultiply_alpha,\n    GLboolean unpack_unmultiply_alpha) {\n  TRACE_EVENT0(\"gpu\", \"GLES2DecoderImpl::DoCopySubTextureCHROMIUM\");\n  static const char kFunctionName[] = \"glCopySubTextureCHROMIUM\";\n  CopySubTextureHelper(kFunctionName, source_id, source_level, dest_target,\n                       dest_id, dest_level, xoffset, yoffset, x, y, width,\n                       height, unpack_flip_y, unpack_premultiply_alpha,\n                       unpack_unmultiply_alpha, GL_FALSE /* dither */);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "ZEND_API int zend_parse_parameters_ex(int flags, int num_args TSRMLS_DC, const char *type_spec, ...) /* {{{ */\n{\n\tva_list va;\n\tint retval;\n\n\tRETURN_IF_ZERO_ARGS(num_args, type_spec, flags & ZEND_PARSE_PARAMS_QUIET);\n\n\tva_start(va, type_spec);\n\tretval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);\n\tva_end(va);\n\n\treturn retval;\n}\n/* }}} */\n",
        "post_patch": "ZEND_API int zend_parse_parameters_ex(int flags, int num_args TSRMLS_DC, const char *type_spec, ...) /* {{{ */\n{\n\tva_list va;\n\tint retval;\n\n\tRETURN_IF_ZERO_ARGS(num_args, type_spec, flags & ZEND_PARSE_PARAMS_QUIET);\n\n\tva_start(va, type_spec);\n\tretval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);\n\tva_end(va);\n\n\treturn retval;\n}\n/* }}} */\n",
        "label": 0
    },
    {
        "pre_patch": "FrameView::FrameView(LocalFrame* frame)\n    : m_frame(frame)\n    , m_canHaveScrollbars(true)\n    , m_slowRepaintObjectCount(0)\n    , m_hasPendingLayout(false)\n    , m_layoutSubtreeRoot(0)\n    , m_inSynchronousPostLayout(false)\n    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)\n    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)\n    , m_isTransparent(false)\n    , m_baseBackgroundColor(Color::white)\n    , m_mediaType(\"screen\")\n    , m_overflowStatusDirty(true)\n    , m_viewportRenderer(0)\n    , m_wasScrolledByUser(false)\n    , m_inProgrammaticScroll(false)\n    , m_safeToPropagateScrollToParent(true)\n    , m_isTrackingPaintInvalidations(false)\n    , m_scrollCorner(nullptr)\n    , m_hasSoftwareFilters(false)\n    , m_visibleContentScaleFactor(1)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n {\n     ASSERT(m_frame);\n     init();\n\n    if (!m_frame->isMainFrame())\n        return;\n\n    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);\n    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);\n}\n",
        "post_patch": "FrameView::FrameView(LocalFrame* frame)\n    : m_frame(frame)\n    , m_canHaveScrollbars(true)\n    , m_slowRepaintObjectCount(0)\n    , m_hasPendingLayout(false)\n    , m_layoutSubtreeRoot(0)\n    , m_inSynchronousPostLayout(false)\n    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)\n    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)\n    , m_isTransparent(false)\n    , m_baseBackgroundColor(Color::white)\n    , m_mediaType(\"screen\")\n    , m_overflowStatusDirty(true)\n    , m_viewportRenderer(0)\n    , m_wasScrolledByUser(false)\n    , m_inProgrammaticScroll(false)\n    , m_safeToPropagateScrollToParent(true)\n    , m_isTrackingPaintInvalidations(false)\n    , m_scrollCorner(nullptr)\n    , m_hasSoftwareFilters(false)\n    , m_visibleContentScaleFactor(1)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n    , m_needsUpdateWidgetPositions(false)\n {\n     ASSERT(m_frame);\n     init();\n\n    if (!m_frame->isMainFrame())\n        return;\n\n    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);\n    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "error::Error GLES2DecoderPassthroughImpl::DoTexStorage3D(GLenum target,\n                                                         GLsizei levels,\n                                                         GLenum internalFormat,\n                                                         GLsizei width,\n                                                         GLsizei height,\n                                                         GLsizei depth) {\n  CheckErrorCallbackState();\n  api()->glTexStorage3DFn(target, levels, internalFormat, width, height, depth);\n  if (CheckErrorCallbackState()) {\n    return error::kNoError;\n  }\n\n  UpdateTextureSizeFromTarget(target);\n  return error::kNoError;\n}\n",
        "post_patch": "error::Error GLES2DecoderPassthroughImpl::DoTexStorage3D(GLenum target,\n                                                         GLsizei levels,\n                                                         GLenum internalFormat,\n                                                         GLsizei width,\n                                                         GLsizei height,\n                                                         GLsizei depth) {\n  CheckErrorCallbackState();\n  api()->glTexStorage3DFn(target, levels, internalFormat, width, height, depth);\n  if (CheckErrorCallbackState()) {\n    return error::kNoError;\n  }\n\n  UpdateTextureSizeFromTarget(target);\n  return error::kNoError;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void ShellSurface::OnPreWindowStateTypeChange(\n    ash::wm::WindowState* window_state,\n    ash::wm::WindowStateType old_type) {\n  ash::wm::WindowStateType new_type = window_state->GetStateType();\n  if (ash::wm::IsMaximizedOrFullscreenOrPinnedWindowStateType(old_type) ||\n      ash::wm::IsMaximizedOrFullscreenOrPinnedWindowStateType(new_type)) {\n    if (configure_callback_.is_null())\n      scoped_animations_disabled_.reset(new ScopedAnimationsDisabled(this));\n  }\n}\n",
        "post_patch": "void ShellSurface::OnPreWindowStateTypeChange(\n    ash::wm::WindowState* window_state,\n    ash::wm::WindowStateType old_type) {\n  ash::wm::WindowStateType new_type = window_state->GetStateType();\n  if (ash::wm::IsMaximizedOrFullscreenOrPinnedWindowStateType(old_type) ||\n      ash::wm::IsMaximizedOrFullscreenOrPinnedWindowStateType(new_type)) {\n    if (configure_callback_.is_null())\n      scoped_animations_disabled_.reset(new ScopedAnimationsDisabled(this));\n  }\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n         /* If current CRL is equivalent use it if it is newer */\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            /*\n             * ASN1_TIME_diff never returns inconsistent signs for |day|\n             * and |sec|.\n             */\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}\n",
        "post_patch": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score || crl_score == 0)\n             continue;\n         /* If current CRL is equivalent use it if it is newer */\n        if (crl_score == best_score && best_crl != NULL) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            /*\n             * ASN1_TIME_diff never returns inconsistent signs for |day|\n             * and |sec|.\n             */\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n       return;\n    }\n \n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}\n",
        "post_patch": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n       return;\n    }\n \n   blit_ctx->initialised = true;\n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void LargeObjectPage::Sweep() {\n  GetHeapObjectHeader()->Unmark();\n  Arena()->GetThreadState()->Heap().HeapStats().IncreaseMarkedObjectSize(\n      size());\n}\n",
        "post_patch": "void LargeObjectPage::Sweep() {\n  GetHeapObjectHeader()->Unmark();\n  Arena()->GetThreadState()->Heap().HeapStats().IncreaseMarkedObjectSize(\n      size());\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n                               int *len, int *strid, int read_packet) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int syncword, streamid, reserved, flags, length, pts_flag;\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n    int ret;\n\nrecover:\n    startpos = avio_tell(pb);\n\n    syncword = avio_rb16(pb);\n    streamid = avio_r8(pb);\n    avio_r8(pb);               /* counter not used */\n    reserved = avio_r8(pb);\n    flags    = avio_r8(pb);\n    length   = avio_rb16(pb);\n\n    pts_flag = flags & 0x10;\n\n    if (syncword != PVA_MAGIC) {\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n        return AVERROR(EIO);\n    }\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n        return AVERROR(EIO);\n    }\n    if (reserved != 0x55) {\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n    }\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n        return AVERROR(EIO);\n    }\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n        pva_pts = avio_rb32(pb);\n        length -= 4;\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n        /* PVA Audio Packets either start with a signaled PES packet or\n         * are a continuation of the previous PES packet. New PES packets\n         * always start at the beginning of a PVA Packet, never somewhere in\n         * the middle. */\n        if (!pvactx->continue_pes) {\n            int pes_signal, pes_header_data_length, pes_packet_length,\n                pes_flags;\n            unsigned char pes_header_data[256];\n\n            pes_signal             = avio_rb24(pb);\n            avio_r8(pb);\n            pes_packet_length      = avio_rb16(pb);\n             pes_flags              = avio_rb16(pb);\n             pes_header_data_length = avio_r8(pb);\n \n             if (pes_signal != 1 || pes_header_data_length == 0) {\n                 pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                           \"trying to recover\\n\");\n                avio_skip(pb, length - 9);\n                if (!read_packet)\n                    return AVERROR(EIO);\n                goto recover;\n            }\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n            if (ret != pes_header_data_length)\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n            length -= 9 + pes_header_data_length;\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n            pvactx->continue_pes = pes_packet_length;\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {\n                if (pes_header_data_length < 5) {\n                    pva_log(s, AV_LOG_ERROR, \"header too short\\n\");\n                    avio_skip(pb, length);\n                    return AVERROR_INVALIDDATA;\n                }\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n            }\n        }\n\n        pvactx->continue_pes -= length;\n\n        if (pvactx->continue_pes < 0) {\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n            pvactx->continue_pes = 0;\n        }\n    }\n\n    if (pva_pts != AV_NOPTS_VALUE)\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n    *pts   = pva_pts;\n    *len   = length;\n    *strid = streamid;\n    return 0;\n}\n",
        "post_patch": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n                               int *len, int *strid, int read_packet) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int syncword, streamid, reserved, flags, length, pts_flag;\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n    int ret;\n\nrecover:\n    startpos = avio_tell(pb);\n\n    syncword = avio_rb16(pb);\n    streamid = avio_r8(pb);\n    avio_r8(pb);               /* counter not used */\n    reserved = avio_r8(pb);\n    flags    = avio_r8(pb);\n    length   = avio_rb16(pb);\n\n    pts_flag = flags & 0x10;\n\n    if (syncword != PVA_MAGIC) {\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n        return AVERROR(EIO);\n    }\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n        return AVERROR(EIO);\n    }\n    if (reserved != 0x55) {\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n    }\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n        return AVERROR(EIO);\n    }\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n        pva_pts = avio_rb32(pb);\n        length -= 4;\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n        /* PVA Audio Packets either start with a signaled PES packet or\n         * are a continuation of the previous PES packet. New PES packets\n         * always start at the beginning of a PVA Packet, never somewhere in\n         * the middle. */\n        if (!pvactx->continue_pes) {\n            int pes_signal, pes_header_data_length, pes_packet_length,\n                pes_flags;\n            unsigned char pes_header_data[256];\n\n            pes_signal             = avio_rb24(pb);\n            avio_r8(pb);\n            pes_packet_length      = avio_rb16(pb);\n             pes_flags              = avio_rb16(pb);\n             pes_header_data_length = avio_r8(pb);\n \n            if (avio_feof(pb)) {\n                return AVERROR_EOF;\n            }\n\n             if (pes_signal != 1 || pes_header_data_length == 0) {\n                 pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                           \"trying to recover\\n\");\n                avio_skip(pb, length - 9);\n                if (!read_packet)\n                    return AVERROR(EIO);\n                goto recover;\n            }\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n            if (ret != pes_header_data_length)\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n            length -= 9 + pes_header_data_length;\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n            pvactx->continue_pes = pes_packet_length;\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {\n                if (pes_header_data_length < 5) {\n                    pva_log(s, AV_LOG_ERROR, \"header too short\\n\");\n                    avio_skip(pb, length);\n                    return AVERROR_INVALIDDATA;\n                }\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n            }\n        }\n\n        pvactx->continue_pes -= length;\n\n        if (pvactx->continue_pes < 0) {\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n            pvactx->continue_pes = 0;\n        }\n    }\n\n    if (pva_pts != AV_NOPTS_VALUE)\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n    *pts   = pva_pts;\n    *len   = length;\n    *strid = streamid;\n    return 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}\n",
        "post_patch": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "onig_get_match_stack_limit_size(void)\n{\n  return MatchStackLimitSize;\n}\n",
        "post_patch": "onig_get_match_stack_limit_size(void)\n{\n  return MatchStackLimitSize;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    PixelInfo\n      quantum_bits;\n\n    PixelPacket\n      shift;\n\n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset == 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MagickPathExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n           {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch (bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n            double\n              gamma;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MagickPathExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->alpha_trait=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    image->resolution.x=(double) bmp_info.x_pixels/100.0;\n    image->resolution.y=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n          We should ignore the alpha value in BMP3 files but there have been\n          reports about 32 bit files with alpha. We do a quick check to see if\n          the alpha channel contains a value that is not zero (default value).\n          If we find a non zero value we asume the program that wrote the file\n          wants to use the alpha channel.\n        */\n        if ((image->alpha_trait == UndefinedPixelTrait) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel == 32))\n          {\n            bytes_per_line=4*(image->columns);\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (*(p+3) != 0)\n                  {\n                    image->alpha_trait=BlendPixelTrait;\n                    y=-1;\n                    break;\n                  }\n                p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?\n          0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register unsigned int\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n            shift.red++;\n            if (shift.red >= 32U)\n              break;\n          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n            if (shift.green >= 32U)\n              break;\n          }\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if (shift.blue >= 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)\n          {\n            shift.alpha++;\n            if (shift.alpha >= 32U)\n              break;\n          }\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.red=(MagickRealType) (sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.green=(MagickRealType) (sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.blue=(MagickRealType) (sample-shift.blue);\n        sample=shift.alpha;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,\n              exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,\n                exception);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n              p++;\n              x++;\n            }\n          if (x < (ssize_t) image->columns)\n            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 16:\n      {\n        unsigned int\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha <= 8)\n                  alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha == 8)\n                  alpha|=(alpha >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    PixelInfo\n      quantum_bits;\n\n    PixelPacket\n      shift;\n\n    /*\n      Verify BMP identifier.\n    */\n    if (bmp_info.ba_offset == 0)\n      start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MagickPathExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n        if (bmp_info.number_colors > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n           {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch (bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n            double\n              gamma;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MagickPathExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            (void) ReadBlobLSBLong(image);  /* Profile data */\n            (void) ReadBlobLSBLong(image);  /* Profile size */\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->alpha_trait=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    image->resolution.x=(double) bmp_info.x_pixels/100.0;\n    image->resolution.y=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    if (((MagickSizeType) length/8) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n          We should ignore the alpha value in BMP3 files but there have been\n          reports about 32 bit files with alpha. We do a quick check to see if\n          the alpha channel contains a value that is not zero (default value).\n          If we find a non zero value we asume the program that wrote the file\n          wants to use the alpha channel.\n        */\n        if ((image->alpha_trait == UndefinedPixelTrait) && (bmp_info.size == 40) &&\n            (bmp_info.bits_per_pixel == 32))\n          {\n            bytes_per_line=4*(image->columns);\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (*(p+3) != 0)\n                  {\n                    image->alpha_trait=BlendPixelTrait;\n                    y=-1;\n                    break;\n                  }\n                p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?\n          0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register unsigned int\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n            shift.red++;\n            if (shift.red >= 32U)\n              break;\n          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n            if (shift.green >= 32U)\n              break;\n          }\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if (shift.blue >= 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)\n          {\n            shift.alpha++;\n            if (shift.alpha >= 32U)\n              break;\n          }\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.red=(MagickRealType) (sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.green=(MagickRealType) (sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.blue=(MagickRealType) (sample-shift.blue);\n        sample=shift.alpha;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,\n              exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,\n                exception);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n              p++;\n              x++;\n            }\n          if (x < (ssize_t) image->columns)\n            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 16:\n      {\n        unsigned int\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha <= 8)\n                  alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha == 8)\n                  alpha|=(alpha >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *magick='\\0';\n    if (bmp_info.ba_offset != 0)\n      {\n        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void __exit exit_nlm(void)\n{\n\t/* FIXME: delete all NLM clients */\n\tnlm_shutdown_hosts();\n\tlockd_remove_procfs();\n\tunregister_pernet_subsys(&lockd_net_ops);\n#ifdef CONFIG_SYSCTL\n\tunregister_sysctl_table(nlm_sysctl_table);\n#endif\n}\n",
        "post_patch": "static void __exit exit_nlm(void)\n{\n\t/* FIXME: delete all NLM clients */\n\tnlm_shutdown_hosts();\n\tlockd_remove_procfs();\n\tunregister_pernet_subsys(&lockd_net_ops);\n#ifdef CONFIG_SYSCTL\n\tunregister_sysctl_table(nlm_sysctl_table);\n#endif\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MagickPathExtent],\n    id[MagickPathExtent],\n    keyword[MagickPathExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MagickPathExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MagickPathExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MagickPathExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment,exception);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MagickPathExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MagickPathExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MagickPathExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'a':\n              case 'A':\n              {\n                if (LocaleCompare(keyword,\"alpha-trait\") == 0)\n                  {\n                    ssize_t\n                      alpha_trait;\n\n                    alpha_trait=ParseCommandOption(MagickPixelTraitOptions,\n                      MagickFalse,options);\n                    if (alpha_trait < 0)\n                      break;\n                    image->alpha_trait=(PixelTrait) alpha_trait;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->background_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->border_color,exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MagickPathExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mattecolor\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->matte_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'n':\n              case 'N':\n              {\n                if (LocaleCompare(keyword,\"number-channels\") == 0)\n                  {\n                    image->number_channels=StringToUnsignedLong(options);\n                    break;\n                  }\n                 if (LocaleCompare(keyword,\"number-meta-channels\") == 0)\n                   {\n                     image->number_meta_channels=StringToUnsignedLong(options);\n                     break;\n                   }\n                 break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile,exception);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->resolution.x=geometry_info.rho;\n                    image->resolution.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->resolution.y=image->resolution.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,\n                      MagickFalse,options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MagickPathExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MagickPathExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MagickPathExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              count=ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        /*\n          Create image colormap.\n        */\n        image->colormap=(PixelInfo *) AcquireQuantumMemory(image->colors+1,\n          sizeof(*image->colormap));\n        if (image->colormap == (PixelInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            size_t\n              packet_size;\n\n            unsigned char\n              *colormap;\n\n            /*\n              Read image colormap from file.\n            */\n            packet_size=(size_t) (3UL*depth/8UL);\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              {\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"InsufficientImageDataInFile\");\n              }\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "post_patch": "static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MagickPathExtent],\n    id[MagickPathExtent],\n    keyword[MagickPathExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MagickPathExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MagickPathExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MagickPathExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment,exception);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MagickPathExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MagickPathExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MagickPathExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'a':\n              case 'A':\n              {\n                if (LocaleCompare(keyword,\"alpha-trait\") == 0)\n                  {\n                    ssize_t\n                      alpha_trait;\n\n                    alpha_trait=ParseCommandOption(MagickPixelTraitOptions,\n                      MagickFalse,options);\n                    if (alpha_trait < 0)\n                      break;\n                    image->alpha_trait=(PixelTrait) alpha_trait;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->background_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->border_color,exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MagickPathExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mattecolor\") == 0)\n                  {\n                    (void) QueryColorCompliance(options,AllCompliance,\n                      &image->matte_color,exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'n':\n              case 'N':\n              {\n                if (LocaleCompare(keyword,\"number-channels\") == 0)\n                  {\n                    image->number_channels=StringToUnsignedLong(options);\n                    break;\n                  }\n                 if (LocaleCompare(keyword,\"number-meta-channels\") == 0)\n                   {\n                     image->number_meta_channels=StringToUnsignedLong(options);\n                    if (image->number_meta_channels > MaxPixelChannels)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                     break;\n                   }\n                 break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile,exception);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->resolution.x=geometry_info.rho;\n                    image->resolution.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->resolution.y=image->resolution.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,\n                      MagickFalse,options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options,exception);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MagickPathExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MagickPathExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MagickPathExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              count=ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        /*\n          Create image colormap.\n        */\n        image->colormap=(PixelInfo *) AcquireQuantumMemory(image->colors+1,\n          sizeof(*image->colormap));\n        if (image->colormap == (PixelInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            size_t\n              packet_size;\n\n            unsigned char\n              *colormap;\n\n            /*\n              Read image colormap from file.\n            */\n            packet_size=(size_t) (3UL*depth/8UL);\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              {\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"InsufficientImageDataInFile\");\n              }\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n \treturn new_ns;\n }\n",
        "post_patch": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n\tnew_ns->mounts = 0;\n\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ZSTD_buildCTable(void* dst, size_t dstCapacity,\n                FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,\n                U32* count, U32 max,\n                const BYTE* codeTable, size_t nbSeq,\n                const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,\n                const FSE_CTable* prevCTable, size_t prevCTableSize,\n                void* workspace, size_t workspaceSize)\n {\n     BYTE* op = (BYTE*)dst;\n     const BYTE* const oend = op + dstCapacity;\n \n     switch (type) {\n     case set_rle:\n        *op = codeTable[0];\n         CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));\n         return 1;\n     case set_repeat:\n         memcpy(nextCTable, prevCTable, prevCTableSize);\n        return 0;\n    case set_basic:\n        CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));  /* note : could be pre-calculated */\n        return 0;\n    case set_compressed: {\n        S16 norm[MaxSeq + 1];\n        size_t nbSeq_1 = nbSeq;\n        const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);\n        if (count[codeTable[nbSeq-1]] > 1) {\n            count[codeTable[nbSeq-1]]--;\n            nbSeq_1--;\n        }\n        assert(nbSeq_1 > 1);\n        CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));\n        {   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);   /* overflow protected */\n            if (FSE_isError(NCountSize)) return NCountSize;\n            CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));\n            return NCountSize;\n        }\n    }\n    default: return assert(0), ERROR(GENERIC);\n    }\n}\n",
        "post_patch": "ZSTD_buildCTable(void* dst, size_t dstCapacity,\n                FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,\n                U32* count, U32 max,\n                const BYTE* codeTable, size_t nbSeq,\n                const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,\n                const FSE_CTable* prevCTable, size_t prevCTableSize,\n                void* workspace, size_t workspaceSize)\n {\n     BYTE* op = (BYTE*)dst;\n     const BYTE* const oend = op + dstCapacity;\n    DEBUGLOG(6, \"ZSTD_buildCTable (dstCapacity=%u)\", (unsigned)dstCapacity);\n \n     switch (type) {\n     case set_rle:\n         CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));\n        if (dstCapacity==0) return ERROR(dstSize_tooSmall);\n        *op = codeTable[0];\n         return 1;\n     case set_repeat:\n         memcpy(nextCTable, prevCTable, prevCTableSize);\n        return 0;\n    case set_basic:\n        CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));  /* note : could be pre-calculated */\n        return 0;\n    case set_compressed: {\n        S16 norm[MaxSeq + 1];\n        size_t nbSeq_1 = nbSeq;\n        const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);\n        if (count[codeTable[nbSeq-1]] > 1) {\n            count[codeTable[nbSeq-1]]--;\n            nbSeq_1--;\n        }\n        assert(nbSeq_1 > 1);\n        CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));\n        {   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);   /* overflow protected */\n            if (FSE_isError(NCountSize)) return NCountSize;\n            CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));\n            return NCountSize;\n        }\n    }\n    default: return assert(0), ERROR(GENERIC);\n    }\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int __init pf_init(void)\n{\t\t\t\t/* preliminary initialisation */\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n \tpf_busy = 0;\n \n \tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n \t\t\tput_disk(pf->disk);\n \t\treturn -EBUSY;\n \t}\n \n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}\n",
        "post_patch": "static int __init pf_init(void)\n{\t\t\t\t/* preliminary initialisation */\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n \tpf_busy = 0;\n \n \tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\t\tif (!pf->disk)\n\t\t\t\tcontinue;\n\t\t\tblk_cleanup_queue(pf->disk->queue);\n\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n \t\t\tput_disk(pf->disk);\n\t\t}\n \t\treturn -EBUSY;\n \t}\n \n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int svc_rdma_secure_port(struct svc_rqst *rqstp)\n{\n\treturn 1;\n}\n",
        "post_patch": "static int svc_rdma_secure_port(struct svc_rqst *rqstp)\n{\n\treturn 1;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void ThreadHeap::WriteBarrier(void* value) {\n  DCHECK(thread_state_->IsIncrementalMarking());\n  DCHECK(value);\n  DCHECK_NE(value, reinterpret_cast<void*>(-1));\n\n  BasePage* const page = PageFromObject(value);\n  HeapObjectHeader* const header =\n      page->IsLargeObjectPage()\n          ? static_cast<LargeObjectPage*>(page)->GetHeapObjectHeader()\n          : static_cast<NormalPage*>(page)->FindHeaderFromAddress(\n                reinterpret_cast<Address>(const_cast<void*>(value)));\n  if (header->IsMarked())\n    return;\n\n   header->Mark();\n   marking_worklist_->Push(\n       WorklistTaskId::MainThread,\n      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n }\n",
        "post_patch": "void ThreadHeap::WriteBarrier(void* value) {\n  DCHECK(thread_state_->IsIncrementalMarking());\n  DCHECK(value);\n  DCHECK_NE(value, reinterpret_cast<void*>(-1));\n\n  BasePage* const page = PageFromObject(value);\n  HeapObjectHeader* const header =\n      page->IsLargeObjectPage()\n          ? static_cast<LargeObjectPage*>(page)->GetHeapObjectHeader()\n          : static_cast<NormalPage*>(page)->FindHeaderFromAddress(\n                reinterpret_cast<Address>(const_cast<void*>(value)));\n  if (header->IsMarked())\n    return;\n\n   header->Mark();\n   marking_worklist_->Push(\n       WorklistTaskId::MainThread,\n      {header->Payload(),\n       GCInfoTable::Get().GCInfoFromIndex(header->GcInfoIndex())->trace_});\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static inline unsigned char *PopHexPixel(const char *const *hex_digits,\n  const size_t pixel,unsigned char *pixels)\n{\n  register const char\n    *hex;\n\n  hex=hex_digits[pixel];\n  *pixels++=(unsigned char) (*hex++);\n  *pixels++=(unsigned char) (*hex);\n  return(pixels);\n}\n",
        "post_patch": "static inline unsigned char *PopHexPixel(const char *const *hex_digits,\n  const size_t pixel,unsigned char *pixels)\n{\n  register const char\n    *hex;\n\n  hex=hex_digits[pixel];\n  *pixels++=(unsigned char) (*hex++);\n  *pixels++=(unsigned char) (*hex);\n  return(pixels);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void SyncBackendHost::Core::SaveChanges() {\n  DCHECK_EQ(MessageLoop::current(), sync_loop_);\n  sync_manager_->SaveChanges();\n}\n",
        "post_patch": "void SyncBackendHost::Core::SaveChanges() {\n  DCHECK_EQ(MessageLoop::current(), sync_loop_);\n  sync_manager_->SaveChanges();\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n             if (!strncmp (prop_chunk, \"SND \", 4)) {\n                 char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                 uint16_t numChannels = 0, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n \n                 while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                     memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\n                                error_line (\"%s is not a valid .DFF file!\", infilename);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n         }\n         else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n \n            if (!config->num_channels) {\n                 error_line (\"%s is not a valid .DFF file!\", infilename);\n                 return WAVPACK_SOFT_ERROR;\n             }\n\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
        "post_patch": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n             if (!strncmp (prop_chunk, \"SND \", 4)) {\n                 char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                 uint16_t numChannels = 0, chansSpecified, chanMask = 0;\n                uint32_t sampleRate = 0;\n \n                 while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                     memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\n                                error_line (\"%s is not a valid .DFF file!\", infilename);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n         }\n         else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n \n            if (!config->num_channels || !config->sample_rate) {\n                 error_line (\"%s is not a valid .DFF file!\", infilename);\n                 return WAVPACK_SOFT_ERROR;\n             }\n\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "find_matching_se(struct sched_entity **se, struct sched_entity **pse)\n{\n\tint se_depth, pse_depth;\n\n\t/*\n\t * preemption test can be made between sibling entities who are in the\n\t * same cfs_rq i.e who have a common parent. Walk up the hierarchy of\n\t * both tasks until we find their ancestors who are siblings of common\n\t * parent.\n\t */\n\n\t/* First walk up until both entities are at same depth */\n\tse_depth = (*se)->depth;\n\tpse_depth = (*pse)->depth;\n\n\twhile (se_depth > pse_depth) {\n\t\tse_depth--;\n\t\t*se = parent_entity(*se);\n\t}\n\n\twhile (pse_depth > se_depth) {\n\t\tpse_depth--;\n\t\t*pse = parent_entity(*pse);\n\t}\n\n\twhile (!is_same_group(*se, *pse)) {\n\t\t*se = parent_entity(*se);\n\t\t*pse = parent_entity(*pse);\n\t}\n}\n",
        "post_patch": "find_matching_se(struct sched_entity **se, struct sched_entity **pse)\n{\n\tint se_depth, pse_depth;\n\n\t/*\n\t * preemption test can be made between sibling entities who are in the\n\t * same cfs_rq i.e who have a common parent. Walk up the hierarchy of\n\t * both tasks until we find their ancestors who are siblings of common\n\t * parent.\n\t */\n\n\t/* First walk up until both entities are at same depth */\n\tse_depth = (*se)->depth;\n\tpse_depth = (*pse)->depth;\n\n\twhile (se_depth > pse_depth) {\n\t\tse_depth--;\n\t\t*se = parent_entity(*se);\n\t}\n\n\twhile (pse_depth > se_depth) {\n\t\tpse_depth--;\n\t\t*pse = parent_entity(*pse);\n\t}\n\n\twhile (!is_same_group(*se, *pse)) {\n\t\t*se = parent_entity(*se);\n\t\t*pse = parent_entity(*pse);\n\t}\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n \n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n \n \t\tdev_net_set(dev, net);\n \t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n",
        "post_patch": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n \n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n\t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err)\n\t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n \t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n \tbox = 0;\n \ttmpstream = 0;\n \n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n \t  '\"', boxinfo->name, '\"', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
        "post_patch": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n \tbox = 0;\n \ttmpstream = 0;\n \n\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: \"\n\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n \t  '\"', boxinfo->name, '\"', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int blk_complete_sgv4_hdr_rq(struct request *rq, struct sg_io_v4 *hdr,\n\t\t\t\t    struct bio *bio, struct bio *bidi_bio)\n{\n\tint ret = 0;\n\n\tdprintk(\"rq %p bio %p 0x%x\\n\", rq, bio, rq->errors);\n\t/*\n\t * fill in all the output members\n\t */\n\thdr->device_status = rq->errors & 0xff;\n\thdr->transport_status = host_byte(rq->errors);\n\thdr->driver_status = driver_byte(rq->errors);\n\thdr->info = 0;\n\tif (hdr->device_status || hdr->transport_status || hdr->driver_status)\n\t\thdr->info |= SG_INFO_CHECK;\n\thdr->response_len = 0;\n\n\tif (rq->sense_len && hdr->response) {\n\t\tint len = min_t(unsigned int, hdr->max_response_len,\n\t\t\t\t\trq->sense_len);\n\n\t\tret = copy_to_user((void __user *)(unsigned long)hdr->response,\n\t\t\t\t   rq->sense, len);\n\t\tif (!ret)\n\t\t\thdr->response_len = len;\n\t\telse\n\t\t\tret = -EFAULT;\n\t}\n\n\tif (rq->next_rq) {\n\t\thdr->dout_resid = rq->resid_len;\n\t\thdr->din_resid = rq->next_rq->resid_len;\n\t\tblk_rq_unmap_user(bidi_bio);\n\t\tblk_put_request(rq->next_rq);\n\t} else if (rq_data_dir(rq) == READ)\n\t\thdr->din_resid = rq->resid_len;\n\telse\n\t\thdr->dout_resid = rq->resid_len;\n\n\t/*\n\t * If the request generated a negative error number, return it\n\t * (providing we aren't already returning an error); if it's\n\t * just a protocol response (i.e. non negative), that gets\n\t * processed above.\n\t */\n\tif (!ret && rq->errors < 0)\n\t\tret = rq->errors;\n\n\tblk_rq_unmap_user(bio);\n\tif (rq->cmd != rq->__cmd)\n\t\tkfree(rq->cmd);\n\tblk_put_request(rq);\n\n\treturn ret;\n}\n",
        "post_patch": "static int blk_complete_sgv4_hdr_rq(struct request *rq, struct sg_io_v4 *hdr,\n\t\t\t\t    struct bio *bio, struct bio *bidi_bio)\n{\n\tint ret = 0;\n\n\tdprintk(\"rq %p bio %p 0x%x\\n\", rq, bio, rq->errors);\n\t/*\n\t * fill in all the output members\n\t */\n\thdr->device_status = rq->errors & 0xff;\n\thdr->transport_status = host_byte(rq->errors);\n\thdr->driver_status = driver_byte(rq->errors);\n\thdr->info = 0;\n\tif (hdr->device_status || hdr->transport_status || hdr->driver_status)\n\t\thdr->info |= SG_INFO_CHECK;\n\thdr->response_len = 0;\n\n\tif (rq->sense_len && hdr->response) {\n\t\tint len = min_t(unsigned int, hdr->max_response_len,\n\t\t\t\t\trq->sense_len);\n\n\t\tret = copy_to_user((void __user *)(unsigned long)hdr->response,\n\t\t\t\t   rq->sense, len);\n\t\tif (!ret)\n\t\t\thdr->response_len = len;\n\t\telse\n\t\t\tret = -EFAULT;\n\t}\n\n\tif (rq->next_rq) {\n\t\thdr->dout_resid = rq->resid_len;\n\t\thdr->din_resid = rq->next_rq->resid_len;\n\t\tblk_rq_unmap_user(bidi_bio);\n\t\tblk_put_request(rq->next_rq);\n\t} else if (rq_data_dir(rq) == READ)\n\t\thdr->din_resid = rq->resid_len;\n\telse\n\t\thdr->dout_resid = rq->resid_len;\n\n\t/*\n\t * If the request generated a negative error number, return it\n\t * (providing we aren't already returning an error); if it's\n\t * just a protocol response (i.e. non negative), that gets\n\t * processed above.\n\t */\n\tif (!ret && rq->errors < 0)\n\t\tret = rq->errors;\n\n\tblk_rq_unmap_user(bio);\n\tif (rq->cmd != rq->__cmd)\n\t\tkfree(rq->cmd);\n\tblk_put_request(rq);\n\n\treturn ret;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "error::Error GLES2DecoderImpl::HandleVertexAttribDivisorANGLE(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::VertexAttribDivisorANGLE& c =\n      *static_cast<const volatile gles2::cmds::VertexAttribDivisorANGLE*>(\n          cmd_data);\n  if (!features().angle_instanced_arrays)\n    return error::kUnknownCommand;\n\n  GLuint index = c.index;\n  GLuint divisor = c.divisor;\n  if (index >= group_->max_vertex_attribs()) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_VALUE,\n        \"glVertexAttribDivisorANGLE\", \"index out of range\");\n    return error::kNoError;\n  }\n\n  state_.vertex_attrib_manager->SetDivisor(\n      index,\n      divisor);\n  api()->glVertexAttribDivisorANGLEFn(index, divisor);\n  return error::kNoError;\n}\n",
        "post_patch": "error::Error GLES2DecoderImpl::HandleVertexAttribDivisorANGLE(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::VertexAttribDivisorANGLE& c =\n      *static_cast<const volatile gles2::cmds::VertexAttribDivisorANGLE*>(\n          cmd_data);\n  if (!features().angle_instanced_arrays)\n    return error::kUnknownCommand;\n\n  GLuint index = c.index;\n  GLuint divisor = c.divisor;\n  if (index >= group_->max_vertex_attribs()) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_VALUE,\n        \"glVertexAttribDivisorANGLE\", \"index out of range\");\n    return error::kNoError;\n  }\n\n  state_.vertex_attrib_manager->SetDivisor(\n      index,\n      divisor);\n  api()->glVertexAttribDivisorANGLEFn(index, divisor);\n  return error::kNoError;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "void pdo_stmt_init(TSRMLS_D)\n{\n\tzend_class_entry ce;\n\n\tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);\n\tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;\n\tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;\n\tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);\n\tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);\n\n\tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;\n\tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;\n\tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;\n\tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;\n\tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;\n\n\tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);\n\tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);\n \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */\n \tpdo_row_ce->create_object = pdo_row_new;\n \tpdo_row_ce->serialize = pdo_row_serialize;\n }\n",
        "post_patch": "void pdo_stmt_init(TSRMLS_D)\n{\n\tzend_class_entry ce;\n\n\tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);\n\tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;\n\tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;\n\tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);\n\tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);\n\n\tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;\n\tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;\n\tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;\n\tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;\n\tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;\n\n\tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);\n\tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);\n \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */\n \tpdo_row_ce->create_object = pdo_row_new;\n \tpdo_row_ce->serialize = pdo_row_serialize;\n\tpdo_row_ce->unserialize = zend_class_unserialize_deny;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tstruct ext4_ext_path *path, int flags,\n\t\t\tunsigned int allocated, ext4_fsblk_t newblock)\n{\n\tint ret = 0;\n\tint err = 0;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\n\text_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical \"\n\t\t  \"block %llu, max_blocks %u, flags %x, allocated %u\\n\",\n\t\t  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,\n\t\t  flags, allocated);\n\text4_ext_show_leaf(inode, path);\n\n\ttrace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,\n\t\t\t\t\t\t    newblock);\n\n\t/* get_block() before submit the IO, split the extent */\n\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\tret = ext4_split_unwritten_extents(handle, inode, map,\n\t\t\t\t\t\t   path, flags);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Flag the inode(non aio case) or end_io struct (aio case)\n\t\t * that this IO needs to conversion to written when IO is\n\t\t * completed\n\t\t */\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tmap->m_flags |= EXT4_MAP_UNINIT;\n\t\tgoto out;\n \t}\n \t/* IO end_io complete, convert the filled extent to written */\n \tif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n\t\tret = ext4_convert_unwritten_extents_endio(handle, inode,\n \t\t\t\t\t\t\tpath);\n \t\tif (ret >= 0) {\n \t\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t\t path, map->m_len);\n\t\t} else\n\t\t\terr = ret;\n\t\tgoto out2;\n\t}\n\t/* buffered IO case */\n\t/*\n\t * repeat fallocate creation request\n\t * we already have an unwritten extent\n\t */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\n\t\tgoto map_out;\n\n\t/* buffered READ or buffered write_begin() lookup */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * We have blocks reserved already.  We\n\t\t * return allocated blocks so that delalloc\n\t\t * won't do block reservation for us.  But\n\t\t * the buffer head will be unmapped so that\n\t\t * a read from the block returns 0s.\n\t\t */\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out1;\n\t}\n\n\t/* buffered write, writepage time, convert*/\n\tret = ext4_ext_convert_to_initialized(handle, inode, map, path);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\nout:\n\tif (ret <= 0) {\n\t\terr = ret;\n\t\tgoto out2;\n\t} else\n\t\tallocated = ret;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\t/*\n\t * if we allocated more blocks than requested\n\t * we need to make sure we unmap the extra block\n\t * allocated. The actual needed block will get\n\t * unmapped later when we find the buffer_head marked\n\t * new.\n\t */\n\tif (allocated > map->m_len) {\n\t\tunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\n\t\t\t\t\tnewblock + map->m_len,\n\t\t\t\t\tallocated - map->m_len);\n\t\tallocated = map->m_len;\n\t}\n\n\t/*\n\t * If we have done fallocate with the offset that is already\n\t * delayed allocated, we would have block reservation\n\t * and quota reservation done in the delayed write path.\n\t * But fallocate would have already updated quota and block\n\t * count for this offset. So cancel these reservation\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\tmap->m_lblk, map->m_len);\n\t\tif (reserved_clusters)\n\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\t     reserved_clusters,\n\t\t\t\t\t\t     0);\n\t}\n\nmap_out:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk, path,\n\t\t\t\t\t map->m_len);\n\t\tif (err < 0)\n\t\t\tgoto out2;\n\t}\nout1:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}\n",
        "post_patch": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tstruct ext4_ext_path *path, int flags,\n\t\t\tunsigned int allocated, ext4_fsblk_t newblock)\n{\n\tint ret = 0;\n\tint err = 0;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\n\text_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical \"\n\t\t  \"block %llu, max_blocks %u, flags %x, allocated %u\\n\",\n\t\t  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,\n\t\t  flags, allocated);\n\text4_ext_show_leaf(inode, path);\n\n\ttrace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,\n\t\t\t\t\t\t    newblock);\n\n\t/* get_block() before submit the IO, split the extent */\n\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\tret = ext4_split_unwritten_extents(handle, inode, map,\n\t\t\t\t\t\t   path, flags);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Flag the inode(non aio case) or end_io struct (aio case)\n\t\t * that this IO needs to conversion to written when IO is\n\t\t * completed\n\t\t */\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tmap->m_flags |= EXT4_MAP_UNINIT;\n\t\tgoto out;\n \t}\n \t/* IO end_io complete, convert the filled extent to written */\n \tif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n\t\tret = ext4_convert_unwritten_extents_endio(handle, inode, map,\n \t\t\t\t\t\t\tpath);\n \t\tif (ret >= 0) {\n \t\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t\t path, map->m_len);\n\t\t} else\n\t\t\terr = ret;\n\t\tgoto out2;\n\t}\n\t/* buffered IO case */\n\t/*\n\t * repeat fallocate creation request\n\t * we already have an unwritten extent\n\t */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\n\t\tgoto map_out;\n\n\t/* buffered READ or buffered write_begin() lookup */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * We have blocks reserved already.  We\n\t\t * return allocated blocks so that delalloc\n\t\t * won't do block reservation for us.  But\n\t\t * the buffer head will be unmapped so that\n\t\t * a read from the block returns 0s.\n\t\t */\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out1;\n\t}\n\n\t/* buffered write, writepage time, convert*/\n\tret = ext4_ext_convert_to_initialized(handle, inode, map, path);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\nout:\n\tif (ret <= 0) {\n\t\terr = ret;\n\t\tgoto out2;\n\t} else\n\t\tallocated = ret;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\t/*\n\t * if we allocated more blocks than requested\n\t * we need to make sure we unmap the extra block\n\t * allocated. The actual needed block will get\n\t * unmapped later when we find the buffer_head marked\n\t * new.\n\t */\n\tif (allocated > map->m_len) {\n\t\tunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\n\t\t\t\t\tnewblock + map->m_len,\n\t\t\t\t\tallocated - map->m_len);\n\t\tallocated = map->m_len;\n\t}\n\n\t/*\n\t * If we have done fallocate with the offset that is already\n\t * delayed allocated, we would have block reservation\n\t * and quota reservation done in the delayed write path.\n\t * But fallocate would have already updated quota and block\n\t * count for this offset. So cancel these reservation\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\tmap->m_lblk, map->m_len);\n\t\tif (reserved_clusters)\n\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\t     reserved_clusters,\n\t\t\t\t\t\t     0);\n\t}\n\nmap_out:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk, path,\n\t\t\t\t\t map->m_len);\n\t\tif (err < 0)\n\t\t\tgoto out2;\n\t}\nout1:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "PS_SERIALIZER_ENCODE_FUNC(wddx)\n{\n\twddx_packet *packet;\n\tzend_string *str;\n\tPS_ENCODE_VARS;\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tPS_ENCODE_LOOP(\n\t\tphp_wddx_serialize_var(packet, struc, key);\n\t);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\tsmart_str_0(packet);\n\tstr = zend_string_copy(packet->s);\n\tphp_wddx_destructor(packet);\n\n\treturn str;\n}\n",
        "post_patch": "PS_SERIALIZER_ENCODE_FUNC(wddx)\n{\n\twddx_packet *packet;\n\tzend_string *str;\n\tPS_ENCODE_VARS;\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tPS_ENCODE_LOOP(\n\t\tphp_wddx_serialize_var(packet, struc, key);\n\t);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\tsmart_str_0(packet);\n\tstr = zend_string_copy(packet->s);\n\tphp_wddx_destructor(packet);\n\n\treturn str;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "bool PDFiumEngineExports::GetPDFDocInfo(const void* pdf_buffer,\n                                        int buffer_size,\n                                        int* page_count,\n                                        double* max_page_width) {\n  FPDF_DOCUMENT doc = FPDF_LoadMemDocument(pdf_buffer, buffer_size, nullptr);\n  if (!doc)\n    return false;\n  int page_count_local = FPDF_GetPageCount(doc);\n  if (page_count) {\n    *page_count = page_count_local;\n  }\n  if (max_page_width) {\n    *max_page_width = 0;\n    for (int page_number = 0; page_number < page_count_local; page_number++) {\n      double page_width = 0;\n      double page_height = 0;\n      FPDF_GetPageSizeByIndex(doc, page_number, &page_width, &page_height);\n      if (page_width > *max_page_width) {\n        *max_page_width = page_width;\n      }\n    }\n  }\n  FPDF_CloseDocument(doc);\n  return true;\n}\n",
        "post_patch": "bool PDFiumEngineExports::GetPDFDocInfo(const void* pdf_buffer,\n                                        int buffer_size,\n                                        int* page_count,\n                                        double* max_page_width) {\n  FPDF_DOCUMENT doc = FPDF_LoadMemDocument(pdf_buffer, buffer_size, nullptr);\n  if (!doc)\n    return false;\n  int page_count_local = FPDF_GetPageCount(doc);\n  if (page_count) {\n    *page_count = page_count_local;\n  }\n  if (max_page_width) {\n    *max_page_width = 0;\n    for (int page_number = 0; page_number < page_count_local; page_number++) {\n      double page_width = 0;\n      double page_height = 0;\n      FPDF_GetPageSizeByIndex(doc, page_number, &page_width, &page_height);\n      if (page_width > *max_page_width) {\n        *max_page_width = page_width;\n      }\n    }\n  }\n  FPDF_CloseDocument(doc);\n  return true;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,\n  PixelPacket *q,IndexPacket *indexes,ssize_t x)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      PixelPacket\n        *color;\n\n      if (type == 0)\n        {\n          if (packet_size == 1)\n            SetPixelIndex(indexes+x,ScaleQuantumToChar(pixel));\n          else\n            SetPixelIndex(indexes+x,ScaleQuantumToShort(pixel));\n        }\n      color=image->colormap+(ssize_t) ConstrainColormapIndex(image,\n        GetPixelIndex(indexes+x));\n      if ((type == 0) && (channels > 1))\n        return;\n      else\n        SetPixelAlpha(color,pixel);\n      SetPixelRGBO(q,color);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(q,pixel);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(q,pixel);\n      if (channels < 3 || type == -2)\n        {\n          SetPixelGreen(q,GetPixelRed(q));\n          SetPixelBlue(q,GetPixelRed(q));\n        }\n      break;\n    }\n    case 1:\n    {\n      SetPixelGreen(q,pixel);\n      break;\n    }\n    case 2:\n    {\n      SetPixelBlue(q,pixel);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(indexes+x,pixel);\n      else\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->matte != MagickFalse)\n        SetPixelAlpha(q,pixel);\n      break;\n    }\n  }\n}\n",
        "post_patch": "static inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,\n  PixelPacket *q,IndexPacket *indexes,ssize_t x)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      PixelPacket\n        *color;\n\n      if (type == 0)\n        {\n          if (packet_size == 1)\n            SetPixelIndex(indexes+x,ScaleQuantumToChar(pixel));\n          else\n            SetPixelIndex(indexes+x,ScaleQuantumToShort(pixel));\n        }\n      color=image->colormap+(ssize_t) ConstrainColormapIndex(image,\n        GetPixelIndex(indexes+x));\n      if ((type == 0) && (channels > 1))\n        return;\n      else\n        SetPixelAlpha(color,pixel);\n      SetPixelRGBO(q,color);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(q,pixel);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(q,pixel);\n      if (channels < 3 || type == -2)\n        {\n          SetPixelGreen(q,GetPixelRed(q));\n          SetPixelBlue(q,GetPixelRed(q));\n        }\n      break;\n    }\n    case 1:\n    {\n      SetPixelGreen(q,pixel);\n      break;\n    }\n    case 2:\n    {\n      SetPixelBlue(q,pixel);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(indexes+x,pixel);\n      else\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->matte != MagickFalse)\n        SetPixelAlpha(q,pixel);\n      break;\n    }\n  }\n}\n",
        "label": 0
    },
    {
        "pre_patch": "    OVS_REQUIRES(ofproto_mutex)\n{\n    heap_change(&table->eviction_groups_by_size, &evg->size_node,\n                eviction_group_priority(heap_count(&evg->rules)));\n}\n",
        "post_patch": "    OVS_REQUIRES(ofproto_mutex)\n{\n    heap_change(&table->eviction_groups_by_size, &evg->size_node,\n                eviction_group_priority(heap_count(&evg->rules)));\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n \n   CalculateVisiblePages();\n   return most_visible_page_;\n }\n",
        "post_patch": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n \n  // We can call GetMostVisiblePage through a callback from PDFium. We have\n  // to defer the page deletion otherwise we could potentially delete the page\n  // that originated the calling JS request and destroy the objects that are\n  // currently being used.\n  defer_page_unload_ = true;\n   CalculateVisiblePages();\n  defer_page_unload_ = false;\n   return most_visible_page_;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n \tint ret;\n \n\tspin_lock_irqsave(&dev->lock, flags);\n \n \tbuf[0] = CP2112_GPIO_SET;\n \tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n \tif (ret < 0)\n \t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n \n\tspin_unlock_irqrestore(&dev->lock, flags);\n }\n",
        "post_patch": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n \tint ret;\n \n\tmutex_lock(&dev->lock);\n \n \tbuf[0] = CP2112_GPIO_SET;\n \tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n \tif (ret < 0)\n \t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n \n\tmutex_unlock(&dev->lock);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int string_cmp_ic(OnigEncoding enc, int case_fold_flag,\n\t\t\t UChar* s1, UChar** ps2, int mblen)\n{\n  UChar buf1[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar buf2[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *p1, *p2, *end1, *s2, *end2;\n  int len1, len2;\n\n  s2   = *ps2;\n  end1 = s1 + mblen;\n  end2 = s2 + mblen;\n  while (s1 < end1) {\n    len1 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s1, end1, buf1);\n    len2 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s2, end2, buf2);\n    if (len1 != len2) return 0;\n    p1 = buf1;\n    p2 = buf2;\n    while (len1-- > 0) {\n      if (*p1 != *p2) return 0;\n      p1++;\n      p2++;\n    }\n  }\n\n  *ps2 = s2;\n  return 1;\n}\n",
        "post_patch": "static int string_cmp_ic(OnigEncoding enc, int case_fold_flag,\n\t\t\t UChar* s1, UChar** ps2, int mblen)\n{\n  UChar buf1[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar buf2[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *p1, *p2, *end1, *s2, *end2;\n  int len1, len2;\n\n  s2   = *ps2;\n  end1 = s1 + mblen;\n  end2 = s2 + mblen;\n  while (s1 < end1) {\n    len1 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s1, end1, buf1);\n    len2 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s2, end2, buf2);\n    if (len1 != len2) return 0;\n    p1 = buf1;\n    p2 = buf2;\n    while (len1-- > 0) {\n      if (*p1 != *p2) return 0;\n      p1++;\n      p2++;\n    }\n  }\n\n  *ps2 = s2;\n  return 1;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int ion_handle_put(struct ion_handle *handle)\n {\n \tstruct ion_client *client = handle->client;\n \tint ret;\n \n \tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n \tmutex_unlock(&client->lock);\n \n \treturn ret;\n}\n",
        "post_patch": "static int ion_handle_put(struct ion_handle *handle)\nstatic int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\n\treturn ret;\n}\n\nint ion_handle_put(struct ion_handle *handle)\n {\n \tstruct ion_client *client = handle->client;\n \tint ret;\n \n \tmutex_lock(&client->lock);\n\tret = ion_handle_put_nolock(handle);\n \tmutex_unlock(&client->lock);\n \n \treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "pdf14_clist_stroke_path(gx_device *dev,\tconst gs_gstate *pgs,\n                             gx_path *ppath, const gx_stroke_params *params,\n                             const gx_drawing_color *pdcolor,\n                             const gx_clip_path *pcpath)\n{\n    pdf14_clist_device * pdev = (pdf14_clist_device *)dev;\n    gs_gstate new_pgs = *pgs;\n    int code;\n    gs_pattern2_instance_t *pinst = NULL;\n\n    /*\n     * Ensure that that the PDF 1.4 reading compositor will have the current\n     * blending parameters.  This is needed since the fill_rectangle routines\n     * do not have access to the gs_gstate.  Thus we have to pass any\n     * changes explictly.\n     */\n    code = pdf14_clist_update_params(pdev, pgs, false, NULL);\n    if (code < 0)\n        return code;\n    /* If we are doing a shading stroke and we are in a transparency group of a\n       different color space, then we need to get the proper device information\n       passed along so that we use the correct color procs and colorinfo about\n       the transparency device and not the final target device */\n    if (pdcolor != NULL && gx_dc_is_pattern2_color(pdcolor) &&\n        pdev->trans_group_parent_cmap_procs != NULL) {\n        pinst =\n            (gs_pattern2_instance_t *)pdcolor->ccolor.pattern;\n           pinst->saved->has_transparency = true;\n           /* The transparency color space operations are driven\n              by the pdf14 clist writer device.  */\n           pinst->saved->trans_device = dev;\n    }\n\n    update_lop_for_pdf14(&new_pgs, pdcolor);\n    new_pgs.trans_device = dev;\n    new_pgs.has_transparency = true;\n    code = gx_forward_stroke_path(dev, &new_pgs, ppath, params, pdcolor, pcpath);\n    new_pgs.trans_device = NULL;\n    new_pgs.has_transparency = false;\n    if (pinst != NULL){\n        pinst->saved->trans_device = NULL;\n    }\n    return code;\n}\n",
        "post_patch": "pdf14_clist_stroke_path(gx_device *dev,\tconst gs_gstate *pgs,\n                             gx_path *ppath, const gx_stroke_params *params,\n                             const gx_drawing_color *pdcolor,\n                             const gx_clip_path *pcpath)\n{\n    pdf14_clist_device * pdev = (pdf14_clist_device *)dev;\n    gs_gstate new_pgs = *pgs;\n    int code;\n    gs_pattern2_instance_t *pinst = NULL;\n\n    /*\n     * Ensure that that the PDF 1.4 reading compositor will have the current\n     * blending parameters.  This is needed since the fill_rectangle routines\n     * do not have access to the gs_gstate.  Thus we have to pass any\n     * changes explictly.\n     */\n    code = pdf14_clist_update_params(pdev, pgs, false, NULL);\n    if (code < 0)\n        return code;\n    /* If we are doing a shading stroke and we are in a transparency group of a\n       different color space, then we need to get the proper device information\n       passed along so that we use the correct color procs and colorinfo about\n       the transparency device and not the final target device */\n    if (pdcolor != NULL && gx_dc_is_pattern2_color(pdcolor) &&\n        pdev->trans_group_parent_cmap_procs != NULL) {\n        pinst =\n            (gs_pattern2_instance_t *)pdcolor->ccolor.pattern;\n           pinst->saved->has_transparency = true;\n           /* The transparency color space operations are driven\n              by the pdf14 clist writer device.  */\n           pinst->saved->trans_device = dev;\n    }\n\n    update_lop_for_pdf14(&new_pgs, pdcolor);\n    new_pgs.trans_device = dev;\n    new_pgs.has_transparency = true;\n    code = gx_forward_stroke_path(dev, &new_pgs, ppath, params, pdcolor, pcpath);\n    new_pgs.trans_device = NULL;\n    new_pgs.has_transparency = false;\n    if (pinst != NULL){\n        pinst->saved->trans_device = NULL;\n    }\n    return code;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
        "post_patch": "epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n \tif (ret)\n \t\tgoto out;\n \tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n \tif (p->io_context)\n \t\tret = p->io_context->ioprio;\n out:\n \treturn ret;\n }\n",
        "post_patch": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n \tif (ret)\n \t\tgoto out;\n \tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n \tif (p->io_context)\n \t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\n out:\n \treturn ret;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n\tio->io_cleanup = port_cleanup;\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint I/O regions in their ACPI\n\t * tables.  This causes problems when trying to register the\n\t * entire I/O region.  Therefore we must register each I/O\n\t * port separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n \t\t\treturn -EIO;\n \t\t}\n \t}\n \treturn 0;\n }\n",
        "post_patch": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint I/O regions in their ACPI\n\t * tables.  This causes problems when trying to register the\n\t * entire I/O region.  Therefore we must register each I/O\n\t * port separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n \t\t\treturn -EIO;\n \t\t}\n \t}\n\n\tio->io_cleanup = port_cleanup;\n\n \treturn 0;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
        "post_patch": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void ImageLoader::setImage(CachedImage* newImage)\n{\n    setImageWithoutConsideringPendingLoadEvent(newImage);\n\n    updatedHasPendingEvent();\n}\n",
        "post_patch": "void ImageLoader::setImage(CachedImage* newImage)\n{\n    setImageWithoutConsideringPendingLoadEvent(newImage);\n\n    updatedHasPendingEvent();\n}\n",
        "label": 0
    },
    {
        "pre_patch": "ofputil_encode_meter_request(enum ofp_version ofp_version,\n                             enum ofputil_meter_request_type type,\n                             uint32_t meter_id)\n{\n    struct ofpbuf *msg;\n\n    enum ofpraw raw;\n\n    switch (type) {\n    case OFPUTIL_METER_CONFIG:\n        raw = OFPRAW_OFPST13_METER_CONFIG_REQUEST;\n        break;\n    case OFPUTIL_METER_STATS:\n        raw = OFPRAW_OFPST13_METER_REQUEST;\n        break;\n    default:\n    case OFPUTIL_METER_FEATURES:\n        raw = OFPRAW_OFPST13_METER_FEATURES_REQUEST;\n        break;\n    }\n\n    msg = ofpraw_alloc(raw, ofp_version, 0);\n\n    if (type != OFPUTIL_METER_FEATURES) {\n        struct ofp13_meter_multipart_request *omr;\n        omr = ofpbuf_put_zeros(msg, sizeof *omr);\n        omr->meter_id = htonl(meter_id);\n    }\n    return msg;\n}\n",
        "post_patch": "ofputil_encode_meter_request(enum ofp_version ofp_version,\n                             enum ofputil_meter_request_type type,\n                             uint32_t meter_id)\n{\n    struct ofpbuf *msg;\n\n    enum ofpraw raw;\n\n    switch (type) {\n    case OFPUTIL_METER_CONFIG:\n        raw = OFPRAW_OFPST13_METER_CONFIG_REQUEST;\n        break;\n    case OFPUTIL_METER_STATS:\n        raw = OFPRAW_OFPST13_METER_REQUEST;\n        break;\n    default:\n    case OFPUTIL_METER_FEATURES:\n        raw = OFPRAW_OFPST13_METER_FEATURES_REQUEST;\n        break;\n    }\n\n    msg = ofpraw_alloc(raw, ofp_version, 0);\n\n    if (type != OFPUTIL_METER_FEATURES) {\n        struct ofp13_meter_multipart_request *omr;\n        omr = ofpbuf_put_zeros(msg, sizeof *omr);\n        omr->meter_id = htonl(meter_id);\n    }\n    return msg;\n}\n",
        "label": 0
    },
    {
        "pre_patch": " static void skcipher_release(void *private)\n {\n\tcrypto_free_skcipher(private);\n }\n",
        "post_patch": " static void skcipher_release(void *private)\n {\n\tstruct skcipher_tfm *tfm = private;\n\n\tcrypto_free_skcipher(tfm->skcipher);\n\tkfree(tfm);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static inline bool find_syn_match(const struct xt_entry_match *m)\n{\n\tconst struct xt_tcp *tcpinfo = (const struct xt_tcp *)m->data;\n\n\tif (strcmp(m->u.kernel.match->name, \"tcp\") == 0 &&\n\t    tcpinfo->flg_cmp & TCPHDR_SYN &&\n\t    !(tcpinfo->invflags & XT_TCP_INV_FLAGS))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "post_patch": "static inline bool find_syn_match(const struct xt_entry_match *m)\n{\n\tconst struct xt_tcp *tcpinfo = (const struct xt_tcp *)m->data;\n\n\tif (strcmp(m->u.kernel.match->name, \"tcp\") == 0 &&\n\t    tcpinfo->flg_cmp & TCPHDR_SYN &&\n\t    !(tcpinfo->invflags & XT_TCP_INV_FLAGS))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n {\n \tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n \n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n \t\tu8 cipso_len;\n \t\tu8 cipso_off;\n \t\tunsigned char *cipso_ptr;\n \t\tint iter;\n \t\tint optlen_new;\n \n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n \t\tcipso_len = cipso_ptr[1];\n \n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n \n \t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n \n \t\t/* determining the new total option length is tricky because of\n \t\t * the padding necessary, the only thing i can think to do at\n\t\t * this point is walk the options one-by-one, skipping the\n\t\t * padding at the end to determine the actual option size and\n \t\t * from there we can determine the new total option length */\n \t\titer = 0;\n \t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n \t\t\t\toptlen_new = iter;\n \t\t\t} else\n \t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n \t} else {\n \t\t/* only the cipso option was present on the socket so we can\n \t\t * remove the entire option struct */\n \t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n \t}\n \n \treturn hdr_delta;\n}\n",
        "post_patch": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\nstatic int cipso_v4_delopt(struct ip_options_rcu **opt_ptr)\n {\n \tint hdr_delta = 0;\n\tstruct ip_options_rcu *opt = *opt_ptr;\n \n\tif (opt->opt.srr || opt->opt.rr || opt->opt.ts || opt->opt.router_alert) {\n \t\tu8 cipso_len;\n \t\tu8 cipso_off;\n \t\tunsigned char *cipso_ptr;\n \t\tint iter;\n \t\tint optlen_new;\n \n\t\tcipso_off = opt->opt.cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->opt.__data[cipso_off];\n \t\tcipso_len = cipso_ptr[1];\n \n\t\tif (opt->opt.srr > opt->opt.cipso)\n\t\t\topt->opt.srr -= cipso_len;\n\t\tif (opt->opt.rr > opt->opt.cipso)\n\t\t\topt->opt.rr -= cipso_len;\n\t\tif (opt->opt.ts > opt->opt.cipso)\n\t\t\topt->opt.ts -= cipso_len;\n\t\tif (opt->opt.router_alert > opt->opt.cipso)\n\t\t\topt->opt.router_alert -= cipso_len;\n\t\topt->opt.cipso = 0;\n \n \t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->opt.optlen - cipso_off - cipso_len);\n \n \t\t/* determining the new total option length is tricky because of\n \t\t * the padding necessary, the only thing i can think to do at\n\t\t * this point is walk the options one-by-one, skipping the\n\t\t * padding at the end to determine the actual option size and\n \t\t * from there we can determine the new total option length */\n \t\titer = 0;\n \t\toptlen_new = 0;\n\t\twhile (iter < opt->opt.optlen)\n\t\t\tif (opt->opt.__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->opt.__data[iter + 1];\n \t\t\t\toptlen_new = iter;\n \t\t\t} else\n \t\t\t\titer++;\n\t\thdr_delta = opt->opt.optlen;\n\t\topt->opt.optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->opt.optlen;\n \t} else {\n \t\t/* only the cipso option was present on the socket so we can\n \t\t * remove the entire option struct */\n \t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->opt.optlen;\n\t\tcall_rcu(&opt->rcu, opt_kfree_rcu);\n \t}\n \n \treturn hdr_delta;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\t/* C1 described at the top of this file */\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\t/* C2 and C3 */\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n \n \t/*\n \t * Borrow tag from the first request since they can't\n\t * be in flight at the same time.\n \t */\n \tif (q->mq_ops) {\n \t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n \t\tflush_rq->tag = first_rq->tag;\n \t}\n \n \tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}\n",
        "post_patch": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\t/* C1 described at the top of this file */\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\t/* C2 and C3 */\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n \n \t/*\n \t * Borrow tag from the first request since they can't\n\t * be in flight at the same time. And acquire the tag's\n\t * ownership for flush req.\n \t */\n \tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n \t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n \t\tflush_rq->tag = first_rq->tag;\n\t\tfq->orig_rq = first_rq;\n\n\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n \t}\n \n \tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void ShellSurface::CreateShellSurfaceWidget(ui::WindowShowState show_state) {\n  DCHECK(enabled());\n  DCHECK(!widget_);\n\n  views::Widget::InitParams params;\n  params.type = views::Widget::InitParams::TYPE_WINDOW;\n  params.ownership = views::Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET;\n  params.delegate = this;\n  params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;\n  params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;\n  params.show_state = show_state;\n   params.parent =\n       ash::Shell::GetContainer(ash::Shell::GetPrimaryRootWindow(), container_);\n   params.bounds = initial_bounds_;\n  bool activatable = activatable_ && !surface_->GetHitTestBounds().IsEmpty();\n   params.activatable = activatable ? views::Widget::InitParams::ACTIVATABLE_YES\n                                    : views::Widget::InitParams::ACTIVATABLE_NO;\n \n  widget_ = new ShellSurfaceWidget(this);\n  widget_->Init(params);\n\n  widget_->set_movement_disabled(!initial_bounds_.IsEmpty());\n\n  aura::Window* window = widget_->GetNativeWindow();\n  window->SetName(\"ExoShellSurface\");\n  window->AddChild(surface_->window());\n  window->SetEventTargeter(base::WrapUnique(new CustomWindowTargeter));\n  SetApplicationId(window, &application_id_);\n  SetMainSurface(window, surface_);\n\n  window->AddObserver(this);\n  ash::wm::GetWindowState(window)->AddObserver(this);\n\n  if (parent_)\n    wm::AddTransientChild(parent_, window);\n\n  ash::wm::GetWindowState(window)->set_window_position_managed(\n      ash::wm::ToWindowShowState(ash::wm::WINDOW_STATE_TYPE_AUTO_POSITIONED) ==\n          show_state &&\n      initial_bounds_.IsEmpty());\n\n  views::FocusManager* focus_manager = widget_->GetFocusManager();\n  for (const auto& entry : kCloseWindowAccelerators) {\n    focus_manager->RegisterAccelerator(\n        ui::Accelerator(entry.keycode, entry.modifiers),\n        ui::AcceleratorManager::kNormalPriority, this);\n  }\n\n  pending_show_widget_ = true;\n}\n",
        "post_patch": "void ShellSurface::CreateShellSurfaceWidget(ui::WindowShowState show_state) {\n  DCHECK(enabled());\n  DCHECK(!widget_);\n\n  views::Widget::InitParams params;\n  params.type = views::Widget::InitParams::TYPE_WINDOW;\n  params.ownership = views::Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET;\n  params.delegate = this;\n  params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;\n  params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;\n  params.show_state = show_state;\n   params.parent =\n       ash::Shell::GetContainer(ash::Shell::GetPrimaryRootWindow(), container_);\n   params.bounds = initial_bounds_;\n  bool activatable = activatable_;\n  // ShellSurfaces in system modal container are only activatable if input\n  // region is non-empty. See OnCommitSurface() for more details.\n  if (container_ == ash::kShellWindowId_SystemModalContainer)\n    activatable &= !surface_->GetHitTestBounds().IsEmpty();\n   params.activatable = activatable ? views::Widget::InitParams::ACTIVATABLE_YES\n                                    : views::Widget::InitParams::ACTIVATABLE_NO;\n \n  widget_ = new ShellSurfaceWidget(this);\n  widget_->Init(params);\n\n  widget_->set_movement_disabled(!initial_bounds_.IsEmpty());\n\n  aura::Window* window = widget_->GetNativeWindow();\n  window->SetName(\"ExoShellSurface\");\n  window->AddChild(surface_->window());\n  window->SetEventTargeter(base::WrapUnique(new CustomWindowTargeter));\n  SetApplicationId(window, &application_id_);\n  SetMainSurface(window, surface_);\n\n  window->AddObserver(this);\n  ash::wm::GetWindowState(window)->AddObserver(this);\n\n  if (parent_)\n    wm::AddTransientChild(parent_, window);\n\n  ash::wm::GetWindowState(window)->set_window_position_managed(\n      ash::wm::ToWindowShowState(ash::wm::WINDOW_STATE_TYPE_AUTO_POSITIONED) ==\n          show_state &&\n      initial_bounds_.IsEmpty());\n\n  views::FocusManager* focus_manager = widget_->GetFocusManager();\n  for (const auto& entry : kCloseWindowAccelerators) {\n    focus_manager->RegisterAccelerator(\n        ui::Accelerator(entry.keycode, entry.modifiers),\n        ui::AcceleratorManager::kNormalPriority, this);\n  }\n\n  pending_show_widget_ = true;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\n\t/*\n\t * IOCTL_VMMDEV_REQUEST needs the buffer to be below 4G to avoid\n\t * the need for a bounce-buffer and another copy later on.\n\t */\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n \tif (!buf)\n \t\treturn -ENOMEM;\n \n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n \t\tret = -EFAULT;\n \t\tgoto out;\n \t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\n\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\n\treturn ret;\n}\n",
        "post_patch": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\n\t/*\n\t * IOCTL_VMMDEV_REQUEST needs the buffer to be below 4G to avoid\n\t * the need for a bounce-buffer and another copy later on.\n\t */\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n \tif (!buf)\n \t\treturn -ENOMEM;\n \n\t*((struct vbg_ioctl_hdr *)buf) = hdr;\n\tif (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr),\n\t\t\t   hdr.size_in - sizeof(hdr))) {\n \t\tret = -EFAULT;\n \t\tgoto out;\n \t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\n\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\n\treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n \n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n \n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n \n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \n \tusb_ep_free_request(io_data->ep, io_data->req);\n \n\tio_data->kiocb->private = NULL;\n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);\n\tkfree(io_data);\n}\n",
        "post_patch": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n \n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n \n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n \n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \n \tusb_ep_free_request(io_data->ep, io_data->req);\n \n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);\n\tkfree(io_data);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int try_smi_init(struct smi_info *new_smi)\n{\n\tint rv = 0;\n\tint i;\n\tchar *init_name = NULL;\n\n\tpr_info(\"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\n\",\n\t\tipmi_addr_src_to_str(new_smi->io.addr_source),\n\t\tsi_to_str[new_smi->io.si_type],\n\t\taddr_space_to_str[new_smi->io.addr_type],\n\t\tnew_smi->io.addr_data,\n\t\tnew_smi->io.slave_addr, new_smi->io.irq);\n\n\tswitch (new_smi->io.si_type) {\n\tcase SI_KCS:\n\t\tnew_smi->handlers = &kcs_smi_handlers;\n\t\tbreak;\n\n\tcase SI_SMIC:\n\t\tnew_smi->handlers = &smic_smi_handlers;\n\t\tbreak;\n\n\tcase SI_BT:\n\t\tnew_smi->handlers = &bt_smi_handlers;\n\t\tbreak;\n\n\tdefault:\n\t\t/* No support for anything else yet. */\n\t\trv = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tnew_smi->si_num = smi_num;\n\n\t/* Do this early so it's available for logs. */\n\tif (!new_smi->io.dev) {\n\t\tinit_name = kasprintf(GFP_KERNEL, \"ipmi_si.%d\",\n\t\t\t\t      new_smi->si_num);\n\n\t\t/*\n\t\t * If we don't already have a device from something\n\t\t * else (like PCI), then register a new one.\n\t\t */\n\t\tnew_smi->pdev = platform_device_alloc(\"ipmi_si\",\n\t\t\t\t\t\t      new_smi->si_num);\n\t\tif (!new_smi->pdev) {\n\t\t\tpr_err(\"Unable to allocate platform device\\n\");\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->io.dev = &new_smi->pdev->dev;\n\t\tnew_smi->io.dev->driver = &ipmi_platform_driver.driver;\n\t\t/* Nulled by device_add() */\n\t\tnew_smi->io.dev->init_name = init_name;\n\t}\n\n\t/* Allocate the state machine's data and initialize it. */\n\tnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\n\tif (!new_smi->si_sm) {\n\t\trv = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tnew_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,\n\t\t\t\t\t\t\t   &new_smi->io);\n\n\t/* Now that we know the I/O size, we can set up the I/O. */\n\trv = new_smi->io.io_setup(&new_smi->io);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev, \"Could not set up I/O space\\n\");\n\t\tgoto out_err;\n\t}\n\n\t/* Do low-level detection first. */\n\tif (new_smi->handlers->detect(new_smi->si_sm)) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Interface detection failed\\n\");\n\t\trv = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Attempt a get device id command.  If it fails, we probably\n\t * don't have a BMC here.\n\t */\n\trv = try_get_dev_id(new_smi);\n\tif (rv) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t       \"There appears to be no BMC at this location\\n\");\n\t\tgoto out_err;\n\t}\n\n\tsetup_oem_data_handler(new_smi);\n\tsetup_xaction_handlers(new_smi);\n\tcheck_for_broken_irqs(new_smi);\n\n\tnew_smi->waiting_msg = NULL;\n\tnew_smi->curr_msg = NULL;\n\tatomic_set(&new_smi->req_events, 0);\n\tnew_smi->run_to_completion = false;\n\tfor (i = 0; i < SI_NUM_STATS; i++)\n\t\tatomic_set(&new_smi->stats[i], 0);\n\n\tnew_smi->interrupt_disabled = true;\n\tatomic_set(&new_smi->need_watch, 0);\n\n\trv = try_enable_event_buffer(new_smi);\n\tif (rv == 0)\n\t\tnew_smi->has_event_buffer = true;\n\n\t/*\n\t * Start clearing the flags before we enable interrupts or the\n\t * timer to avoid racing with the timer.\n\t */\n\tstart_clear_flags(new_smi);\n\n\t/*\n\t * IRQ is defined to be set when non-zero.  req_events will\n\t * cause a global flags check that will enable interrupts.\n\t */\n\tif (new_smi->io.irq) {\n\t\tnew_smi->interrupt_disabled = false;\n\t\tatomic_set(&new_smi->req_events, 1);\n\t}\n\n\tif (new_smi->pdev && !new_smi->pdev_registered) {\n\t\trv = platform_device_add(new_smi->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Unable to register system interface device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->pdev_registered = true;\n\t}\n\n\tdev_set_drvdata(new_smi->io.dev, new_smi);\n\trv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to add device attributes: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\tnew_smi->dev_group_added = true;\n\n\trv = ipmi_register_smi(&handlers,\n\t\t\t       new_smi,\n\t\t\t       new_smi->io.dev,\n\t\t\t       new_smi->io.slave_addr);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to register device: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\n\t/* Don't increment till we know we have succeeded. */\n\tsmi_num++;\n\n\tdev_info(new_smi->io.dev, \"IPMI %s interface initialized\\n\",\n\t\t si_to_str[new_smi->io.si_type]);\n\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n \tkfree(init_name);\n \treturn rv;\n }\n",
        "post_patch": "static int try_smi_init(struct smi_info *new_smi)\n{\n\tint rv = 0;\n\tint i;\n\tchar *init_name = NULL;\n\n\tpr_info(\"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\n\",\n\t\tipmi_addr_src_to_str(new_smi->io.addr_source),\n\t\tsi_to_str[new_smi->io.si_type],\n\t\taddr_space_to_str[new_smi->io.addr_type],\n\t\tnew_smi->io.addr_data,\n\t\tnew_smi->io.slave_addr, new_smi->io.irq);\n\n\tswitch (new_smi->io.si_type) {\n\tcase SI_KCS:\n\t\tnew_smi->handlers = &kcs_smi_handlers;\n\t\tbreak;\n\n\tcase SI_SMIC:\n\t\tnew_smi->handlers = &smic_smi_handlers;\n\t\tbreak;\n\n\tcase SI_BT:\n\t\tnew_smi->handlers = &bt_smi_handlers;\n\t\tbreak;\n\n\tdefault:\n\t\t/* No support for anything else yet. */\n\t\trv = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tnew_smi->si_num = smi_num;\n\n\t/* Do this early so it's available for logs. */\n\tif (!new_smi->io.dev) {\n\t\tinit_name = kasprintf(GFP_KERNEL, \"ipmi_si.%d\",\n\t\t\t\t      new_smi->si_num);\n\n\t\t/*\n\t\t * If we don't already have a device from something\n\t\t * else (like PCI), then register a new one.\n\t\t */\n\t\tnew_smi->pdev = platform_device_alloc(\"ipmi_si\",\n\t\t\t\t\t\t      new_smi->si_num);\n\t\tif (!new_smi->pdev) {\n\t\t\tpr_err(\"Unable to allocate platform device\\n\");\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->io.dev = &new_smi->pdev->dev;\n\t\tnew_smi->io.dev->driver = &ipmi_platform_driver.driver;\n\t\t/* Nulled by device_add() */\n\t\tnew_smi->io.dev->init_name = init_name;\n\t}\n\n\t/* Allocate the state machine's data and initialize it. */\n\tnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\n\tif (!new_smi->si_sm) {\n\t\trv = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tnew_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,\n\t\t\t\t\t\t\t   &new_smi->io);\n\n\t/* Now that we know the I/O size, we can set up the I/O. */\n\trv = new_smi->io.io_setup(&new_smi->io);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev, \"Could not set up I/O space\\n\");\n\t\tgoto out_err;\n\t}\n\n\t/* Do low-level detection first. */\n\tif (new_smi->handlers->detect(new_smi->si_sm)) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Interface detection failed\\n\");\n\t\trv = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Attempt a get device id command.  If it fails, we probably\n\t * don't have a BMC here.\n\t */\n\trv = try_get_dev_id(new_smi);\n\tif (rv) {\n\t\tif (new_smi->io.addr_source)\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t       \"There appears to be no BMC at this location\\n\");\n\t\tgoto out_err;\n\t}\n\n\tsetup_oem_data_handler(new_smi);\n\tsetup_xaction_handlers(new_smi);\n\tcheck_for_broken_irqs(new_smi);\n\n\tnew_smi->waiting_msg = NULL;\n\tnew_smi->curr_msg = NULL;\n\tatomic_set(&new_smi->req_events, 0);\n\tnew_smi->run_to_completion = false;\n\tfor (i = 0; i < SI_NUM_STATS; i++)\n\t\tatomic_set(&new_smi->stats[i], 0);\n\n\tnew_smi->interrupt_disabled = true;\n\tatomic_set(&new_smi->need_watch, 0);\n\n\trv = try_enable_event_buffer(new_smi);\n\tif (rv == 0)\n\t\tnew_smi->has_event_buffer = true;\n\n\t/*\n\t * Start clearing the flags before we enable interrupts or the\n\t * timer to avoid racing with the timer.\n\t */\n\tstart_clear_flags(new_smi);\n\n\t/*\n\t * IRQ is defined to be set when non-zero.  req_events will\n\t * cause a global flags check that will enable interrupts.\n\t */\n\tif (new_smi->io.irq) {\n\t\tnew_smi->interrupt_disabled = false;\n\t\tatomic_set(&new_smi->req_events, 1);\n\t}\n\n\tif (new_smi->pdev && !new_smi->pdev_registered) {\n\t\trv = platform_device_add(new_smi->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(new_smi->io.dev,\n\t\t\t\t\"Unable to register system interface device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_err;\n\t\t}\n\t\tnew_smi->pdev_registered = true;\n\t}\n\n\tdev_set_drvdata(new_smi->io.dev, new_smi);\n\trv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to add device attributes: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\tnew_smi->dev_group_added = true;\n\n\trv = ipmi_register_smi(&handlers,\n\t\t\t       new_smi,\n\t\t\t       new_smi->io.dev,\n\t\t\t       new_smi->io.slave_addr);\n\tif (rv) {\n\t\tdev_err(new_smi->io.dev,\n\t\t\t\"Unable to register device: error %d\\n\",\n\t\t\trv);\n\t\tgoto out_err;\n\t}\n\n\t/* Don't increment till we know we have succeeded. */\n\tsmi_num++;\n\n\tdev_info(new_smi->io.dev, \"IPMI %s interface initialized\\n\",\n\t\t si_to_str[new_smi->io.si_type]);\n\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n\tif (rv && new_smi->io.io_cleanup) {\n\t\tnew_smi->io.io_cleanup(&new_smi->io);\n\t\tnew_smi->io.io_cleanup = NULL;\n\t}\n\n \tkfree(init_name);\n \treturn rv;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ResourceHostMsg_Request CreateXHRRequestWithOrigin(const char* origin) {\n   ResourceHostMsg_Request request;\n   request.method = \"GET\";\n  request.url = GURL(\"http://bar.com/simple_page.html\");\n  request.first_party_for_cookies = GURL(origin);\n   request.referrer_policy = blink::WebReferrerPolicyDefault;\n  request.headers = base::StringPrintf(\"Origin: %s\\r\\n\", origin);\n   request.load_flags = 0;\n   request.origin_pid = 0;\n   request.resource_type = RESOURCE_TYPE_XHR;\n  request.request_context = 0;\n  request.appcache_host_id = kAppCacheNoHostId;\n  request.download_to_file = false;\n  request.should_reset_appcache = false;\n  request.is_main_frame = true;\n  request.parent_is_main_frame = false;\n  request.parent_render_frame_id = -1;\n  request.transition_type = ui::PAGE_TRANSITION_LINK;\n  request.allow_download = true;\n   return request;\n }\n",
        "post_patch": "ResourceHostMsg_Request CreateXHRRequestWithOrigin(const char* origin) {\nResourceHostMsg_Request CreateXHRRequest(const char* url) {\n   ResourceHostMsg_Request request;\n   request.method = \"GET\";\n  request.url = GURL(url);\n   request.referrer_policy = blink::WebReferrerPolicyDefault;\n   request.load_flags = 0;\n   request.origin_pid = 0;\n   request.resource_type = RESOURCE_TYPE_XHR;\n  request.request_context = 0;\n  request.appcache_host_id = kAppCacheNoHostId;\n  request.download_to_file = false;\n  request.should_reset_appcache = false;\n  request.is_main_frame = true;\n  request.parent_is_main_frame = false;\n  request.parent_render_frame_id = -1;\n  request.transition_type = ui::PAGE_TRANSITION_LINK;\n  request.allow_download = true;\n   return request;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"EPI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n   entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\n   \"Encapsulated PostScript Interchange format\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Encapsulated PostScript\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPSF\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Encapsulated PostScript\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPSI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\n    \"Encapsulated PostScript Interchange format\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"PS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->mime_type=ConstantString(\"application/postscript\");\n   entry->module=ConstantString(\"PS\");\n  entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"PostScript\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "post_patch": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"EPI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->seekable_stream=MagickTrue;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n   entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\n   \"Encapsulated PostScript Interchange format\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Encapsulated PostScript\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPSF\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Encapsulated PostScript\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPSI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\n    \"Encapsulated PostScript Interchange format\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"PS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->mime_type=ConstantString(\"application/postscript\");\n   entry->module=ConstantString(\"PS\");\n  entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"PostScript\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "SECURITY_STATUS SEC_ENTRY EncryptMessage(PCtxtHandle phContext, ULONG fQOP, PSecBufferDesc pMessage, ULONG MessageSeqNo)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->EncryptMessage == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->EncryptMessage(phContext, fQOP, pMessage, MessageSeqNo);\n\n\treturn status;\n}\n",
        "post_patch": "SECURITY_STATUS SEC_ENTRY EncryptMessage(PCtxtHandle phContext, ULONG fQOP, PSecBufferDesc pMessage, ULONG MessageSeqNo)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->EncryptMessage == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->EncryptMessage(phContext, fQOP, pMessage, MessageSeqNo);\n\n\treturn status;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "nfsd_inject_recall_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}\n",
        "post_patch": "nfsd_inject_recall_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static void f2fs_submit_discard_endio(struct bio *bio)\n{\n\tstruct discard_cmd *dc = (struct discard_cmd *)bio->bi_private;\n\n\tdc->error = bio->bi_error;\n\tdc->state = D_DONE;\n\tcomplete_all(&dc->wait);\n\tbio_put(bio);\n}\n",
        "post_patch": "static void f2fs_submit_discard_endio(struct bio *bio)\n{\n\tstruct discard_cmd *dc = (struct discard_cmd *)bio->bi_private;\n\n\tdc->error = bio->bi_error;\n\tdc->state = D_DONE;\n\tcomplete_all(&dc->wait);\n\tbio_put(bio);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static RBinElfSection* get_sections_from_phdr(ELFOBJ *bin) {\n\tRBinElfSection *ret;\n\tint i, num_sections = 0;\n\tut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;\n\tut64 reldynsz = 0, relasz = 0, pltgotsz = 0;\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bin->dyn_entries; i++) {\n\t\tswitch (bin->dyn_buf[i].d_tag) {\n\t\tcase DT_REL:\n\t\t\treldyn = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELA:\n\t\t\trelva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELSZ:\n\t\t\treldynsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELASZ:\n\t\t\trelasz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTGOT:\n\t\t\tpltgotva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_PLTRELSZ:\n\t\t\tpltgotsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_JMPREL:\n\t\t\trelava = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tdefault: break;\n\t\t}\n\t}\n\tret = calloc (num_sections + 1, sizeof(RBinElfSection));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\ti = 0;\n\tif (reldyn) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, reldyn);\n\t\tret[i].rva = reldyn;\n\t\tret[i].size = reldynsz;\n\t\tstrcpy (ret[i].name, \".rel.dyn\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relava) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relava);\n\t\tret[i].rva = relava;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".rela.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relva);\n\t\tret[i].rva = relva;\n\t\tret[i].size = relasz;\n\t\tstrcpy (ret[i].name, \".rel.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (pltgotva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, pltgotva);\n\t\tret[i].rva = pltgotva;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".got.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tret[i].last = 1;\n\n\treturn ret;\n}\n",
        "post_patch": "static RBinElfSection* get_sections_from_phdr(ELFOBJ *bin) {\n\tRBinElfSection *ret;\n\tint i, num_sections = 0;\n\tut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;\n\tut64 reldynsz = 0, relasz = 0, pltgotsz = 0;\n\tif (!bin || !bin->phdr || !bin->ehdr.e_phnum)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bin->dyn_entries; i++) {\n\t\tswitch (bin->dyn_buf[i].d_tag) {\n\t\tcase DT_REL:\n\t\t\treldyn = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELA:\n\t\t\trelva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_RELSZ:\n\t\t\treldynsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_RELASZ:\n\t\t\trelasz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_PLTGOT:\n\t\t\tpltgotva = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tcase DT_PLTRELSZ:\n\t\t\tpltgotsz = bin->dyn_buf[i].d_un.d_val;\n\t\t\tbreak;\n\t\tcase DT_JMPREL:\n\t\t\trelava = bin->dyn_buf[i].d_un.d_ptr;\n\t\t\tnum_sections++;\n\t\t\tbreak;\n\t\tdefault: break;\n\t\t}\n\t}\n\tret = calloc (num_sections + 1, sizeof(RBinElfSection));\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\ti = 0;\n\tif (reldyn) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, reldyn);\n\t\tret[i].rva = reldyn;\n\t\tret[i].size = reldynsz;\n\t\tstrcpy (ret[i].name, \".rel.dyn\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relava) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relava);\n\t\tret[i].rva = relava;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".rela.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (relva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, relva);\n\t\tret[i].rva = relva;\n\t\tret[i].size = relasz;\n\t\tstrcpy (ret[i].name, \".rel.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tif (pltgotva) {\n\t\tret[i].offset = Elf_(r_bin_elf_v2p) (bin, pltgotva);\n\t\tret[i].rva = pltgotva;\n\t\tret[i].size = pltgotsz;\n\t\tstrcpy (ret[i].name, \".got.plt\");\n\t\tret[i].last = 0;\n\t\ti++;\n\t}\n\tret[i].last = 1;\n\n\treturn ret;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static void amd_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n",
        "post_patch": "static void amd_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n",
        "label": 0
    },
    {
        "pre_patch": " static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}\n/* }}} */\n",
        "post_patch": " static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n\tfpm_globals.listening_socket = dup(wp->listening_socket);\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}\n/* }}} */\n",
        "label": 1
    },
    {
        "pre_patch": "int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n     int format_chunk = 0;\n     uint32_t bcount;\n \n     infilesize = DoGetFileSize (infile);\n     memcpy (&filehdr, fourcc, 4);\n \n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            if (format_chunk++) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
        "post_patch": "int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n     int format_chunk = 0;\n     uint32_t bcount;\n \n    CLEAR (WaveHeader);\n     infilesize = DoGetFileSize (infile);\n     memcpy (&filehdr, fourcc, 4);\n \n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            if (format_chunk++) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n \txmlGenericError(xmlGenericErrorContext,\n \t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n     }\n     ret = inputPush(ctxt, input);\n     if (ctxt->instate == XML_PARSER_EOF)\n         return(-1);\n    GROW;\n    return(ret);\n}\n",
        "post_patch": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n \txmlGenericError(xmlGenericErrorContext,\n \t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n     }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n     ret = inputPush(ctxt, input);\n     if (ctxt->instate == XML_PARSER_EOF)\n         return(-1);\n    GROW;\n    return(ret);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n     goto MATLAB_KO;    /* unsupported endian */\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
        "post_patch": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n     goto MATLAB_KO;    /* unsupported endian */\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "email_close(FILE *mailer)\n{\n\tchar *temp;\n\tmode_t prev_umask;\n\tpriv_state priv;\n\tchar *customSig;\n\n\tif ( mailer == NULL ) {\n\t\treturn;\n\t}\n\n\t/* Want the letter to come from \"condor\" if possible */\n\tpriv = set_condor_priv();\n\n        customSig = NULL;\n        if ((customSig = param(\"EMAIL_SIGNATURE\")) != NULL) {\n                fprintf( mailer, \"\\n\\n\");\n               fprintf( mailer, customSig);\n                fprintf( mailer, \"\\n\");\n                free(customSig);\n        } else {\n\t\t\n\t\t/* Put a signature on the bottom of the email */\n\t\tfprintf( mailer, \"\\n\\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\\n\" );\n\t\tfprintf( mailer, \"Questions about this message or Condor in general?\\n\" );\n\n\t\t\t/* See if there's an address users should use for help */\n\t\ttemp = param( \"CONDOR_SUPPORT_EMAIL\" );\n\t\tif( ! temp ) {\n\t\t\ttemp = param( \"CONDOR_ADMIN\" );\n\t\t}\n\t\tif( temp ) {\n\t\t\tfprintf( mailer, \"Email address of the local Condor administrator: \"\n\t\t\t\t\t \"%s\\n\", temp );\n\t\t\tfree( temp );\n\t\t}\n\t\tfprintf( mailer, \"The Official Condor Homepage is \"\n\t\t\t\t \"http://www.cs.wisc.edu/condor\\n\" );\n\t}\n\n\tfflush(mailer);\n\t/* there are some oddities with how pclose can close a file. In some\n\t\tarches, pclose will create temp files for locking and they need to\n\t\tbe of the correct perms in order to be deleted. So the umask is\n\t\tset to something useable for the close operation. -pete 9/11/99\n\t*/\n\tprev_umask = umask(022);\n\t/* \n\t** we fclose() on UNIX, pclose on win32 \n\t*/\n#if defined(WIN32)\n\tif (EMAIL_FINAL_COMMAND == NULL) {\n\t\tmy_pclose( mailer );\n\t} else {\n\t\tchar *email_filename = NULL;\n\t\t/* Should this be a pclose??? -Erik 9/21/00 */ \n\t\tfclose( mailer );\n\t\tdprintf(D_FULLDEBUG,\"Sending email via system(%s)\\n\",\n\t\t\tEMAIL_FINAL_COMMAND);\n\t\tsystem(EMAIL_FINAL_COMMAND);\n\t\tif ( (email_filename=strrchr(EMAIL_FINAL_COMMAND,'<')) ) {\n\t\t\temail_filename++;\t/* go past the \"<\" */\n\t\t\temail_filename++;\t/* go past the space after the < */\n\t\t\tif ( unlink(email_filename) == -1 ) {\n\t\t\t\tdprintf(D_ALWAYS,\"email_close: cannot unlink temp file %s\\n\",\n\t\t\t\t\temail_filename);\n\t\t\t}\n\t\t}\n\t\tfree(EMAIL_FINAL_COMMAND);\n\t\tEMAIL_FINAL_COMMAND = NULL;\n\t}\n#else\n\t(void)fclose( mailer );\n#endif\n\tumask(prev_umask);\n\n\t/* Set priv state back */\n\tset_priv(priv);\n\n}\n",
        "post_patch": "email_close(FILE *mailer)\n{\n\tchar *temp;\n\tmode_t prev_umask;\n\tpriv_state priv;\n\tchar *customSig;\n\n\tif ( mailer == NULL ) {\n\t\treturn;\n\t}\n\n\t/* Want the letter to come from \"condor\" if possible */\n\tpriv = set_condor_priv();\n\n        customSig = NULL;\n        if ((customSig = param(\"EMAIL_SIGNATURE\")) != NULL) {\n                fprintf( mailer, \"\\n\\n\");\n               fprintf( mailer, \"%s\", customSig);\n                fprintf( mailer, \"\\n\");\n                free(customSig);\n        } else {\n\t\t\n\t\t/* Put a signature on the bottom of the email */\n\t\tfprintf( mailer, \"\\n\\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\\n\" );\n\t\tfprintf( mailer, \"Questions about this message or Condor in general?\\n\" );\n\n\t\t\t/* See if there's an address users should use for help */\n\t\ttemp = param( \"CONDOR_SUPPORT_EMAIL\" );\n\t\tif( ! temp ) {\n\t\t\ttemp = param( \"CONDOR_ADMIN\" );\n\t\t}\n\t\tif( temp ) {\n\t\t\tfprintf( mailer, \"Email address of the local Condor administrator: \"\n\t\t\t\t\t \"%s\\n\", temp );\n\t\t\tfree( temp );\n\t\t}\n\t\tfprintf( mailer, \"The Official Condor Homepage is \"\n\t\t\t\t \"http://www.cs.wisc.edu/condor\\n\" );\n\t}\n\n\tfflush(mailer);\n\t/* there are some oddities with how pclose can close a file. In some\n\t\tarches, pclose will create temp files for locking and they need to\n\t\tbe of the correct perms in order to be deleted. So the umask is\n\t\tset to something useable for the close operation. -pete 9/11/99\n\t*/\n\tprev_umask = umask(022);\n\t/* \n\t** we fclose() on UNIX, pclose on win32 \n\t*/\n#if defined(WIN32)\n\tif (EMAIL_FINAL_COMMAND == NULL) {\n\t\tmy_pclose( mailer );\n\t} else {\n\t\tchar *email_filename = NULL;\n\t\t/* Should this be a pclose??? -Erik 9/21/00 */ \n\t\tfclose( mailer );\n\t\tdprintf(D_FULLDEBUG,\"Sending email via system(%s)\\n\",\n\t\t\tEMAIL_FINAL_COMMAND);\n\t\tsystem(EMAIL_FINAL_COMMAND);\n\t\tif ( (email_filename=strrchr(EMAIL_FINAL_COMMAND,'<')) ) {\n\t\t\temail_filename++;\t/* go past the \"<\" */\n\t\t\temail_filename++;\t/* go past the space after the < */\n\t\t\tif ( unlink(email_filename) == -1 ) {\n\t\t\t\tdprintf(D_ALWAYS,\"email_close: cannot unlink temp file %s\\n\",\n\t\t\t\t\temail_filename);\n\t\t\t}\n\t\t}\n\t\tfree(EMAIL_FINAL_COMMAND);\n\t\tEMAIL_FINAL_COMMAND = NULL;\n\t}\n#else\n\t(void)fclose( mailer );\n#endif\n\tumask(prev_umask);\n\n\t/* Set priv state back */\n\tset_priv(priv);\n\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    unsigned long len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    unsigned long (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt)) {\n                ossl_statem_set_error(s);\n                return SUB_STATE_ERROR;\n            }\n\n            if (s->s3->tmp.message_size > max_message_size(s)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n                SSLerr(SSL_F_READ_STATE_MACHINE, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                 return SUB_STATE_ERROR;\n             }\n \n             st->read_state = READ_STATE_BODY;\n             /* Fall through */\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            default:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);\n            ossl_statem_set_error(s);\n            return SUB_STATE_ERROR;\n        }\n    }\n}\n",
        "post_patch": "static SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    unsigned long len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    unsigned long (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt)) {\n                ossl_statem_set_error(s);\n                return SUB_STATE_ERROR;\n            }\n\n            if (s->s3->tmp.message_size > max_message_size(s)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n                SSLerr(SSL_F_READ_STATE_MACHINE, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                 return SUB_STATE_ERROR;\n             }\n \n            /* dtls_get_message already did this */\n            if (!SSL_IS_DTLS(s)\n                    && s->s3->tmp.message_size > 0\n                    && !BUF_MEM_grow_clean(s->init_buf,\n                                           (int)s->s3->tmp.message_size\n                                           + SSL3_HM_HEADER_LENGTH)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);\n                return SUB_STATE_ERROR;\n            }\n\n             st->read_state = READ_STATE_BODY;\n             /* Fall through */\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            default:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);\n            ossl_statem_set_error(s);\n            return SUB_STATE_ERROR;\n        }\n    }\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static size_t ZSTD_initCDict_internal(\n                    ZSTD_CDict* cdict,\n              const void* dictBuffer, size_t dictSize,\n                    ZSTD_dictLoadMethod_e dictLoadMethod,\n                    ZSTD_dictContentType_e dictContentType,\n                    ZSTD_compressionParameters cParams)\n{\n    DEBUGLOG(3, \"ZSTD_initCDict_internal (dictContentType:%u)\", (U32)dictContentType);\n    assert(!ZSTD_checkCParams(cParams));\n    cdict->matchState.cParams = cParams;\n    if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dictBuffer) || (!dictSize)) {\n        cdict->dictBuffer = NULL;\n        cdict->dictContent = dictBuffer;\n    } else {\n        void* const internalBuffer = ZSTD_malloc(dictSize, cdict->customMem);\n        cdict->dictBuffer = internalBuffer;\n        cdict->dictContent = internalBuffer;\n        if (!internalBuffer) return ERROR(memory_allocation);\n        memcpy(internalBuffer, dictBuffer, dictSize);\n    }\n    cdict->dictContentSize = dictSize;\n\n    /* Reset the state to no dictionary */\n    ZSTD_reset_compressedBlockState(&cdict->cBlockState);\n    {   void* const end = ZSTD_reset_matchState(\n                &cdict->matchState,\n                (U32*)cdict->workspace + HUF_WORKSPACE_SIZE_U32,\n                &cParams, ZSTDcrp_continue, /* forCCtx */ 0);\n        assert(end == (char*)cdict->workspace + cdict->workspaceSize);\n        (void)end;\n    }\n    /* (Maybe) load the dictionary\n     * Skips loading the dictionary if it is <= 8 bytes.\n     */\n    {   ZSTD_CCtx_params params;\n        memset(&params, 0, sizeof(params));\n        params.compressionLevel = ZSTD_CLEVEL_DEFAULT;\n        params.fParams.contentSizeFlag = 1;\n        params.cParams = cParams;\n        {   size_t const dictID = ZSTD_compress_insertDictionary(\n                    &cdict->cBlockState, &cdict->matchState, &params,\n                    cdict->dictContent, cdict->dictContentSize,\n                    dictContentType, ZSTD_dtlm_full, cdict->workspace);\n            if (ZSTD_isError(dictID)) return dictID;\n            assert(dictID <= (size_t)(U32)-1);\n            cdict->dictID = (U32)dictID;\n        }\n    }\n\n    return 0;\n}\n",
        "post_patch": "static size_t ZSTD_initCDict_internal(\n                    ZSTD_CDict* cdict,\n              const void* dictBuffer, size_t dictSize,\n                    ZSTD_dictLoadMethod_e dictLoadMethod,\n                    ZSTD_dictContentType_e dictContentType,\n                    ZSTD_compressionParameters cParams)\n{\n    DEBUGLOG(3, \"ZSTD_initCDict_internal (dictContentType:%u)\", (U32)dictContentType);\n    assert(!ZSTD_checkCParams(cParams));\n    cdict->matchState.cParams = cParams;\n    if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dictBuffer) || (!dictSize)) {\n        cdict->dictBuffer = NULL;\n        cdict->dictContent = dictBuffer;\n    } else {\n        void* const internalBuffer = ZSTD_malloc(dictSize, cdict->customMem);\n        cdict->dictBuffer = internalBuffer;\n        cdict->dictContent = internalBuffer;\n        if (!internalBuffer) return ERROR(memory_allocation);\n        memcpy(internalBuffer, dictBuffer, dictSize);\n    }\n    cdict->dictContentSize = dictSize;\n\n    /* Reset the state to no dictionary */\n    ZSTD_reset_compressedBlockState(&cdict->cBlockState);\n    {   void* const end = ZSTD_reset_matchState(\n                &cdict->matchState,\n                (U32*)cdict->workspace + HUF_WORKSPACE_SIZE_U32,\n                &cParams, ZSTDcrp_continue, /* forCCtx */ 0);\n        assert(end == (char*)cdict->workspace + cdict->workspaceSize);\n        (void)end;\n    }\n    /* (Maybe) load the dictionary\n     * Skips loading the dictionary if it is <= 8 bytes.\n     */\n    {   ZSTD_CCtx_params params;\n        memset(&params, 0, sizeof(params));\n        params.compressionLevel = ZSTD_CLEVEL_DEFAULT;\n        params.fParams.contentSizeFlag = 1;\n        params.cParams = cParams;\n        {   size_t const dictID = ZSTD_compress_insertDictionary(\n                    &cdict->cBlockState, &cdict->matchState, &params,\n                    cdict->dictContent, cdict->dictContentSize,\n                    dictContentType, ZSTD_dtlm_full, cdict->workspace);\n            if (ZSTD_isError(dictID)) return dictID;\n            assert(dictID <= (size_t)(U32)-1);\n            cdict->dictID = (U32)dictID;\n        }\n    }\n\n    return 0;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n \t}\n \n \tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n",
        "post_patch": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n \t}\n \n \tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\n\t/* Check the TFD_* constants for consistency.  */\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n \t\treturn -ENOMEM;\n \n \tinit_waitqueue_head(&ctx->wqh);\n \tctx->clockid = clockid;\n \n \tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\n\tctx->moffs = ktime_mono_to_real(0);\n\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\n\treturn ufd;\n}\n",
        "post_patch": "SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\n\t/* Check the TFD_* constants for consistency.  */\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n \t\treturn -ENOMEM;\n \n \tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n \tctx->clockid = clockid;\n \n \tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\n\tctx->moffs = ktime_mono_to_real(0);\n\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\n\treturn ufd;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "mrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n",
        "post_patch": "mrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n",
        "label": 0
    },
    {
        "pre_patch": "xfs_inode_ag_iterator_flags(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\titer_flags)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1,\n\t\t\t\t\t  iter_flags);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}\n",
        "post_patch": "xfs_inode_ag_iterator_flags(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\titer_flags)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1,\n\t\t\t\t\t  iter_flags);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n \t\t\t\tstruct pipe_buffer *buf)\n {\n \tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n \n \tref->ref++;\n }\n",
        "post_patch": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\nstatic bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n \t\t\t\tstruct pipe_buffer *buf)\n {\n \tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n \n\tif (ref->ref > INT_MAX/2)\n\t\treturn false;\n\n \tref->ref++;\n\treturn true;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\n\t\t/*\n\t\t * This should never happen (a device public page in the gate\n\t\t * area).\n\t\t */\n \t\tif (is_device_public_page(*page))\n \t\t\tgoto unmap;\n \t}\n\tget_page(*page);\n out:\n \tret = 0;\n unmap:\n\tpte_unmap(pte);\n\treturn ret;\n}\n",
        "post_patch": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\n\t\t/*\n\t\t * This should never happen (a device public page in the gate\n\t\t * area).\n\t\t */\n \t\tif (is_device_public_page(*page))\n \t\t\tgoto unmap;\n \t}\n\tif (unlikely(!try_get_page(*page))) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\n out:\n \tret = 0;\n unmap:\n\tpte_unmap(pte);\n\treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitSlice(\n    const H264PPS* pps,\n    const H264SliceHeader* slice_hdr,\n    const H264Picture::Vector& ref_pic_list0,\n    const H264Picture::Vector& ref_pic_list1,\n     const scoped_refptr<H264Picture>& pic,\n     const uint8_t* data,\n     size_t size) {\n   VASliceParameterBufferH264 slice_param;\n   memset(&slice_param, 0, sizeof(slice_param));\n \n  slice_param.slice_data_size = slice_hdr->nalu_size;\n  slice_param.slice_data_offset = 0;\n  slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n  slice_param.slice_data_bit_offset = slice_hdr->header_bit_size;\n\n#define SHDRToSP(a) slice_param.a = slice_hdr->a\n  SHDRToSP(first_mb_in_slice);\n  slice_param.slice_type = slice_hdr->slice_type % 5;\n  SHDRToSP(direct_spatial_mv_pred_flag);\n\n  SHDRToSP(num_ref_idx_l0_active_minus1);\n  SHDRToSP(num_ref_idx_l1_active_minus1);\n  SHDRToSP(cabac_init_idc);\n  SHDRToSP(slice_qp_delta);\n  SHDRToSP(disable_deblocking_filter_idc);\n  SHDRToSP(slice_alpha_c0_offset_div2);\n  SHDRToSP(slice_beta_offset_div2);\n\n  if (((slice_hdr->IsPSlice() || slice_hdr->IsSPSlice()) &&\n       pps->weighted_pred_flag) ||\n      (slice_hdr->IsBSlice() && pps->weighted_bipred_idc == 1)) {\n    SHDRToSP(luma_log2_weight_denom);\n    SHDRToSP(chroma_log2_weight_denom);\n\n    SHDRToSP(luma_weight_l0_flag);\n    SHDRToSP(luma_weight_l1_flag);\n\n    SHDRToSP(chroma_weight_l0_flag);\n    SHDRToSP(chroma_weight_l1_flag);\n\n    for (int i = 0; i <= slice_param.num_ref_idx_l0_active_minus1; ++i) {\n      slice_param.luma_weight_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_weight[i];\n      slice_param.luma_offset_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_offset[i];\n\n      for (int j = 0; j < 2; ++j) {\n        slice_param.chroma_weight_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_weight[i][j];\n        slice_param.chroma_offset_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_offset[i][j];\n      }\n    }\n\n    if (slice_hdr->IsBSlice()) {\n      for (int i = 0; i <= slice_param.num_ref_idx_l1_active_minus1; ++i) {\n        slice_param.luma_weight_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_weight[i];\n        slice_param.luma_offset_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_offset[i];\n\n        for (int j = 0; j < 2; ++j) {\n          slice_param.chroma_weight_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_weight[i][j];\n          slice_param.chroma_offset_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_offset[i][j];\n        }\n      }\n    }\n  }\n\n  static_assert(\n      arraysize(slice_param.RefPicList0) == arraysize(slice_param.RefPicList1),\n      \"Invalid RefPicList sizes\");\n\n  for (size_t i = 0; i < arraysize(slice_param.RefPicList0); ++i) {\n    InitVAPicture(&slice_param.RefPicList0[i]);\n    InitVAPicture(&slice_param.RefPicList1[i]);\n  }\n\n  for (size_t i = 0;\n       i < ref_pic_list0.size() && i < arraysize(slice_param.RefPicList0);\n       ++i) {\n    if (ref_pic_list0[i])\n      FillVAPicture(&slice_param.RefPicList0[i], ref_pic_list0[i]);\n  }\n  for (size_t i = 0;\n       i < ref_pic_list1.size() && i < arraysize(slice_param.RefPicList1);\n       ++i) {\n    if (ref_pic_list1[i])\n      FillVAPicture(&slice_param.RefPicList1[i], ref_pic_list1[i]);\n  }\n\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceParameterBufferType,\n                                    sizeof(slice_param), &slice_param))\n    return false;\n\n  void* non_const_ptr = const_cast<uint8_t*>(data);\n  return vaapi_wrapper_->SubmitBuffer(VASliceDataBufferType, size,\n                                      non_const_ptr);\n}\n",
        "post_patch": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitSlice(\n    const H264PPS* pps,\n    const H264SliceHeader* slice_hdr,\n    const H264Picture::Vector& ref_pic_list0,\n    const H264Picture::Vector& ref_pic_list1,\n     const scoped_refptr<H264Picture>& pic,\n     const uint8_t* data,\n     size_t size) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   VASliceParameterBufferH264 slice_param;\n   memset(&slice_param, 0, sizeof(slice_param));\n \n  slice_param.slice_data_size = slice_hdr->nalu_size;\n  slice_param.slice_data_offset = 0;\n  slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n  slice_param.slice_data_bit_offset = slice_hdr->header_bit_size;\n\n#define SHDRToSP(a) slice_param.a = slice_hdr->a\n  SHDRToSP(first_mb_in_slice);\n  slice_param.slice_type = slice_hdr->slice_type % 5;\n  SHDRToSP(direct_spatial_mv_pred_flag);\n\n  SHDRToSP(num_ref_idx_l0_active_minus1);\n  SHDRToSP(num_ref_idx_l1_active_minus1);\n  SHDRToSP(cabac_init_idc);\n  SHDRToSP(slice_qp_delta);\n  SHDRToSP(disable_deblocking_filter_idc);\n  SHDRToSP(slice_alpha_c0_offset_div2);\n  SHDRToSP(slice_beta_offset_div2);\n\n  if (((slice_hdr->IsPSlice() || slice_hdr->IsSPSlice()) &&\n       pps->weighted_pred_flag) ||\n      (slice_hdr->IsBSlice() && pps->weighted_bipred_idc == 1)) {\n    SHDRToSP(luma_log2_weight_denom);\n    SHDRToSP(chroma_log2_weight_denom);\n\n    SHDRToSP(luma_weight_l0_flag);\n    SHDRToSP(luma_weight_l1_flag);\n\n    SHDRToSP(chroma_weight_l0_flag);\n    SHDRToSP(chroma_weight_l1_flag);\n\n    for (int i = 0; i <= slice_param.num_ref_idx_l0_active_minus1; ++i) {\n      slice_param.luma_weight_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_weight[i];\n      slice_param.luma_offset_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_offset[i];\n\n      for (int j = 0; j < 2; ++j) {\n        slice_param.chroma_weight_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_weight[i][j];\n        slice_param.chroma_offset_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_offset[i][j];\n      }\n    }\n\n    if (slice_hdr->IsBSlice()) {\n      for (int i = 0; i <= slice_param.num_ref_idx_l1_active_minus1; ++i) {\n        slice_param.luma_weight_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_weight[i];\n        slice_param.luma_offset_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_offset[i];\n\n        for (int j = 0; j < 2; ++j) {\n          slice_param.chroma_weight_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_weight[i][j];\n          slice_param.chroma_offset_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_offset[i][j];\n        }\n      }\n    }\n  }\n\n  static_assert(\n      arraysize(slice_param.RefPicList0) == arraysize(slice_param.RefPicList1),\n      \"Invalid RefPicList sizes\");\n\n  for (size_t i = 0; i < arraysize(slice_param.RefPicList0); ++i) {\n    InitVAPicture(&slice_param.RefPicList0[i]);\n    InitVAPicture(&slice_param.RefPicList1[i]);\n  }\n\n  for (size_t i = 0;\n       i < ref_pic_list0.size() && i < arraysize(slice_param.RefPicList0);\n       ++i) {\n    if (ref_pic_list0[i])\n      FillVAPicture(&slice_param.RefPicList0[i], ref_pic_list0[i]);\n  }\n  for (size_t i = 0;\n       i < ref_pic_list1.size() && i < arraysize(slice_param.RefPicList1);\n       ++i) {\n    if (ref_pic_list1[i])\n      FillVAPicture(&slice_param.RefPicList1[i], ref_pic_list1[i]);\n  }\n\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceParameterBufferType,\n                                    sizeof(slice_param), &slice_param))\n    return false;\n\n  void* non_const_ptr = const_cast<uint8_t*>(data);\n  return vaapi_wrapper_->SubmitBuffer(VASliceDataBufferType, size,\n                                      non_const_ptr);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                     int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n;\n    SSL3_RECORD *rr;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_buffers(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA) &&\n         (type != SSL3_RT_HANDSHAKE)) ||\n        (peek && (type != SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    /*\n     * check whether there's a handshake message (client hello?) waiting\n     */\n    if ((ret = have_handshake_fragment(s, type, buf, len)))\n        return ret;\n\n    /*\n     * Now s->rlayer.d->handshake_fragment_len == 0 if\n     * type == SSL3_RT_HANDSHAKE.\n     */\n\n#ifndef OPENSSL_NO_SCTP\n    /*\n     * Continue handshake if it had to be interrupted to read app data with\n     * SCTP.\n     */\n    if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||\n        (BIO_dgram_is_sctp(SSL_get_rbio(s))\n         && ossl_statem_in_sctp_read_sock(s)\n         && s->s3->in_read_app_data != 2))\n#else\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))\n#endif\n    {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * s->s3->rrec.type         - is the type of record\n     * s->s3->rrec.data,    - data\n     * s->s3->rrec.off,     - offset into 'data' for next read\n     * s->s3->rrec.length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n\n    /*\n     * We are not handshaking and have no data yet, so process data buffered\n     * during the last handshake in advance, if any.\n     */\n    if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {\n        pitem *item;\n        item = pqueue_pop(s->rlayer.d->buffered_app_data.q);\n        if (item) {\n#ifndef OPENSSL_NO_SCTP\n            /* Restore bio_dgram_sctp_rcvinfo struct */\n            if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n                DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;\n                BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,\n                         sizeof(rdata->recordinfo), &rdata->recordinfo);\n            }\n#endif\n\n            dtls1_copy_record(s, item);\n\n            OPENSSL_free(item->data);\n            pitem_free(item);\n        }\n    }\n\n    /* Check for timeout */\n    if (dtls1_handle_timeout(s) > 0)\n        goto start;\n\n    /* get new packet if necessary */\n    if ((SSL3_RECORD_get_length(rr) == 0)\n        || (s->rlayer.rstate == SSL_ST_READ_BODY)) {\n        ret = dtls1_get_record(s);\n        if (ret <= 0) {\n            ret = dtls1_read_failed(s, ret);\n            /* anything other than a timeout is an error */\n            if (ret <= 0)\n                return (ret);\n            else\n                goto start;\n         }\n     }\n \n     /* we now have a packet which can be read and processed */\n \n     if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                SSL3_RECORD_get_seq_num(rr)) < 0) {\n            SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n            return -1;\n        }\n        SSL3_RECORD_set_length(rr, 0);\n        goto start;\n    }\n",
        "post_patch": "int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                     int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n;\n    SSL3_RECORD *rr;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_buffers(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA) &&\n         (type != SSL3_RT_HANDSHAKE)) ||\n        (peek && (type != SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    /*\n     * check whether there's a handshake message (client hello?) waiting\n     */\n    if ((ret = have_handshake_fragment(s, type, buf, len)))\n        return ret;\n\n    /*\n     * Now s->rlayer.d->handshake_fragment_len == 0 if\n     * type == SSL3_RT_HANDSHAKE.\n     */\n\n#ifndef OPENSSL_NO_SCTP\n    /*\n     * Continue handshake if it had to be interrupted to read app data with\n     * SCTP.\n     */\n    if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||\n        (BIO_dgram_is_sctp(SSL_get_rbio(s))\n         && ossl_statem_in_sctp_read_sock(s)\n         && s->s3->in_read_app_data != 2))\n#else\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))\n#endif\n    {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * s->s3->rrec.type         - is the type of record\n     * s->s3->rrec.data,    - data\n     * s->s3->rrec.off,     - offset into 'data' for next read\n     * s->s3->rrec.length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n\n    /*\n     * We are not handshaking and have no data yet, so process data buffered\n     * during the last handshake in advance, if any.\n     */\n    if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {\n        pitem *item;\n        item = pqueue_pop(s->rlayer.d->buffered_app_data.q);\n        if (item) {\n#ifndef OPENSSL_NO_SCTP\n            /* Restore bio_dgram_sctp_rcvinfo struct */\n            if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n                DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;\n                BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,\n                         sizeof(rdata->recordinfo), &rdata->recordinfo);\n            }\n#endif\n\n            dtls1_copy_record(s, item);\n\n            OPENSSL_free(item->data);\n            pitem_free(item);\n        }\n    }\n\n    /* Check for timeout */\n    if (dtls1_handle_timeout(s) > 0)\n        goto start;\n\n    /* get new packet if necessary */\n    if ((SSL3_RECORD_get_length(rr) == 0)\n        || (s->rlayer.rstate == SSL_ST_READ_BODY)) {\n        ret = dtls1_get_record(s);\n        if (ret <= 0) {\n            ret = dtls1_read_failed(s, ret);\n            /* anything other than a timeout is an error */\n            if (ret <= 0)\n                return (ret);\n            else\n                goto start;\n         }\n     }\n \n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n     /* we now have a packet which can be read and processed */\n \n     if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                SSL3_RECORD_get_seq_num(rr)) < 0) {\n            SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n            return -1;\n        }\n        SSL3_RECORD_set_length(rr, 0);\n        goto start;\n    }\n",
        "label": 1
    },
    {
        "pre_patch": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll_inode(&args->trans, args->dp);\n}\n",
        "post_patch": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll_inode(&args->trans, args->dp);\n}\n",
        "label": 0
    },
    {
        "pre_patch": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t/*\n\t\t * Some architectures need to do book-keeping after\n\t\t * a ptrace attach.\n\t\t */\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n \n \tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n \t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n \t\tret = compat_arch_ptrace(child, request, addr, data);\n \n  out_put_task_struct:\n \tput_task_struct(child);\n out:\n\treturn ret;\n}\n",
        "post_patch": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\t/*\n\t\t * Some architectures need to do book-keeping after\n\t\t * a ptrace attach.\n\t\t */\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n \n \tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n \t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret) {\n \t\tret = compat_arch_ptrace(child, request, addr, data);\n\t\tif (ret || request != PTRACE_DETACH)\n\t\t\tptrace_unfreeze_traced(child);\n\t}\n \n  out_put_task_struct:\n \tput_task_struct(child);\n out:\n\treturn ret;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "void GLES2Implementation::DisableVertexAttribArray(GLuint index) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glDisableVertexAttribArray(\"\n                     << index << \")\");\n  vertex_array_object_manager_->SetAttribEnable(index, false);\n  helper_->DisableVertexAttribArray(index);\n  CheckGLError();\n}\n",
        "post_patch": "void GLES2Implementation::DisableVertexAttribArray(GLuint index) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glDisableVertexAttribArray(\"\n                     << index << \")\");\n  vertex_array_object_manager_->SetAttribEnable(index, false);\n  helper_->DisableVertexAttribArray(index);\n  CheckGLError();\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n \n restart:\n     if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n         reload_interval = default_reload_interval(v);\n \n reload:\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n",
        "post_patch": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n    int reload_count = 0;\n \n restart:\n     if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n         reload_interval = default_reload_interval(v);\n \n reload:\n        reload_count++;\n        if (reload_count > c->max_reload)\n            return AVERROR_EOF;\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "GahpServer::useCachedProxy( GahpProxyInfo *new_proxy, bool force )\n{\n\tif ( new_proxy == NULL ) {\n\t\tnew_proxy = current_proxy;\n\t}\n\n\tif ( new_proxy->cached_expiration != new_proxy->proxy->expiration_time ) {\n\t\tif ( command_cache_proxy_from_file( new_proxy ) == false ) {\n\t\t\tEXCEPT( \"Failed to recache proxy!\" );\n\t\t}\n\t\tnew_proxy->cached_expiration = new_proxy->proxy->expiration_time;\n\t\tforce = true;\n\t}\n\n\tif ( force == false && new_proxy == current_proxy ) {\n\t\treturn true;\n\t}\n\n\tif ( command_use_cached_proxy( new_proxy ) == false ) {\n\t\treturn false;\n\t}\n\n\tcurrent_proxy = new_proxy;\n\n\treturn true;\n}\n",
        "post_patch": "GahpServer::useCachedProxy( GahpProxyInfo *new_proxy, bool force )\n{\n\tif ( new_proxy == NULL ) {\n\t\tnew_proxy = current_proxy;\n\t}\n\n\tif ( new_proxy->cached_expiration != new_proxy->proxy->expiration_time ) {\n\t\tif ( command_cache_proxy_from_file( new_proxy ) == false ) {\n\t\t\tEXCEPT( \"Failed to recache proxy!\" );\n\t\t}\n\t\tnew_proxy->cached_expiration = new_proxy->proxy->expiration_time;\n\t\tforce = true;\n\t}\n\n\tif ( force == false && new_proxy == current_proxy ) {\n\t\treturn true;\n\t}\n\n\tif ( command_use_cached_proxy( new_proxy ) == false ) {\n\t\treturn false;\n\t}\n\n\tcurrent_proxy = new_proxy;\n\n\treturn true;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n \t\t\tif (pmd_trans_unstable(pmd))\n \t\t\t\tret = -EBUSY;\n \t\t} else {\n\t\t\tget_page(page);\n \t\t\tspin_unlock(ptl);\n \t\t\tlock_page(page);\n \t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}\n",
        "post_patch": "static struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n \t\t\tif (pmd_trans_unstable(pmd))\n \t\t\t\tret = -EBUSY;\n \t\t} else {\n\t\t\tif (unlikely(!try_get_page(page))) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n \t\t\tspin_unlock(ptl);\n \t\t\tlock_page(page);\n \t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n \tint err = 0;\n \n \tmutex_lock(&swhash->hlist_mutex);\n \tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n \t\tstruct swevent_hlist *hlist;\n \n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n",
        "post_patch": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n \tint err = 0;\n \n \tmutex_lock(&swhash->hlist_mutex);\n \tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n \t\tstruct swevent_hlist *hlist;\n \n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "xfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n \t\t\t\t\tsbp->namelen,\n \t\t\t\t\tsbp->valuelen,\n \t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n \t\t\treturn error;\n \t\tif (context->seen_enough)\n \t\t\tbreak;\n \t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}\n",
        "post_patch": "xfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n \t\t\t\t\tsbp->namelen,\n \t\t\t\t\tsbp->valuelen,\n \t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error) {\n\t\t\tkmem_free(sbuf);\n \t\t\treturn error;\n\t\t}\n \t\tif (context->seen_enough)\n \t\t\tbreak;\n \t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}\n",
        "label": 1
    },
    {
        "pre_patch": " void ahci_uninit(AHCIState *s)\n {\n     g_free(s->dev);\n }\n",
        "post_patch": " void ahci_uninit(AHCIState *s)\n {\n    int i, j;\n\n    for (i = 0; i < s->ports; i++) {\n        AHCIDevice *ad = &s->dev[i];\n\n        for (j = 0; j < 2; j++) {\n            IDEState *s = &ad->port.ifs[j];\n\n            ide_exit(s);\n        }\n    }\n\n     g_free(s->dev);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "ExprResolveIntegerLookup(struct xkb_context *ctx, const ExprDef *expr,\n                         int *val_rtrn, IdentLookupFunc lookup,\n                         const void *lookupPriv)\n{\n    bool ok = false;\n    int l, r;\n    unsigned u;\n    ExprDef *left, *right;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where an int was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *val_rtrn = expr->integer.ival;\n        return true;\n\n    case EXPR_IDENT:\n        if (lookup)\n            ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT, &u);\n\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        else\n            *val_rtrn = (int) u;\n\n        return ok;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveIntegerLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l + r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l - r;\n            break;\n        case EXPR_MULTIPLY:\n            *val_rtrn = l * r;\n            break;\n        case EXPR_DIVIDE:\n            if (r == 0) {\n                log_err(ctx, \"Cannot divide by zero: %d / %d\\n\", l, r);\n                return false;\n            }\n            *val_rtrn = l / r;\n            break;\n        default:\n            log_err(ctx, \"%s of integers not permitted\\n\",\n                    expr_op_type_to_string(expr->expr.op));\n            return false;\n        }\n\n        return true;\n\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n\n    case EXPR_NOT:\n        log_err(ctx, \"The ! operator cannot be applied to an integer\\n\");\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NEGATE:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv))\n            return false;\n\n        *val_rtrn = (expr->expr.op == EXPR_NEGATE ? -l : ~l);\n        return true;\n\n    case EXPR_UNARY_PLUS:\n        left = expr->unary.child;\n        return ExprResolveIntegerLookup(ctx, left, val_rtrn, lookup,\n                                        lookupPriv);\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveInteger\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n",
        "post_patch": "ExprResolveIntegerLookup(struct xkb_context *ctx, const ExprDef *expr,\n                         int *val_rtrn, IdentLookupFunc lookup,\n                         const void *lookupPriv)\n{\n    bool ok = false;\n    int l, r;\n    unsigned u;\n    ExprDef *left, *right;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where an int was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n\n        *val_rtrn = expr->integer.ival;\n        return true;\n\n    case EXPR_IDENT:\n        if (lookup)\n            ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT, &u);\n\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        else\n            *val_rtrn = (int) u;\n\n        return ok;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveIntegerLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l + r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l - r;\n            break;\n        case EXPR_MULTIPLY:\n            *val_rtrn = l * r;\n            break;\n        case EXPR_DIVIDE:\n            if (r == 0) {\n                log_err(ctx, \"Cannot divide by zero: %d / %d\\n\", l, r);\n                return false;\n            }\n            *val_rtrn = l / r;\n            break;\n        default:\n            log_err(ctx, \"%s of integers not permitted\\n\",\n                    expr_op_type_to_string(expr->expr.op));\n            return false;\n        }\n\n        return true;\n\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n\n    case EXPR_NOT:\n        log_err(ctx, \"The ! operator cannot be applied to an integer\\n\");\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NEGATE:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &l, lookup, lookupPriv))\n            return false;\n\n        *val_rtrn = (expr->expr.op == EXPR_NEGATE ? -l : ~l);\n        return true;\n\n    case EXPR_UNARY_PLUS:\n        left = expr->unary.child;\n        return ExprResolveIntegerLookup(ctx, left, val_rtrn, lookup,\n                                        lookupPriv);\n\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveInteger\\n\",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n",
        "label": 0
    },
    {
        "pre_patch": " ZEND_METHOD(CURLFile, __wakeup)\n {\n       zend_update_property_string(curl_CURLFile_class, getThis(), \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n        zend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n }\n",
        "post_patch": " ZEND_METHOD(CURLFile, __wakeup)\n {\n       zval *_this = getThis();\n\n       zend_unset_property(curl_CURLFile_class, _this, \"name\", sizeof(\"name\")-1 TSRMLS_CC);\n       zend_update_property_string(curl_CURLFile_class, _this, \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n        zend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static int kvm_handle_cp_32(struct kvm_vcpu *vcpu,\n\t\t\t    const struct sys_reg_desc *global,\n\t\t\t    size_t nr_global,\n\t\t\t    const struct sys_reg_desc *target_specific,\n\t\t\t    size_t nr_specific)\n{\n\tstruct sys_reg_params params;\n\tu32 hsr = kvm_vcpu_get_hsr(vcpu);\n\tint Rt  = (hsr >> 5) & 0xf;\n\n\tparams.is_aarch32 = true;\n\tparams.is_32bit = true;\n\tparams.CRm = (hsr >> 1) & 0xf;\n\tparams.regval = vcpu_get_reg(vcpu, Rt);\n\tparams.is_write = ((hsr & 1) == 0);\n\tparams.CRn = (hsr >> 10) & 0xf;\n\tparams.Op0 = 0;\n\tparams.Op1 = (hsr >> 14) & 0x7;\n\tparams.Op2 = (hsr >> 17) & 0x7;\n\n\tif (!emulate_cp(vcpu, &params, target_specific, nr_specific) ||\n\t    !emulate_cp(vcpu, &params, global, nr_global)) {\n\t\tif (!params.is_write)\n\t\t\tvcpu_set_reg(vcpu, Rt, params.regval);\n\t\treturn 1;\n\t}\n\n\tunhandled_cp_access(vcpu, &params);\n\treturn 1;\n}\n",
        "post_patch": "static int kvm_handle_cp_32(struct kvm_vcpu *vcpu,\n\t\t\t    const struct sys_reg_desc *global,\n\t\t\t    size_t nr_global,\n\t\t\t    const struct sys_reg_desc *target_specific,\n\t\t\t    size_t nr_specific)\n{\n\tstruct sys_reg_params params;\n\tu32 hsr = kvm_vcpu_get_hsr(vcpu);\n\tint Rt  = (hsr >> 5) & 0xf;\n\n\tparams.is_aarch32 = true;\n\tparams.is_32bit = true;\n\tparams.CRm = (hsr >> 1) & 0xf;\n\tparams.regval = vcpu_get_reg(vcpu, Rt);\n\tparams.is_write = ((hsr & 1) == 0);\n\tparams.CRn = (hsr >> 10) & 0xf;\n\tparams.Op0 = 0;\n\tparams.Op1 = (hsr >> 14) & 0x7;\n\tparams.Op2 = (hsr >> 17) & 0x7;\n\n\tif (!emulate_cp(vcpu, &params, target_specific, nr_specific) ||\n\t    !emulate_cp(vcpu, &params, global, nr_global)) {\n\t\tif (!params.is_write)\n\t\t\tvcpu_set_reg(vcpu, Rt, params.regval);\n\t\treturn 1;\n\t}\n\n\tunhandled_cp_access(vcpu, &params);\n\treturn 1;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 encoder parameters.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1 << (i+2)) > image->columns) &&\n        ((size_t) (1 << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n       &parameters.subsampling_dx,&parameters.subsampling_dy);\n   property=GetImageProperty(image,\"comment\");\n   if (property != (const char *) NULL)\n    parameters.cp_comment=property;\n   channels=3;\n   jp2_colorspace=OPJ_CLRSPC_SRGB;\n   if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte != MagickFalse)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(unsigned int) image->depth;\n    jp2_info[i].bpp=(unsigned int) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(unsigned int) image->columns;\n    jp2_info[i].h=(unsigned int) image->rows;\n  }\n  jp2_image=opj_image_create(channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelLuma(image,p));\n                break;\n              }\n            *q=(int) (scale*p->red);\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*(QuantumRange-p->opacity));\n                break;\n              }\n            *q=(int) (scale*p->green);\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*p->blue);\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*(QuantumRange-p->opacity));\n            break;\n          }\n        }\n      }\n      p++;\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,&image->exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,&image->exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if (jp2_status == 0)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "post_patch": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 encoder parameters.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1 << (i+2)) > image->columns) &&\n        ((size_t) (1 << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n       &parameters.subsampling_dx,&parameters.subsampling_dy);\n   property=GetImageProperty(image,\"comment\");\n   if (property != (const char *) NULL)\n    parameters.cp_comment=(char *) property;\n   channels=3;\n   jp2_colorspace=OPJ_CLRSPC_SRGB;\n   if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte != MagickFalse)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(unsigned int) image->depth;\n    jp2_info[i].bpp=(unsigned int) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(unsigned int) image->columns;\n    jp2_info[i].h=(unsigned int) image->rows;\n  }\n  jp2_image=opj_image_create(channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelLuma(image,p));\n                break;\n              }\n            *q=(int) (scale*p->red);\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*(QuantumRange-p->opacity));\n                break;\n              }\n            *q=(int) (scale*p->green);\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*p->blue);\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*(QuantumRange-p->opacity));\n            break;\n          }\n        }\n      }\n      p++;\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,&image->exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,&image->exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if (jp2_status == 0)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "label": 1
    },
    {
        "pre_patch": "e1000e_verify_csum_in_sw(E1000ECore *core,\n                         struct NetRxPkt *pkt,\n                         uint32_t *status_flags,\n                         bool istcp, bool isudp)\n{\n    bool csum_valid;\n    uint32_t csum_error;\n\n    if (e1000e_rx_l3_cso_enabled(core)) {\n        if (!net_rx_pkt_validate_l3_csum(pkt, &csum_valid)) {\n            trace_e1000e_rx_metadata_l3_csum_validation_failed();\n        } else {\n            csum_error = csum_valid ? 0 : E1000_RXDEXT_STATERR_IPE;\n            *status_flags |= E1000_RXD_STAT_IPCS | csum_error;\n        }\n    } else {\n        trace_e1000e_rx_metadata_l3_cso_disabled();\n    }\n\n    if (!e1000e_rx_l4_cso_enabled(core)) {\n        trace_e1000e_rx_metadata_l4_cso_disabled();\n        return;\n    }\n\n    if (!net_rx_pkt_validate_l4_csum(pkt, &csum_valid)) {\n        trace_e1000e_rx_metadata_l4_csum_validation_failed();\n        return;\n    }\n\n    csum_error = csum_valid ? 0 : E1000_RXDEXT_STATERR_TCPE;\n\n    if (istcp) {\n        *status_flags |= E1000_RXD_STAT_TCPCS |\n                         csum_error;\n    } else if (isudp) {\n        *status_flags |= E1000_RXD_STAT_TCPCS |\n                         E1000_RXD_STAT_UDPCS |\n                         csum_error;\n    }\n}\n",
        "post_patch": "e1000e_verify_csum_in_sw(E1000ECore *core,\n                         struct NetRxPkt *pkt,\n                         uint32_t *status_flags,\n                         bool istcp, bool isudp)\n{\n    bool csum_valid;\n    uint32_t csum_error;\n\n    if (e1000e_rx_l3_cso_enabled(core)) {\n        if (!net_rx_pkt_validate_l3_csum(pkt, &csum_valid)) {\n            trace_e1000e_rx_metadata_l3_csum_validation_failed();\n        } else {\n            csum_error = csum_valid ? 0 : E1000_RXDEXT_STATERR_IPE;\n            *status_flags |= E1000_RXD_STAT_IPCS | csum_error;\n        }\n    } else {\n        trace_e1000e_rx_metadata_l3_cso_disabled();\n    }\n\n    if (!e1000e_rx_l4_cso_enabled(core)) {\n        trace_e1000e_rx_metadata_l4_cso_disabled();\n        return;\n    }\n\n    if (!net_rx_pkt_validate_l4_csum(pkt, &csum_valid)) {\n        trace_e1000e_rx_metadata_l4_csum_validation_failed();\n        return;\n    }\n\n    csum_error = csum_valid ? 0 : E1000_RXDEXT_STATERR_TCPE;\n\n    if (istcp) {\n        *status_flags |= E1000_RXD_STAT_TCPCS |\n                         csum_error;\n    } else if (isudp) {\n        *status_flags |= E1000_RXD_STAT_TCPCS |\n                         E1000_RXD_STAT_UDPCS |\n                         csum_error;\n    }\n}\n",
        "label": 0
    },
    {
        "pre_patch": "static struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name)\n{\n\tstruct regulator *regulator;\n\tchar buf[REG_STR_SIZE];\n\tint err, size;\n\n\tregulator = kzalloc(sizeof(*regulator), GFP_KERNEL);\n\tif (regulator == NULL)\n\t\treturn NULL;\n\n\tmutex_lock(&rdev->mutex);\n\tregulator->rdev = rdev;\n\tlist_add(&regulator->list, &rdev->consumer_list);\n\n\tif (dev) {\n\t\tregulator->dev = dev;\n\n\t\t/* Add a link to the device sysfs entry */\n\t\tsize = scnprintf(buf, REG_STR_SIZE, \"%s-%s\",\n\t\t\t\t dev->kobj.name, supply_name);\n\t\tif (size >= REG_STR_SIZE)\n\t\t\tgoto overflow_err;\n\n\t\tregulator->supply_name = kstrdup(buf, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\n\t\terr = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,\n\t\t\t\t\tbuf);\n\t\tif (err) {\n\t\t\trdev_warn(rdev, \"could not add device link %s err %d\\n\",\n\t\t\t\t  dev->kobj.name, err);\n\t\t\t/* non-fatal */\n\t\t}\n\t} else {\n\t\tregulator->supply_name = kstrdup(supply_name, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\t}\n\n\tregulator->debugfs = debugfs_create_dir(regulator->supply_name,\n\t\t\t\t\t\trdev->debugfs);\n\tif (!regulator->debugfs) {\n\t\trdev_warn(rdev, \"Failed to create debugfs directory\\n\");\n\t} else {\n\t\tdebugfs_create_u32(\"uA_load\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->uA_load);\n\t\tdebugfs_create_u32(\"min_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->min_uV);\n\t\tdebugfs_create_u32(\"max_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->max_uV);\n\t}\n\n\t/*\n\t * Check now if the regulator is an always on regulator - if\n\t * it is then we don't need to do nearly so much work for\n\t * enable/disable calls.\n\t */\n\tif (!_regulator_can_change_status(rdev) &&\n\t    _regulator_is_enabled(rdev))\n\t\tregulator->always_on = true;\n\n\tmutex_unlock(&rdev->mutex);\n\treturn regulator;\noverflow_err:\n\tlist_del(&regulator->list);\n\tkfree(regulator);\n\tmutex_unlock(&rdev->mutex);\n\treturn NULL;\n}\n",
        "post_patch": "static struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name)\n{\n\tstruct regulator *regulator;\n\tchar buf[REG_STR_SIZE];\n\tint err, size;\n\n\tregulator = kzalloc(sizeof(*regulator), GFP_KERNEL);\n\tif (regulator == NULL)\n\t\treturn NULL;\n\n\tmutex_lock(&rdev->mutex);\n\tregulator->rdev = rdev;\n\tlist_add(&regulator->list, &rdev->consumer_list);\n\n\tif (dev) {\n\t\tregulator->dev = dev;\n\n\t\t/* Add a link to the device sysfs entry */\n\t\tsize = scnprintf(buf, REG_STR_SIZE, \"%s-%s\",\n\t\t\t\t dev->kobj.name, supply_name);\n\t\tif (size >= REG_STR_SIZE)\n\t\t\tgoto overflow_err;\n\n\t\tregulator->supply_name = kstrdup(buf, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\n\t\terr = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,\n\t\t\t\t\tbuf);\n\t\tif (err) {\n\t\t\trdev_warn(rdev, \"could not add device link %s err %d\\n\",\n\t\t\t\t  dev->kobj.name, err);\n\t\t\t/* non-fatal */\n\t\t}\n\t} else {\n\t\tregulator->supply_name = kstrdup(supply_name, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\t}\n\n\tregulator->debugfs = debugfs_create_dir(regulator->supply_name,\n\t\t\t\t\t\trdev->debugfs);\n\tif (!regulator->debugfs) {\n\t\trdev_warn(rdev, \"Failed to create debugfs directory\\n\");\n\t} else {\n\t\tdebugfs_create_u32(\"uA_load\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->uA_load);\n\t\tdebugfs_create_u32(\"min_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->min_uV);\n\t\tdebugfs_create_u32(\"max_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->max_uV);\n\t}\n\n\t/*\n\t * Check now if the regulator is an always on regulator - if\n\t * it is then we don't need to do nearly so much work for\n\t * enable/disable calls.\n\t */\n\tif (!_regulator_can_change_status(rdev) &&\n\t    _regulator_is_enabled(rdev))\n\t\tregulator->always_on = true;\n\n\tmutex_unlock(&rdev->mutex);\n\treturn regulator;\noverflow_err:\n\tlist_del(&regulator->list);\n\tkfree(regulator);\n\tmutex_unlock(&rdev->mutex);\n\treturn NULL;\n}\n",
        "label": 0
    },
    {
        "pre_patch": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tint a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n        int argc = ZEND_NUM_ARGS();\n \n        snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n        if (zend_parse_parameters(argc TSRMLS_CC, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n                &a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n                RETURN_FALSE;\n\t}\n\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7 TSRMLS_CC)) {\n\t\t/* Warning message sent already, just bail out */\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n }\n",
        "post_patch": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tint a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n        int argc = ZEND_NUM_ARGS();\n \n        snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n\n        if (zend_parse_parameters(argc TSRMLS_CC, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n                &a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n                RETURN_FALSE;\n\t}\n\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7 TSRMLS_CC)) {\n\t\t/* Warning message sent already, just bail out */\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static void i8042_stop(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n \tport->exists = false;\n \n \t/*\n \t * We synchronize with both AUX and KBD IRQs because there is\n \t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n \t * and vice versa.\n \t */\n \tsynchronize_irq(I8042_AUX_IRQ);\n \tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n }\n",
        "post_patch": "static void i8042_stop(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n\tspin_lock_irq(&i8042_lock);\n \tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n \n \t/*\n\t * We need to make sure that interrupt handler finishes using\n\t * our serio port before we return from this function.\n \t * We synchronize with both AUX and KBD IRQs because there is\n \t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n \t * and vice versa.\n \t */\n \tsynchronize_irq(I8042_AUX_IRQ);\n \tsynchronize_irq(I8042_KBD_IRQ);\n }\n",
        "label": 1
    }
]