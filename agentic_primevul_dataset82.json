[
    {
        "pre_patch": "  void UpdateNetworkManagerStatus() {\n    if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n      BrowserThread::PostTask(\n          BrowserThread::UI, FROM_HERE,\n          NewRunnableMethod(this,\n                            &NetworkLibraryImpl::UpdateNetworkManagerStatus));\n      return;\n    }\n\n    SystemInfo* system = GetSystemInfo();\n    if (!system)\n      return;\n\n\n    std::string prev_cellular_service_path = cellular_ ?\n        cellular_->service_path() : std::string();\n\n    ClearNetworks();\n\n    ParseSystem(system, &ethernet_, &wifi_networks_, &cellular_networks_,\n                &remembered_wifi_networks_);\n\n    wifi_ = NULL;\n    for (size_t i = 0; i < wifi_networks_.size(); i++) {\n      if (wifi_networks_[i]->connecting_or_connected()) {\n        wifi_ = wifi_networks_[i];\n        break;  // There is only one connected or connecting wifi network.\n      }\n    }\n    cellular_ = NULL;\n     for (size_t i = 0; i < cellular_networks_.size(); i++) {\n       if (cellular_networks_[i]->connecting_or_connected()) {\n         cellular_ = cellular_networks_[i];\n         if (cellular_networks_[i]->service_path() !=\n                 prev_cellular_service_path) {\n          CellularDataPlanList* list = RetrieveCellularDataPlans(\n              cellular_->service_path().c_str());\n          UpdateCellularDataPlan(list);\n          FreeCellularDataPlanList(list);\n         }\n         break;  // There is only one connected or connecting cellular network.\n       }\n    }\n\n    available_devices_ = system->available_technologies;\n    enabled_devices_ = system->enabled_technologies;\n    connected_devices_ = system->connected_technologies;\n    offline_mode_ = system->offline_mode;\n\n    NotifyNetworkManagerChanged();\n    FreeSystemInfo(system);\n  }\n",
        "post_patch": "  void UpdateNetworkManagerStatus() {\n    if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n      BrowserThread::PostTask(\n          BrowserThread::UI, FROM_HERE,\n          NewRunnableMethod(this,\n                            &NetworkLibraryImpl::UpdateNetworkManagerStatus));\n      return;\n    }\n\n    SystemInfo* system = GetSystemInfo();\n    if (!system)\n      return;\n\n\n    std::string prev_cellular_service_path = cellular_ ?\n        cellular_->service_path() : std::string();\n\n    ClearNetworks();\n\n    ParseSystem(system, &ethernet_, &wifi_networks_, &cellular_networks_,\n                &remembered_wifi_networks_);\n\n    wifi_ = NULL;\n    for (size_t i = 0; i < wifi_networks_.size(); i++) {\n      if (wifi_networks_[i]->connecting_or_connected()) {\n        wifi_ = wifi_networks_[i];\n        break;  // There is only one connected or connecting wifi network.\n      }\n    }\n    cellular_ = NULL;\n     for (size_t i = 0; i < cellular_networks_.size(); i++) {\n       if (cellular_networks_[i]->connecting_or_connected()) {\n         cellular_ = cellular_networks_[i];\n        // If new cellular, then request update of the data plan list.\n         if (cellular_networks_[i]->service_path() !=\n                 prev_cellular_service_path) {\n          RefreshCellularDataPlans(cellular_);\n         }\n         break;  // There is only one connected or connecting cellular network.\n       }\n    }\n\n    available_devices_ = system->available_technologies;\n    enabled_devices_ = system->enabled_technologies;\n    connected_devices_ = system->connected_technologies;\n    offline_mode_ = system->offline_mode;\n\n    NotifyNetworkManagerChanged();\n    FreeSystemInfo(system);\n  }\n",
        "label": 1
    },
    {
        "pre_patch": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n\n    MODE = get_elf_class(elf);\n\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    /* 32bit */\n    if (MODE == ELFCLASS32) {\n        /* ELF Header Information */\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            \n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            \n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            \n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            \n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            \n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n\n        /* Section Information */\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (validated_offset(name, elf_map, elf_map + st.st_size)) {\n                ERROR(\"Corrupt file format\\n\");\n                return -1;\n            }\n\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                \n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                \n                default:\n                    break;\n            }\n\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                \n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                \n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        \n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                /* Legal values for d_tag (dynamic entry type).  */\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                \n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                    \n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                \n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                \n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                \n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n                 * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n                 * approach. */\n\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                \n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n\n                /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n                 * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n                 * If any adjustment is made to the ELF object after it has been\n                 * built these entries will need to be adjusted.  */\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                    \n                /* The versioning entry types.  The next are defined as part of the\n                 * GNU extension.  */\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                \n                /* These were chosen by Sun.  */\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        \n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    \n                    break;\n\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                \n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n\n    /* 64bit */\n    if (MODE == ELFCLASS64) {\n        /* ELF Header Information */\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            \n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            \n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            \n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            \n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            \n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n\n        /* Section Information */\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (validated_offset(name, elf_map, elf_map + st.st_size)) {\n                ERROR(\"Corrupt file format\\n\");\n                return -1;\n            }\n\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                \n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                \n                default:\n                    break;\n            }\n\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                \n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                \n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        \n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                /* Legal values for d_tag (dynamic entry type).  */\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                \n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                    \n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                \n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                \n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                \n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n                 * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n                 * approach. */\n\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                \n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n\n                /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n                 * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n                 * If any adjustment is made to the ELF object after it has been\n                 * built these entries will need to be adjusted.  */\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                    \n                /* The versioning entry types.  The next are defined as part of the\n                 * GNU extension.  */\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                \n                /* These were chosen by Sun.  */\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        \n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    \n                    break;\n\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                \n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n\n    return 0;\n}",
        "post_patch": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n\n    MODE = get_elf_class(elf);\n\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    /* 32bit */\n    if (MODE == ELFCLASS32) {\n        /* ELF Header Information */\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            \n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            \n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            \n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            \n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            \n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n\n        /* Section Information */\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (validated_offset(name, elf_map, elf_map + st.st_size)) {\n                ERROR(\"Corrupt file format\\n\");\n                return -1;\n            }\n\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                \n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                \n                default:\n                    break;\n            }\n\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                \n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                \n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        \n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                /* Legal values for d_tag (dynamic entry type).  */\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                \n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                    \n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                \n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                \n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                \n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n                 * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n                 * approach. */\n\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                \n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n\n                /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n                 * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n                 * If any adjustment is made to the ELF object after it has been\n                 * built these entries will need to be adjusted.  */\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                    \n                /* The versioning entry types.  The next are defined as part of the\n                 * GNU extension.  */\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                \n                /* These were chosen by Sun.  */\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        \n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    \n                    break;\n\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                \n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n\n    /* 64bit */\n    if (MODE == ELFCLASS64) {\n        /* ELF Header Information */\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            \n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            \n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            \n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            \n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            \n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n\n        /* Section Information */\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (validated_offset(name, elf_map, elf_map + st.st_size)) {\n                ERROR(\"Corrupt file format\\n\");\n                return -1;\n            }\n\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                \n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                \n                default:\n                    break;\n            }\n\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                \n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                \n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        \n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                /* Legal values for d_tag (dynamic entry type).  */\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                \n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                    \n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                \n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                \n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                \n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n\n                /* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n                 * Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n                 * approach. */\n\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                \n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n\n                /* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n                 * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n                 * If any adjustment is made to the ELF object after it has been\n                 * built these entries will need to be adjusted.  */\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                    \n                /* The versioning entry types.  The next are defined as part of the\n                 * GNU extension.  */\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                \n                /* These were chosen by Sun.  */\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        \n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    \n                    break;\n\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                \n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n\n    return 0;\n}",
        "label": 0
    },
    {
        "pre_patch": "int64 ClientUsageTracker::GetCachedHostUsage(const std::string& host) {\n   HostUsageMap::const_iterator found = cached_usage_.find(host);\n   if (found == cached_usage_.end())\n     return 0;\n\n  int64 usage = 0;\n  const UsageMap& map = found->second;\n  for (UsageMap::const_iterator iter = map.begin();\n       iter != map.end(); ++iter) {\n    usage += iter->second;\n  }\n  return usage;\n}\n",
        "post_patch": "int64 ClientUsageTracker::GetCachedHostUsage(const std::string& host) {\nint64 ClientUsageTracker::GetCachedHostUsage(const std::string& host) const {\n   HostUsageMap::const_iterator found = cached_usage_.find(host);\n   if (found == cached_usage_.end())\n     return 0;\n\n  int64 usage = 0;\n  const UsageMap& map = found->second;\n  for (UsageMap::const_iterator iter = map.begin();\n       iter != map.end(); ++iter) {\n    usage += iter->second;\n  }\n  return usage;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n\n   /*---------------------*/\n   /* MESH STRUCTURE INIT */\n   /*---------------------*/\n\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n\n   MshIdx = (int64_t)msh;\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n\n      free(msh);\n      return(0);\n   }\n\n   // Copy the FilNam into the structure\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n\n   strcpy(msh->FilNam, FilNam);\n\n   // Store the opening mod (read or write) and guess\n   // the filetype (binary or ascii) depending on the extension\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n\n   // Open the file in the required mod and initialize the mesh structure\n   if(msh->mod == GmfRead)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR READING */\n      /*-----------------------*/\n\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n\n      // Read the endian coding tag, the mesh version\n      // and the mesh dimension (mandatory kwd)\n      if(msh->typ & Bin)\n      {\n         // Create the name string and open the file\n#ifdef WITH_GMF_AIO\n         // [Bruno] added binary flag (necessary under Windows)\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n\n         // Read the endian coding tag\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         // [Bruno] added binary flag (necessary under Windows)\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n\n         // Read the endian coding tag\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n\n         // Read the mesh version and the mesh dimension (mandatory kwd)\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         // Create the name string and open the file\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -14);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -16);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      /*------------*/\n      /* KW READING */\n      /*------------*/\n\n      // Read the list of kw present in the file\n      if(!ScaKwdTab(msh))\n         return(0);\n\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR WRITING */\n      /*-----------------------*/\n\n      msh->cod = 1;\n\n      // Check if the user provided a valid version number and dimension\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      // Create the mesh file\n      if(msh->typ & Bin) \n      {\n         /* \n          * [Bruno] replaced previous call to creat():\n          * with a call to open(), because Windows needs the\n          * binary flag to be specified.\n          */\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n\n\n      /*------------*/\n      /* KW WRITING */\n      /*------------*/\n\n      // Write the mesh version and dimension\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "post_patch": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n\n   /*---------------------*/\n   /* MESH STRUCTURE INIT */\n   /*---------------------*/\n\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n\n   MshIdx = (int64_t)msh;\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n\n      free(msh);\n      return(0);\n   }\n\n   // Copy the FilNam into the structure\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n\n   strcpy(msh->FilNam, FilNam);\n\n   // Store the opening mod (read or write) and guess\n   // the filetype (binary or ascii) depending on the extension\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n\n   // Open the file in the required mod and initialize the mesh structure\n   if(msh->mod == GmfRead)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR READING */\n      /*-----------------------*/\n\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n\n      // Read the endian coding tag, the mesh version\n      // and the mesh dimension (mandatory kwd)\n      if(msh->typ & Bin)\n      {\n         // Create the name string and open the file\n#ifdef WITH_GMF_AIO\n         // [Bruno] added binary flag (necessary under Windows)\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n\n         // Read the endian coding tag\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         // [Bruno] added binary flag (necessary under Windows)\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n\n         // Read the endian coding tag\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n\n         // Read the mesh version and the mesh dimension (mandatory kwd)\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         // Create the name string and open the file\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -14);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -16);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      /*------------*/\n      /* KW READING */\n      /*------------*/\n\n      // Read the list of kw present in the file\n      if(!ScaKwdTab(msh))\n         return(0);\n\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR WRITING */\n      /*-----------------------*/\n\n      msh->cod = 1;\n\n      // Check if the user provided a valid version number and dimension\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      // Create the mesh file\n      if(msh->typ & Bin) \n      {\n         /* \n          * [Bruno] replaced previous call to creat():\n          * with a call to open(), because Windows needs the\n          * binary flag to be specified.\n          */\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n\n\n      /*------------*/\n      /* KW WRITING */\n      /*------------*/\n\n      // Write the mesh version and dimension\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "label": 0
    },
    {
        "pre_patch": "void AddInstallerCopyTasks(const InstallerState& installer_state,\n                           const FilePath& setup_path,\n                           const FilePath& archive_path,\n                           const FilePath& temp_path,\n                           const Version& new_version,\n                           WorkItemList* install_list) {\n  DCHECK(install_list);\n  FilePath installer_dir(installer_state.GetInstallerDirectory(new_version));\n  install_list->AddCreateDirWorkItem(installer_dir);\n\n   FilePath exe_dst(installer_dir.Append(setup_path.BaseName()));\n   FilePath archive_dst(installer_dir.Append(archive_path.BaseName()));\n \n  install_list->AddMoveTreeWorkItem(setup_path.value(), exe_dst.value(),\n                                    temp_path.value(), WorkItem::ALWAYS_MOVE);\n   install_list->AddMoveTreeWorkItem(archive_path.value(), archive_dst.value(),\n                                     temp_path.value(), WorkItem::ALWAYS_MOVE);\n }\n",
        "post_patch": "void AddInstallerCopyTasks(const InstallerState& installer_state,\n                           const FilePath& setup_path,\n                           const FilePath& archive_path,\n                           const FilePath& temp_path,\n                           const Version& new_version,\n                           WorkItemList* install_list) {\n  DCHECK(install_list);\n  FilePath installer_dir(installer_state.GetInstallerDirectory(new_version));\n  install_list->AddCreateDirWorkItem(installer_dir);\n\n   FilePath exe_dst(installer_dir.Append(setup_path.BaseName()));\n   FilePath archive_dst(installer_dir.Append(archive_path.BaseName()));\n \n  install_list->AddCopyTreeWorkItem(setup_path.value(), exe_dst.value(),\n                                    temp_path.value(), WorkItem::ALWAYS);\n\n  // otherwise), there is no need to do this for the archive.  Setup.exe, on\n  // the other hand, is created elsewhere so it must always be copied.\n   install_list->AddMoveTreeWorkItem(archive_path.value(), archive_dst.value(),\n                                     temp_path.value(), WorkItem::ALWAYS_MOVE);\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\t/* get rid of trailing / characters */\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}",
        "post_patch": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\t/* get rid of trailing / characters */\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}",
        "label": 0
    },
    {
        "pre_patch": "bool decode(ArgumentDecoder* decoder, RetainPtr<CFURLRef>& result)\n{\n    RetainPtr<CFURLRef> baseURL;\n    bool hasBaseURL;\n    if (!decoder->decodeBool(hasBaseURL))\n        return false;\n    if (hasBaseURL) {\n        if (!decode(decoder, baseURL))\n            return false;\n    }\n\n    RetainPtr<CFStringRef> string;\n     if (!decode(decoder, string))\n         return false;\n \n     CFURLRef url = CFURLCreateWithString(0, string.get(), baseURL.get());\n     if (!url)\n         return false;\n\n    result.adoptCF(url);\n    return true;\n}\n",
        "post_patch": "bool decode(ArgumentDecoder* decoder, RetainPtr<CFURLRef>& result)\n{\n    RetainPtr<CFURLRef> baseURL;\n    bool hasBaseURL;\n    if (!decoder->decodeBool(hasBaseURL))\n        return false;\n    if (hasBaseURL) {\n        if (!decode(decoder, baseURL))\n            return false;\n    }\n\n    RetainPtr<CFStringRef> string;\n     if (!decode(decoder, string))\n         return false;\n \n#if PLATFORM(MAC)\n    // FIXME: Move this to ArgumentCodersCFMac.mm and change this file back to be C++\n    // instead of Objective-C++.\n    if (!CFStringGetLength(string.get())) {\n        // CFURL can't hold an empty URL, unlike NSURL.\n        result = reinterpret_cast<CFURLRef>([NSURL URLWithString:@\"\"]);\n        return true;\n    }\n#endif\n                    \n     CFURLRef url = CFURLCreateWithString(0, string.get(), baseURL.get());\n     if (!url)\n         return false;\n\n    result.adoptCF(url);\n    return true;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (! targetFile.isAChildOf (targetDirectory))\r\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (overwriteFiles == OverwriteFiles::no)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r",
        "post_patch": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (! targetFile.isAChildOf (targetDirectory))\r\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (overwriteFiles == OverwriteFiles::no)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r",
        "label": 0
    },
    {
        "pre_patch": "void WebProcessProxy::addExistingWebPage(WebPageProxy* webPage, uint64_t pageID)\n{\n     m_pageMap.set(pageID, webPage);\n     globalPageMap().set(pageID, webPage);\n #if PLATFORM(MAC)\n    if (pageIsProcessSuppressible(webPage));\n         m_processSuppressiblePages.add(pageID);\n     updateProcessSuppressionState();\n #endif\n}\n",
        "post_patch": "void WebProcessProxy::addExistingWebPage(WebPageProxy* webPage, uint64_t pageID)\n{\n     m_pageMap.set(pageID, webPage);\n     globalPageMap().set(pageID, webPage);\n #if PLATFORM(MAC)\n    if (pageIsProcessSuppressible(webPage))\n         m_processSuppressiblePages.add(pageID);\n     updateProcessSuppressionState();\n #endif\n}\n",
        "label": 1
    },
    {
        "pre_patch": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                escapeHTML(res->outputbuffer, buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}",
        "post_patch": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                escapeHTML(res->outputbuffer, buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}",
        "label": 0
    },
    {
        "pre_patch": "v8::Handle<v8::Value> V8ThrowException::createDOMException(v8::Isolate* isolate, int ec, const String& sanitizedMessage, const String& unsanitizedMessage, const v8::Handle<v8::Object>& creationContext)\n{\n    if (ec <= 0 || v8::V8::IsExecutionTerminating())\n        return v8Undefined();\n\n    ASSERT(ec == SecurityError || unsanitizedMessage.isEmpty());\n\n    if (ec == V8GeneralError)\n        return V8ThrowException::createGeneralError(isolate, sanitizedMessage);\n    if (ec == V8TypeError)\n        return V8ThrowException::createTypeError(isolate, sanitizedMessage);\n    if (ec == V8RangeError)\n        return V8ThrowException::createRangeError(isolate, sanitizedMessage);\n    if (ec == V8SyntaxError)\n        return V8ThrowException::createSyntaxError(isolate, sanitizedMessage);\n     if (ec == V8ReferenceError)\n         return V8ThrowException::createReferenceError(isolate, sanitizedMessage);\n \n     RefPtrWillBeRawPtr<DOMException> domException = DOMException::create(ec, sanitizedMessage, unsanitizedMessage);\n    v8::Handle<v8::Value> exception = toV8(domException.get(), creationContext, isolate);\n \n     if (exception.IsEmpty())\n         return v8Undefined();\n\n    v8::Handle<v8::Value> error = v8::Exception::Error(v8String(isolate, domException->message()));\n    ASSERT(!error.IsEmpty());\n    ASSERT(exception->IsObject());\n    exception->ToObject(isolate)->SetAccessor(v8AtomicString(isolate, \"stack\"), domExceptionStackGetter, domExceptionStackSetter, error);\n    V8HiddenValue::setHiddenValue(isolate, exception->ToObject(isolate), V8HiddenValue::error(isolate), error);\n\n    return exception;\n}\n",
        "post_patch": "v8::Handle<v8::Value> V8ThrowException::createDOMException(v8::Isolate* isolate, int ec, const String& sanitizedMessage, const String& unsanitizedMessage, const v8::Handle<v8::Object>& creationContext)\n{\n    if (ec <= 0 || v8::V8::IsExecutionTerminating())\n        return v8Undefined();\n\n    ASSERT(ec == SecurityError || unsanitizedMessage.isEmpty());\n\n    if (ec == V8GeneralError)\n        return V8ThrowException::createGeneralError(isolate, sanitizedMessage);\n    if (ec == V8TypeError)\n        return V8ThrowException::createTypeError(isolate, sanitizedMessage);\n    if (ec == V8RangeError)\n        return V8ThrowException::createRangeError(isolate, sanitizedMessage);\n    if (ec == V8SyntaxError)\n        return V8ThrowException::createSyntaxError(isolate, sanitizedMessage);\n     if (ec == V8ReferenceError)\n         return V8ThrowException::createReferenceError(isolate, sanitizedMessage);\n \n    v8::Handle<v8::Object> sanitizedCreationContext = creationContext;\n\n    // FIXME: Is the current context always the right choice?\n    Frame* frame = toFrameIfNotDetached(creationContext->CreationContext());\n    if (!frame || !BindingSecurity::shouldAllowAccessToFrame(isolate, frame, DoNotReportSecurityError))\n        sanitizedCreationContext = isolate->GetCurrentContext()->Global();\n\n\n     RefPtrWillBeRawPtr<DOMException> domException = DOMException::create(ec, sanitizedMessage, unsanitizedMessage);\n    v8::Handle<v8::Value> exception = toV8(domException.get(), sanitizedCreationContext, isolate);\n \n     if (exception.IsEmpty())\n         return v8Undefined();\n\n    v8::Handle<v8::Value> error = v8::Exception::Error(v8String(isolate, domException->message()));\n    ASSERT(!error.IsEmpty());\n    ASSERT(exception->IsObject());\n    exception->ToObject(isolate)->SetAccessor(v8AtomicString(isolate, \"stack\"), domExceptionStackGetter, domExceptionStackSetter, error);\n    V8HiddenValue::setHiddenValue(isolate, exception->ToObject(isolate), V8HiddenValue::error(isolate), error);\n\n    return exception;\n}\n",
        "label": 1
    },
    {
        "pre_patch": "multi_update::initialize_tables(JOIN *join)\n{\n  TABLE_LIST *table_ref;\n  DBUG_ENTER(\"initialize_tables\");\n\n  if (unlikely((thd->variables.option_bits & OPTION_SAFE_UPDATES) &&\n               error_if_full_join(join)))\n    DBUG_RETURN(1);\n  if (join->implicit_grouping)\n  {\n    my_error(ER_INVALID_GROUP_FUNC_USE, MYF(0));\n    DBUG_RETURN(1);\n  }\n  main_table=join->join_tab->table;\n  table_to_update= 0;\n\n  /* Any update has at least one pair (field, value) */\n  DBUG_ASSERT(fields->elements);\n  /*\n   Only one table may be modified by UPDATE of an updatable view.\n   For an updatable view first_table_for_update indicates this\n   table.\n   For a regular multi-update it refers to some updated table.\n  */ \n  TABLE *first_table_for_update= ((Item_field *) fields->head())->field->table;\n\n  /* Create a temporary table for keys to all tables, except main table */\n  for (table_ref= update_tables; table_ref; table_ref= table_ref->next_local)\n  {\n    TABLE *table=table_ref->table;\n    uint cnt= table_ref->shared;\n    List<Item> temp_fields;\n    ORDER     group;\n    TMP_TABLE_PARAM *tmp_param;\n\n    if (ignore)\n      table->file->extra(HA_EXTRA_IGNORE_DUP_KEY);\n    if (table == main_table)\t\t\t// First table in join\n    {\n      if (safe_update_on_fly(thd, join->join_tab, table_ref, all_tables))\n      {\n\ttable_to_update= table;\t\t\t// Update table on the fly\n        has_vers_fields= table->vers_check_update(*fields);\n\tcontinue;\n      }\n    }\n    table->prepare_for_position();\n    join->map2table[table->tablenr]->keep_current_rowid= true;\n\n    /*\n      enable uncacheable flag if we update a view with check option\n      and check option has a subselect, otherwise, the check option\n      can be evaluated after the subselect was freed as independent\n      (See full_local in JOIN::join_free()).\n    */\n    if (table_ref->check_option && !join->select_lex->uncacheable)\n    {\n      SELECT_LEX_UNIT *tmp_unit;\n      SELECT_LEX *sl;\n      for (tmp_unit= join->select_lex->first_inner_unit();\n           tmp_unit;\n           tmp_unit= tmp_unit->next_unit())\n      {\n        for (sl= tmp_unit->first_select(); sl; sl= sl->next_select())\n        {\n          if (sl->master_unit()->item)\n          {\n            join->select_lex->uncacheable|= UNCACHEABLE_CHECKOPTION;\n            goto loop_end;\n          }\n        }\n      }\n    }\nloop_end:\n\n    if (table == first_table_for_update && table_ref->check_option)\n    {\n      table_map unupdated_tables= table_ref->check_option->used_tables() &\n                                  ~first_table_for_update->map;\n      List_iterator<TABLE_LIST> ti(*leaves);\n      TABLE_LIST *tbl_ref;\n      while ((tbl_ref= ti++) && unupdated_tables)\n      {\n        if (unupdated_tables & tbl_ref->table->map)\n          unupdated_tables&= ~tbl_ref->table->map;\n        else\n          continue;\n        if (unupdated_check_opt_tables.push_back(tbl_ref->table))\n          DBUG_RETURN(1);\n      }\n    }\n\n    tmp_param= tmp_table_param+cnt;\n\n    /*\n      Create a temporary table to store all fields that are changed for this\n      table. The first field in the temporary table is a pointer to the\n      original row so that we can find and update it. For the updatable\n      VIEW a few following fields are rowids of tables used in the CHECK\n      OPTION condition.\n    */\n\n    List_iterator_fast<TABLE> tbl_it(unupdated_check_opt_tables);\n    TABLE *tbl= table;\n    do\n    {\n      LEX_CSTRING field_name;\n      field_name.str= tbl->alias.c_ptr();\n      field_name.length= strlen(field_name.str);\n      /*\n        Signal each table (including tables referenced by WITH CHECK OPTION\n        clause) for which we will store row position in the temporary table\n        that we need a position to be read first.\n      */\n      tbl->prepare_for_position();\n      join->map2table[tbl->tablenr]->keep_current_rowid= true;\n\n      Item_temptable_rowid *item=\n        new (thd->mem_root) Item_temptable_rowid(tbl);\n      if (!item)\n         DBUG_RETURN(1);\n      item->fix_fields(thd, 0);\n      if (temp_fields.push_back(item, thd->mem_root))\n        DBUG_RETURN(1);\n    } while ((tbl= tbl_it++));\n\n    temp_fields.append(fields_for_table[cnt]);\n\n    /* Make an unique key over the first field to avoid duplicated updates */\n    bzero((char*) &group, sizeof(group));\n    group.direction= ORDER::ORDER_ASC;\n    group.item= (Item**) temp_fields.head_ref();\n\n    tmp_param->quick_group= 1;\n    tmp_param->field_count= temp_fields.elements;\n    tmp_param->func_count=  temp_fields.elements - 1;\n    calc_group_buffer(tmp_param, &group);\n    /* small table, ignore SQL_BIG_TABLES */\n    my_bool save_big_tables= thd->variables.big_tables; \n    thd->variables.big_tables= FALSE;\n    tmp_tables[cnt]=create_tmp_table(thd, tmp_param, temp_fields,\n                                     (ORDER*) &group, 0, 0,\n                                     TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &empty_clex_str);\n    thd->variables.big_tables= save_big_tables;\n    if (!tmp_tables[cnt])\n      DBUG_RETURN(1);\n    tmp_tables[cnt]->file->extra(HA_EXTRA_WRITE_CACHE);\n  }\n  join->tmp_table_keep_current_rowid= TRUE;\n  DBUG_RETURN(0);\n}",
        "post_patch": "multi_update::initialize_tables(JOIN *join)\n{\n  TABLE_LIST *table_ref;\n  DBUG_ENTER(\"initialize_tables\");\n\n  if (unlikely((thd->variables.option_bits & OPTION_SAFE_UPDATES) &&\n               error_if_full_join(join)))\n    DBUG_RETURN(1);\n  if (join->implicit_grouping)\n  {\n    my_error(ER_INVALID_GROUP_FUNC_USE, MYF(0));\n    DBUG_RETURN(1);\n  }\n  main_table=join->join_tab->table;\n  table_to_update= 0;\n\n  /* Any update has at least one pair (field, value) */\n  DBUG_ASSERT(fields->elements);\n  /*\n   Only one table may be modified by UPDATE of an updatable view.\n   For an updatable view first_table_for_update indicates this\n   table.\n   For a regular multi-update it refers to some updated table.\n  */ \n  TABLE *first_table_for_update= ((Item_field *) fields->head())->field->table;\n\n  /* Create a temporary table for keys to all tables, except main table */\n  for (table_ref= update_tables; table_ref; table_ref= table_ref->next_local)\n  {\n    TABLE *table=table_ref->table;\n    uint cnt= table_ref->shared;\n    List<Item> temp_fields;\n    ORDER     group;\n    TMP_TABLE_PARAM *tmp_param;\n\n    if (ignore)\n      table->file->extra(HA_EXTRA_IGNORE_DUP_KEY);\n    if (table == main_table)\t\t\t// First table in join\n    {\n      if (safe_update_on_fly(thd, join->join_tab, table_ref, all_tables))\n      {\n\ttable_to_update= table;\t\t\t// Update table on the fly\n        has_vers_fields= table->vers_check_update(*fields);\n\tcontinue;\n      }\n    }\n    table->prepare_for_position();\n    join->map2table[table->tablenr]->keep_current_rowid= true;\n\n    /*\n      enable uncacheable flag if we update a view with check option\n      and check option has a subselect, otherwise, the check option\n      can be evaluated after the subselect was freed as independent\n      (See full_local in JOIN::join_free()).\n    */\n    if (table_ref->check_option && !join->select_lex->uncacheable)\n    {\n      SELECT_LEX_UNIT *tmp_unit;\n      SELECT_LEX *sl;\n      for (tmp_unit= join->select_lex->first_inner_unit();\n           tmp_unit;\n           tmp_unit= tmp_unit->next_unit())\n      {\n        for (sl= tmp_unit->first_select(); sl; sl= sl->next_select())\n        {\n          if (sl->master_unit()->item)\n          {\n            join->select_lex->uncacheable|= UNCACHEABLE_CHECKOPTION;\n            goto loop_end;\n          }\n        }\n      }\n    }\nloop_end:\n\n    if (table == first_table_for_update && table_ref->check_option)\n    {\n      table_map unupdated_tables= table_ref->check_option->used_tables() &\n                                  ~first_table_for_update->map;\n      List_iterator<TABLE_LIST> ti(*leaves);\n      TABLE_LIST *tbl_ref;\n      while ((tbl_ref= ti++) && unupdated_tables)\n      {\n        if (unupdated_tables & tbl_ref->table->map)\n          unupdated_tables&= ~tbl_ref->table->map;\n        else\n          continue;\n        if (unupdated_check_opt_tables.push_back(tbl_ref->table))\n          DBUG_RETURN(1);\n      }\n    }\n\n    tmp_param= tmp_table_param+cnt;\n\n    /*\n      Create a temporary table to store all fields that are changed for this\n      table. The first field in the temporary table is a pointer to the\n      original row so that we can find and update it. For the updatable\n      VIEW a few following fields are rowids of tables used in the CHECK\n      OPTION condition.\n    */\n\n    List_iterator_fast<TABLE> tbl_it(unupdated_check_opt_tables);\n    TABLE *tbl= table;\n    do\n    {\n      LEX_CSTRING field_name;\n      field_name.str= tbl->alias.c_ptr();\n      field_name.length= strlen(field_name.str);\n      /*\n        Signal each table (including tables referenced by WITH CHECK OPTION\n        clause) for which we will store row position in the temporary table\n        that we need a position to be read first.\n      */\n      tbl->prepare_for_position();\n      join->map2table[tbl->tablenr]->keep_current_rowid= true;\n\n      Item_temptable_rowid *item=\n        new (thd->mem_root) Item_temptable_rowid(tbl);\n      if (!item)\n         DBUG_RETURN(1);\n      item->fix_fields(thd, 0);\n      if (temp_fields.push_back(item, thd->mem_root))\n        DBUG_RETURN(1);\n    } while ((tbl= tbl_it++));\n\n    temp_fields.append(fields_for_table[cnt]);\n\n    /* Make an unique key over the first field to avoid duplicated updates */\n    bzero((char*) &group, sizeof(group));\n    group.direction= ORDER::ORDER_ASC;\n    group.item= (Item**) temp_fields.head_ref();\n\n    tmp_param->quick_group= 1;\n    tmp_param->field_count= temp_fields.elements;\n    tmp_param->func_count=  temp_fields.elements - 1;\n    calc_group_buffer(tmp_param, &group);\n    /* small table, ignore SQL_BIG_TABLES */\n    my_bool save_big_tables= thd->variables.big_tables; \n    thd->variables.big_tables= FALSE;\n    tmp_tables[cnt]=create_tmp_table(thd, tmp_param, temp_fields,\n                                     (ORDER*) &group, 0, 0,\n                                     TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &empty_clex_str);\n    thd->variables.big_tables= save_big_tables;\n    if (!tmp_tables[cnt])\n      DBUG_RETURN(1);\n    tmp_tables[cnt]->file->extra(HA_EXTRA_WRITE_CACHE);\n  }\n  join->tmp_table_keep_current_rowid= TRUE;\n  DBUG_RETURN(0);\n}",
        "label": 0
    },
    {
        "pre_patch": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n\n  hide_controls_timer_.Reset();\n\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true /* should_pause_video */,\n                       true /* should_reset_pip_player */);\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n  views::Widget::OnGestureEvent(event);\n }\n",
        "post_patch": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n\n  hide_controls_timer_.Reset();\n\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true /* should_pause_video */,\n                       true /* should_reset_pip_player */);\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n }\n",
        "label": 1
    },
    {
        "pre_patch": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (dl->length < so_ext_len ||\n      my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}",
        "post_patch": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (dl->length < so_ext_len ||\n      my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}",
        "label": 0
    },
    {
        "pre_patch": "static MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MaxTextExtent-1)) \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MaxTextExtent-1)) \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      description[36];\n  } TagInfo;\n\n  static const TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },  /* specs as \"Exif IFD Pointer\"? */\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" }, /* specs as \"GPSInfo IFD Pointer\"? */\n      {  0x8827, \"exif:PhotographicSensitivity\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },      \n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x8830, \"exif:SensitivityType\" },\n      {  0x8831, \"exif:StandardOutputSensitivity\" },\n      {  0x8832, \"exif:RecommendedExposureIndex\" },\n      {  0x8833, \"exif:ISOSpeed\" },\n      {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n      {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9010, \"exif:OffsetTime\" },\n      {  0x9011, \"exif:OffsetTimeOriginal\" },\n      {  0x9012, \"exif:OffsetTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9400, \"exif:Temperature\" },\n      {  0x9401, \"exif:Humidity\" },\n      {  0x9402, \"exif:Pressure\" },\n      {  0x9403, \"exif:WaterDepth\" },\n      {  0x9404, \"exif:Acceleration\" },\n      {  0x9405, \"exif:CameraElevationAngle\" },    \n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },      \n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:PixelXDimension\" },\n      {  0xa003, \"exif:PixelYDimension\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xa430, \"exif:CameraOwnerName\" },\n      {  0xa431, \"exif:BodySerialNumber\" },\n      {  0xa432, \"exif:LensSpecification\" },\n      {  0xa433, \"exif:LensMake\" },\n      {  0xa434, \"exif:LensModel\" },\n      {  0xa435, \"exif:LensSerialNumber\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x1001f, \"exif:GPSHPositioningError\" },\n      { 0x00000, \"\" }\n    };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf */\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  if (length < 6)\n    return(MagickFalse);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      if (format == 0)\n        break;  /* corrupt EXIF */\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            dir_offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((dir_offset < 0) || (size_t) dir_offset >= length)\n            continue;\n          if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n            continue;  /* prevent overflow */\n          if (((size_t) dir_offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+dir_offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MaxTextExtent],\n            *value;\n\n          if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n            break;\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if (isprint((int) p[i]) != 0) \n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            case EXIF_FMT_STRING:\n            default:\n            {\n              if ((p < exif) || (p > (exif+length-number_bytes)))\n                break;\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MaxTextExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MaxTextExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                /*\n                  Check for duplicate tag.\n                */\n                for (i=0; i < level; i++)\n                  if (directory_stack[i].directory == (exif+tag_offset1))\n                    break;\n                if (i < level)\n                  break;  /* duplicate tag */\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)+4) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}",
        "post_patch": "static MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MaxTextExtent-1)) \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MaxTextExtent-1)) \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      description[36];\n  } TagInfo;\n\n  static const TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },  /* specs as \"Exif IFD Pointer\"? */\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" }, /* specs as \"GPSInfo IFD Pointer\"? */\n      {  0x8827, \"exif:PhotographicSensitivity\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },      \n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x8830, \"exif:SensitivityType\" },\n      {  0x8831, \"exif:StandardOutputSensitivity\" },\n      {  0x8832, \"exif:RecommendedExposureIndex\" },\n      {  0x8833, \"exif:ISOSpeed\" },\n      {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n      {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9010, \"exif:OffsetTime\" },\n      {  0x9011, \"exif:OffsetTimeOriginal\" },\n      {  0x9012, \"exif:OffsetTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9400, \"exif:Temperature\" },\n      {  0x9401, \"exif:Humidity\" },\n      {  0x9402, \"exif:Pressure\" },\n      {  0x9403, \"exif:WaterDepth\" },\n      {  0x9404, \"exif:Acceleration\" },\n      {  0x9405, \"exif:CameraElevationAngle\" },    \n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },      \n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:PixelXDimension\" },\n      {  0xa003, \"exif:PixelYDimension\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xa430, \"exif:CameraOwnerName\" },\n      {  0xa431, \"exif:BodySerialNumber\" },\n      {  0xa432, \"exif:LensSpecification\" },\n      {  0xa433, \"exif:LensMake\" },\n      {  0xa434, \"exif:LensModel\" },\n      {  0xa435, \"exif:LensSerialNumber\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x1001f, \"exif:GPSHPositioningError\" },\n      { 0x00000, \"\" }\n    };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf */\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  if (length < 6)\n    return(MagickFalse);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      if (format == 0)\n        break;  /* corrupt EXIF */\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            dir_offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((dir_offset < 0) || (size_t) dir_offset >= length)\n            continue;\n          if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n            continue;  /* prevent overflow */\n          if (((size_t) dir_offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+dir_offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MaxTextExtent],\n            *value;\n\n          if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n            break;\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if (isprint((int) p[i]) != 0) \n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_STRING:\n            default:\n            {\n              if ((p < exif) || (p > (exif+length-number_bytes)))\n                break;\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MaxTextExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MaxTextExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                /*\n                  Check for duplicate tag.\n                */\n                for (i=0; i < level; i++)\n                  if (directory_stack[i].directory == (exif+tag_offset1))\n                    break;\n                if (i < level)\n                  break;  /* duplicate tag */\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)+4) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}",
        "label": 1
    },
    {
        "pre_patch": "bool Item_equal::create_pushable_equalities(THD *thd,\n                                            List<Item> *equalities,\n                                            Pushdown_checker checker,\n                                            uchar *arg,\n                                            bool clone_const)\n{\n  Item *item;\n  Item *left_item= NULL;\n  Item *right_item = get_const();\n  Item_equal_fields_iterator it(*this);\n\n  while ((item=it++))\n  {\n    left_item= item;\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    break;\n  }\n\n  if (!left_item)\n    return false;\n\n  if (right_item)\n  {\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= !clone_const ?\n                            right_item : right_item->build_clone(thd);\n    if (!left_item_clone || !right_item_clone)\n      return true;\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         left_item_clone,\n                                         right_item_clone);\n    if (!eq ||  equalities->push_back(eq, thd->mem_root))\n      return true;\n    if (!clone_const)\n    {\n      /*\n        Also set IMMUTABLE_FL for any sub-items of the right_item.\n        This is needed to prevent Item::cleanup_excluding_immutables_processor\n        from peforming cleanup of the sub-items and so creating an item tree\n        where a fixed item has non-fixed items inside it.\n      */\n      int new_flag= IMMUTABLE_FL;\n      right_item->walk(&Item::set_extraction_flag_processor, false,\n                       (void*)&new_flag);\n    }\n  }\n\n  while ((item=it++))\n  {\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= item->build_clone(thd);\n    if (!(left_item_clone && right_item_clone))\n      return true;\n    left_item_clone->set_item_equal(NULL);\n    right_item_clone->set_item_equal(NULL);\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         right_item_clone,\n                                         left_item_clone);\n    if (!eq || equalities->push_back(eq, thd->mem_root))\n      return true;\n  }\n  return false;\n}",
        "post_patch": "bool Item_equal::create_pushable_equalities(THD *thd,\n                                            List<Item> *equalities,\n                                            Pushdown_checker checker,\n                                            uchar *arg,\n                                            bool clone_const)\n{\n  Item *item;\n  Item *left_item= NULL;\n  Item *right_item = get_const();\n  Item_equal_fields_iterator it(*this);\n\n  while ((item=it++))\n  {\n    left_item= item;\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    break;\n  }\n\n  if (!left_item)\n    return false;\n\n  if (right_item)\n  {\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= !clone_const ?\n                            right_item : right_item->build_clone(thd);\n    if (!left_item_clone || !right_item_clone)\n      return true;\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         left_item_clone,\n                                         right_item_clone);\n    if (!eq ||  equalities->push_back(eq, thd->mem_root))\n      return true;\n    if (!clone_const)\n    {\n      /*\n        Also set IMMUTABLE_FL for any sub-items of the right_item.\n        This is needed to prevent Item::cleanup_excluding_immutables_processor\n        from peforming cleanup of the sub-items and so creating an item tree\n        where a fixed item has non-fixed items inside it.\n      */\n      int new_flag= IMMUTABLE_FL;\n      right_item->walk(&Item::set_extraction_flag_processor, false,\n                       (void*)&new_flag);\n    }\n  }\n\n  while ((item=it++))\n  {\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= item->build_clone(thd);\n    if (!(left_item_clone && right_item_clone))\n      return true;\n    left_item_clone->set_item_equal(NULL);\n    right_item_clone->set_item_equal(NULL);\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         right_item_clone,\n                                         left_item_clone);\n    if (!eq || equalities->push_back(eq, thd->mem_root))\n      return true;\n  }\n  return false;\n}",
        "label": 0
    },
    {
        "pre_patch": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
        "post_patch": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,\n            (((unsigned char) ((ssize_t) pixel)) & (0x01 << (7-bit))) != 0 ? 0 :\n            QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
        "label": 1
    },
    {
        "pre_patch": "bool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)\n{\n  TABLE *table;\n  const char *key;\n  uint\tkey_length;\n  const char *alias= table_list->alias.str;\n  uint flags= ot_ctx->get_flags();\n  MDL_ticket *mdl_ticket;\n  TABLE_SHARE *share;\n  uint gts_flags;\n  bool from_share= false;\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  int part_names_error=0;\n#endif\n  DBUG_ENTER(\"open_table\");\n\n  /*\n    The table must not be opened already. The table can be pre-opened for\n    some statements if it is a temporary table.\n\n    open_temporary_table() must be used to open temporary tables.\n  */\n  DBUG_ASSERT(!table_list->table);\n\n  /* an open table operation needs a lot of the stack space */\n  if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))\n    DBUG_RETURN(TRUE);\n\n  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed)\n  {\n    thd->send_kill_message();\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Check if we're trying to take a write lock in a read only transaction.\n\n    Note that we allow write locks on log tables as otherwise logging\n    to general/slow log would be disabled in read only transactions.\n  */\n  if (table_list->mdl_request.is_write_lock_request() &&\n      thd->tx_read_only &&\n      !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK)))\n  {\n    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));\n    DBUG_RETURN(true);\n  }\n\n  if (!table_list->db.str)\n  {\n    my_error(ER_NO_DB_ERROR, MYF(0));\n    DBUG_RETURN(true);\n  }\n\n  key_length= get_table_def_key(table_list, &key);\n\n  /*\n    If we're in pre-locked or LOCK TABLES mode, let's try to find the\n    requested table in the list of pre-opened and locked tables. If the\n    table is not there, return an error - we can't open not pre-opened\n    tables in pre-locked/LOCK TABLES mode.\n    TODO: move this block into a separate function.\n  */\n  if (thd->locked_tables_mode &&\n      ! (flags & MYSQL_OPEN_GET_NEW_TABLE))\n  {\t\t\t\t\t\t// Using table locks\n    TABLE *best_table= 0;\n    int best_distance= INT_MIN;\n    for (table=thd->open_tables; table ; table=table->next)\n    {\n      if (table->s->table_cache_key.length == key_length &&\n\t  !memcmp(table->s->table_cache_key.str, key, key_length))\n      {\n        if (!my_strcasecmp(system_charset_info, table->alias.c_ptr(), alias) &&\n            table->query_id != thd->query_id && /* skip tables already used */\n            (thd->locked_tables_mode == LTM_LOCK_TABLES ||\n             table->query_id == 0))\n        {\n          int distance= ((int) table->reginfo.lock_type -\n                         (int) table_list->lock_type);\n\n          /*\n            Find a table that either has the exact lock type requested,\n            or has the best suitable lock. In case there is no locked\n            table that has an equal or higher lock than requested,\n            we us the closest matching lock to be able to produce an error\n            message about wrong lock mode on the table. The best_table\n            is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.\n\n            distance <  0 - No suitable lock found\n            distance >  0 - we have lock mode higher then we require\n            distance == 0 - we have lock mode exactly which we need\n          */\n          if ((best_distance < 0 && distance > best_distance) ||\n              (distance >= 0 && distance < best_distance))\n          {\n            best_distance= distance;\n            best_table= table;\n            if (best_distance == 0)\n            {\n              /*\n                We have found a perfect match and can finish iterating\n                through open tables list. Check for table use conflict\n                between calling statement and SP/trigger is done in\n                lock_tables().\n              */\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (best_table)\n    {\n      table= best_table;\n      table->query_id= thd->query_id;\n      table->init(thd, table_list);\n      DBUG_PRINT(\"info\",(\"Using locked table\"));\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n      part_names_error= set_partitions_as_used(table_list, table);\n#endif\n      goto reset;\n    }\n\n    if (is_locked_view(thd, table_list))\n    {\n      if (table_list->sequence)\n      {\n        my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n        DBUG_RETURN(true);\n      }\n      DBUG_RETURN(FALSE); // VIEW\n    }\n\n    /*\n      No table in the locked tables list. In case of explicit LOCK TABLES\n      this can happen if a user did not include the table into the list.\n      In case of pre-locked mode locked tables list is generated automatically,\n      so we may only end up here if the table did not exist when\n      locked tables list was created.\n    */\n    if (thd->locked_tables_mode == LTM_PRELOCKED)\n      my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db.str, table_list->alias.str);\n    else\n      my_error(ER_TABLE_NOT_LOCKED, MYF(0), alias);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Non pre-locked/LOCK TABLES mode, and the table is not temporary.\n    This is the normal use case.\n  */\n\n  if (! (flags & MYSQL_OPEN_HAS_MDL_LOCK))\n  {\n    /*\n      We are not under LOCK TABLES and going to acquire write-lock/\n      modify the base table. We need to acquire protection against\n      global read lock until end of this statement in order to have\n      this statement blocked by active FLUSH TABLES WITH READ LOCK.\n\n      We don't need to acquire this protection under LOCK TABLES as\n      such protection already acquired at LOCK TABLES time and\n      not released until UNLOCK TABLES.\n\n      We don't block statements which modify only temporary tables\n      as these tables are not preserved by any form of\n      backup which uses FLUSH TABLES WITH READ LOCK.\n\n      TODO: The fact that we sometimes acquire protection against\n            GRL only when we encounter table to be write-locked\n            slightly increases probability of deadlock.\n            This problem will be solved once Alik pushes his\n            temporary table refactoring patch and we can start\n            pre-acquiring metadata locks at the beggining of\n            open_tables() call.\n    */\n    if (table_list->mdl_request.is_write_lock_request() &&\n        ! (flags & (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK |\n                    MYSQL_OPEN_FORCE_SHARED_MDL |\n                    MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |\n                    MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&\n        ! ot_ctx->has_protection_against_grl())\n    {\n      MDL_request protection_request;\n      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n\n      if (thd->global_read_lock.can_acquire_protection())\n        DBUG_RETURN(TRUE);\n\n      protection_request.init(MDL_key::GLOBAL, \"\", \"\", MDL_INTENTION_EXCLUSIVE,\n                              MDL_STATEMENT);\n\n      /*\n        Install error handler which if possible will convert deadlock error\n        into request to back-off and restart process of opening tables.\n      */\n      thd->push_internal_handler(&mdl_deadlock_handler);\n      bool result= thd->mdl_context.acquire_lock(&protection_request,\n                                                 ot_ctx->get_timeout());\n      thd->pop_internal_handler();\n\n      if (result)\n        DBUG_RETURN(TRUE);\n\n      ot_ctx->set_has_protection_against_grl();\n    }\n\n    if (open_table_get_mdl_lock(thd, ot_ctx, &table_list->mdl_request,\n                                flags, &mdl_ticket) ||\n        mdl_ticket == NULL)\n    {\n      DEBUG_SYNC(thd, \"before_open_table_wait_refresh\");\n      DBUG_RETURN(TRUE);\n    }\n    DEBUG_SYNC(thd, \"after_open_table_mdl_shared\");\n  }\n  else\n  {\n    /*\n      Grab reference to the MDL lock ticket that was acquired\n      by the caller.\n    */\n    mdl_ticket= table_list->mdl_request.ticket;\n  }\n\n  if (table_list->open_strategy == TABLE_LIST::OPEN_IF_EXISTS)\n  {\n    if (!ha_table_exists(thd, &table_list->db, &table_list->table_name))\n      DBUG_RETURN(FALSE);\n  }\n  else if (table_list->open_strategy == TABLE_LIST::OPEN_STUB)\n    DBUG_RETURN(FALSE);\n\n  /* Table exists. Let us try to open it. */\n\n  if (table_list->i_s_requested_object & OPEN_TABLE_ONLY)\n    gts_flags= GTS_TABLE;\n  else if (table_list->i_s_requested_object &  OPEN_VIEW_ONLY)\n    gts_flags= GTS_VIEW;\n  else\n    gts_flags= GTS_TABLE | GTS_VIEW;\n\nretry_share:\n\n  share= tdc_acquire_share(thd, table_list, gts_flags, &table);\n\n  if (unlikely(!share))\n  {\n    /*\n      Hide \"Table doesn't exist\" errors if the table belongs to a view.\n      The check for thd->is_error() is necessary to not push an\n      unwanted error in case the error was already silenced.\n      @todo Rework the alternative ways to deal with ER_NO_SUCH TABLE.\n    */\n    if (thd->is_error())\n    {\n      if (table_list->parent_l)\n      {\n        thd->clear_error();\n        my_error(ER_WRONG_MRG_TABLE, MYF(0));\n      }\n      else if (table_list->belong_to_view)\n      {\n        TABLE_LIST *view= table_list->belong_to_view;\n        thd->clear_error();\n        my_error(ER_VIEW_INVALID, MYF(0),\n                 view->view_db.str, view->view_name.str);\n      }\n    }\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Check if this TABLE_SHARE-object corresponds to a view. Note, that there is\n    no need to check TABLE_SHARE::tdc.flushed as we do for regular tables,\n    because view shares are always up to date.\n  */\n  if (share->is_view)\n  {\n    /*\n      If parent_l of the table_list is non null then a merge table\n      has this view as child table, which is not supported.\n    */\n    if (table_list->parent_l)\n    {\n      my_error(ER_WRONG_MRG_TABLE, MYF(0));\n      goto err_lock;\n    }\n    if (table_list->sequence)\n    {\n      my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str,\n               table_list->alias.str);\n      goto err_lock;\n    }\n    /*\n      This table is a view. Validate its metadata version: in particular,\n      that it was a view when the statement was prepared.\n    */\n    if (check_and_update_table_version(thd, table_list, share))\n      goto err_lock;\n\n    /* Open view */\n    if (mysql_make_view(thd, share, table_list, false))\n      goto err_lock;\n\n\n    /* TODO: Don't free this */\n    tdc_release_share(share);\n\n    DBUG_ASSERT(table_list->view);\n\n    DBUG_RETURN(FALSE);\n  }\n\n#ifdef WITH_WSREP\n  if (!((flags & MYSQL_OPEN_IGNORE_FLUSH) ||\n        (thd->wsrep_applier)))\n#else\n  if (!(flags & MYSQL_OPEN_IGNORE_FLUSH))\n#endif\n  {\n    if (share->tdc->flushed)\n    {\n      DBUG_PRINT(\"info\", (\"Found old share version: %lld  current: %lld\",\n                          share->tdc->version, tdc_refresh_version()));\n      /*\n        We already have an MDL lock. But we have encountered an old\n        version of table in the table definition cache which is possible\n        when someone changes the table version directly in the cache\n        without acquiring a metadata lock (e.g. this can happen during\n        \"rolling\" FLUSH TABLE(S)).\n        Release our reference to share, wait until old version of\n        share goes away and then try to get new version of table share.\n      */\n      if (table)\n        tc_release_table(table);\n      else\n        tdc_release_share(share);\n\n      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n      bool wait_result;\n\n      thd->push_internal_handler(&mdl_deadlock_handler);\n      wait_result= tdc_wait_for_old_version(thd, table_list->db.str,\n                                            table_list->table_name.str,\n                                            ot_ctx->get_timeout(),\n                                            mdl_ticket->get_deadlock_weight());\n      thd->pop_internal_handler();\n\n      if (wait_result)\n        DBUG_RETURN(TRUE);\n\n      goto retry_share;\n    }\n\n    if (thd->open_tables && thd->open_tables->s->tdc->flushed)\n    {\n      /*\n        If the version changes while we're opening the tables,\n        we have to back off, close all the tables opened-so-far,\n        and try to reopen them. Note: refresh_version is currently\n        changed only during FLUSH TABLES.\n      */\n      if (table)\n        tc_release_table(table);\n      else\n        tdc_release_share(share);\n      (void)ot_ctx->request_backoff_action(Open_table_context::OT_REOPEN_TABLES,\n                                           NULL);\n      DBUG_RETURN(TRUE);\n    }\n  }\n\n  if (table)\n  {\n    DBUG_ASSERT(table->file != NULL);\n    MYSQL_REBIND_TABLE(table->file);\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n    part_names_error= set_partitions_as_used(table_list, table);\n#endif\n  }\n  else\n  {\n    enum open_frm_error error;\n\n    /* make a new table */\n    if (!(table=(TABLE*) my_malloc(sizeof(*table),MYF(MY_WME))))\n      goto err_lock;\n\n    error= open_table_from_share(thd, share, &table_list->alias,\n                                 HA_OPEN_KEYFILE | HA_TRY_READ_ONLY,\n                                 EXTRA_RECORD,\n                                 thd->open_options, table, FALSE,\n                                 IF_PARTITIONING(table_list->partition_names,0));\n\n    if (unlikely(error))\n    {\n      my_free(table);\n\n      if (error == OPEN_FRM_DISCOVER)\n        (void) ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,\n                                              table_list);\n      else if (share->crashed)\n      {\n        if (!(flags & MYSQL_OPEN_IGNORE_REPAIR))\n          (void) ot_ctx->request_backoff_action(Open_table_context::OT_REPAIR,\n                                                table_list);\n        else\n          table_list->crashed= 1;  /* Mark that table was crashed */\n      }\n      goto err_lock;\n    }\n    if (open_table_entry_fini(thd, share, table))\n    {\n      closefrm(table);\n      my_free(table);\n      goto err_lock;\n    }\n\n    /* Add table to the share's used tables list. */\n    tc_add_table(thd, table);\n    from_share= true;\n  }\n\n  table->mdl_ticket= mdl_ticket;\n  table->reginfo.lock_type=TL_READ;\t\t/* Assume read */\n\n  table->init(thd, table_list);\n\n  table->next= thd->open_tables;\t\t/* Link into simple list */\n  thd->set_open_tables(table);\n\n reset:\n  /*\n    Check that there is no reference to a condition from an earlier query\n    (cf. Bug#58553). \n  */\n  DBUG_ASSERT(table->file->pushed_cond == NULL);\n  table_list->updatable= 1; // It is not derived table nor non-updatable VIEW\n  table_list->table= table;\n\n  if (!from_share && table->vcol_fix_expr(thd))\n    DBUG_RETURN(true);\n\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  if (unlikely(table->part_info))\n  {\n    /* Partitions specified were incorrect.*/\n    if (part_names_error)\n    {\n      table->file->print_error(part_names_error, MYF(0));\n      DBUG_RETURN(true);\n    }\n  }\n  else if (table_list->partition_names)\n  {\n    /* Don't allow PARTITION () clause on a nonpartitioned table */\n    my_error(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));\n    DBUG_RETURN(true);\n  }\n#endif\n  if (table_list->sequence && table->s->table_type != TABLE_TYPE_SEQUENCE)\n  {\n    my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n    DBUG_RETURN(true);\n  }\n\n  DBUG_RETURN(FALSE);\n\nerr_lock:\n  tdc_release_share(share);\n\n  DBUG_PRINT(\"exit\", (\"failed\"));\n  DBUG_RETURN(TRUE);\n}",
        "post_patch": "bool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)\n{\n  TABLE *table;\n  const char *key;\n  uint\tkey_length;\n  const char *alias= table_list->alias.str;\n  uint flags= ot_ctx->get_flags();\n  MDL_ticket *mdl_ticket;\n  TABLE_SHARE *share;\n  uint gts_flags;\n  bool from_share= false;\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  int part_names_error=0;\n#endif\n  DBUG_ENTER(\"open_table\");\n\n  /*\n    The table must not be opened already. The table can be pre-opened for\n    some statements if it is a temporary table.\n\n    open_temporary_table() must be used to open temporary tables.\n  */\n  DBUG_ASSERT(!table_list->table);\n\n  /* an open table operation needs a lot of the stack space */\n  if (check_stack_overrun(thd, STACK_MIN_SIZE_FOR_OPEN, (uchar *)&alias))\n    DBUG_RETURN(TRUE);\n\n  if (!(flags & MYSQL_OPEN_IGNORE_KILLED) && thd->killed)\n  {\n    thd->send_kill_message();\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Check if we're trying to take a write lock in a read only transaction.\n\n    Note that we allow write locks on log tables as otherwise logging\n    to general/slow log would be disabled in read only transactions.\n  */\n  if (table_list->mdl_request.is_write_lock_request() &&\n      thd->tx_read_only &&\n      !(flags & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK)))\n  {\n    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));\n    DBUG_RETURN(true);\n  }\n\n  if (!table_list->db.str)\n  {\n    my_error(ER_NO_DB_ERROR, MYF(0));\n    DBUG_RETURN(true);\n  }\n\n  key_length= get_table_def_key(table_list, &key);\n\n  /*\n    If we're in pre-locked or LOCK TABLES mode, let's try to find the\n    requested table in the list of pre-opened and locked tables. If the\n    table is not there, return an error - we can't open not pre-opened\n    tables in pre-locked/LOCK TABLES mode.\n    TODO: move this block into a separate function.\n  */\n  if (thd->locked_tables_mode &&\n      ! (flags & MYSQL_OPEN_GET_NEW_TABLE))\n  {\t\t\t\t\t\t// Using table locks\n    TABLE *best_table= 0;\n    int best_distance= INT_MIN;\n    for (table=thd->open_tables; table ; table=table->next)\n    {\n      if (table->s->table_cache_key.length == key_length &&\n\t  !memcmp(table->s->table_cache_key.str, key, key_length))\n      {\n        if (!my_strcasecmp(system_charset_info, table->alias.c_ptr(), alias) &&\n            table->query_id != thd->query_id && /* skip tables already used */\n            (thd->locked_tables_mode == LTM_LOCK_TABLES ||\n             table->query_id == 0))\n        {\n          int distance= ((int) table->reginfo.lock_type -\n                         (int) table_list->lock_type);\n\n          /*\n            Find a table that either has the exact lock type requested,\n            or has the best suitable lock. In case there is no locked\n            table that has an equal or higher lock than requested,\n            we us the closest matching lock to be able to produce an error\n            message about wrong lock mode on the table. The best_table\n            is changed if bd < 0 <= d or bd < d < 0 or 0 <= d < bd.\n\n            distance <  0 - No suitable lock found\n            distance >  0 - we have lock mode higher then we require\n            distance == 0 - we have lock mode exactly which we need\n          */\n          if ((best_distance < 0 && distance > best_distance) ||\n              (distance >= 0 && distance < best_distance))\n          {\n            best_distance= distance;\n            best_table= table;\n            if (best_distance == 0)\n            {\n              /*\n                We have found a perfect match and can finish iterating\n                through open tables list. Check for table use conflict\n                between calling statement and SP/trigger is done in\n                lock_tables().\n              */\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (best_table)\n    {\n      table= best_table;\n      table->query_id= thd->query_id;\n      table->init(thd, table_list);\n      DBUG_PRINT(\"info\",(\"Using locked table\"));\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n      part_names_error= set_partitions_as_used(table_list, table);\n#endif\n      goto reset;\n    }\n\n    if (is_locked_view(thd, table_list))\n    {\n      if (table_list->sequence)\n      {\n        my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n        DBUG_RETURN(true);\n      }\n      DBUG_RETURN(FALSE); // VIEW\n    }\n\n    /*\n      No table in the locked tables list. In case of explicit LOCK TABLES\n      this can happen if a user did not include the table into the list.\n      In case of pre-locked mode locked tables list is generated automatically,\n      so we may only end up here if the table did not exist when\n      locked tables list was created.\n    */\n    if (thd->locked_tables_mode == LTM_PRELOCKED)\n      my_error(ER_NO_SUCH_TABLE, MYF(0), table_list->db.str, table_list->alias.str);\n    else\n      my_error(ER_TABLE_NOT_LOCKED, MYF(0), alias);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Non pre-locked/LOCK TABLES mode, and the table is not temporary.\n    This is the normal use case.\n  */\n\n  if (! (flags & MYSQL_OPEN_HAS_MDL_LOCK))\n  {\n    /*\n      We are not under LOCK TABLES and going to acquire write-lock/\n      modify the base table. We need to acquire protection against\n      global read lock until end of this statement in order to have\n      this statement blocked by active FLUSH TABLES WITH READ LOCK.\n\n      We don't need to acquire this protection under LOCK TABLES as\n      such protection already acquired at LOCK TABLES time and\n      not released until UNLOCK TABLES.\n\n      We don't block statements which modify only temporary tables\n      as these tables are not preserved by any form of\n      backup which uses FLUSH TABLES WITH READ LOCK.\n\n      TODO: The fact that we sometimes acquire protection against\n            GRL only when we encounter table to be write-locked\n            slightly increases probability of deadlock.\n            This problem will be solved once Alik pushes his\n            temporary table refactoring patch and we can start\n            pre-acquiring metadata locks at the beggining of\n            open_tables() call.\n    */\n    if (table_list->mdl_request.is_write_lock_request() &&\n        ! (flags & (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK |\n                    MYSQL_OPEN_FORCE_SHARED_MDL |\n                    MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |\n                    MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&\n        ! ot_ctx->has_protection_against_grl())\n    {\n      MDL_request protection_request;\n      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n\n      if (thd->global_read_lock.can_acquire_protection())\n        DBUG_RETURN(TRUE);\n\n      protection_request.init(MDL_key::GLOBAL, \"\", \"\", MDL_INTENTION_EXCLUSIVE,\n                              MDL_STATEMENT);\n\n      /*\n        Install error handler which if possible will convert deadlock error\n        into request to back-off and restart process of opening tables.\n      */\n      thd->push_internal_handler(&mdl_deadlock_handler);\n      bool result= thd->mdl_context.acquire_lock(&protection_request,\n                                                 ot_ctx->get_timeout());\n      thd->pop_internal_handler();\n\n      if (result)\n        DBUG_RETURN(TRUE);\n\n      ot_ctx->set_has_protection_against_grl();\n    }\n\n    if (open_table_get_mdl_lock(thd, ot_ctx, &table_list->mdl_request,\n                                flags, &mdl_ticket) ||\n        mdl_ticket == NULL)\n    {\n      DEBUG_SYNC(thd, \"before_open_table_wait_refresh\");\n      DBUG_RETURN(TRUE);\n    }\n    DEBUG_SYNC(thd, \"after_open_table_mdl_shared\");\n  }\n  else\n  {\n    /*\n      Grab reference to the MDL lock ticket that was acquired\n      by the caller.\n    */\n    mdl_ticket= table_list->mdl_request.ticket;\n  }\n\n  if (table_list->open_strategy == TABLE_LIST::OPEN_IF_EXISTS)\n  {\n    if (!ha_table_exists(thd, &table_list->db, &table_list->table_name))\n      DBUG_RETURN(FALSE);\n  }\n  else if (table_list->open_strategy == TABLE_LIST::OPEN_STUB)\n    DBUG_RETURN(FALSE);\n\n  /* Table exists. Let us try to open it. */\n\n  if (table_list->i_s_requested_object & OPEN_TABLE_ONLY)\n    gts_flags= GTS_TABLE;\n  else if (table_list->i_s_requested_object &  OPEN_VIEW_ONLY)\n    gts_flags= GTS_VIEW;\n  else\n    gts_flags= GTS_TABLE | GTS_VIEW;\n\nretry_share:\n\n  share= tdc_acquire_share(thd, table_list, gts_flags, &table);\n\n  if (unlikely(!share))\n  {\n    /*\n      Hide \"Table doesn't exist\" errors if the table belongs to a view.\n      The check for thd->is_error() is necessary to not push an\n      unwanted error in case the error was already silenced.\n      @todo Rework the alternative ways to deal with ER_NO_SUCH TABLE.\n    */\n    if (thd->is_error())\n    {\n      if (table_list->parent_l)\n      {\n        thd->clear_error();\n        my_error(ER_WRONG_MRG_TABLE, MYF(0));\n      }\n      else if (table_list->belong_to_view)\n      {\n        TABLE_LIST *view= table_list->belong_to_view;\n        thd->clear_error();\n        my_error(ER_VIEW_INVALID, MYF(0),\n                 view->view_db.str, view->view_name.str);\n      }\n    }\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Check if this TABLE_SHARE-object corresponds to a view. Note, that there is\n    no need to check TABLE_SHARE::tdc.flushed as we do for regular tables,\n    because view shares are always up to date.\n  */\n  if (share->is_view)\n  {\n    /*\n      If parent_l of the table_list is non null then a merge table\n      has this view as child table, which is not supported.\n    */\n    if (table_list->parent_l)\n    {\n      my_error(ER_WRONG_MRG_TABLE, MYF(0));\n      goto err_lock;\n    }\n    if (table_list->sequence)\n    {\n      my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str,\n               table_list->alias.str);\n      goto err_lock;\n    }\n    /*\n      This table is a view. Validate its metadata version: in particular,\n      that it was a view when the statement was prepared.\n    */\n    if (check_and_update_table_version(thd, table_list, share))\n      goto err_lock;\n\n    /* Open view */\n    if (mysql_make_view(thd, share, table_list, false))\n      goto err_lock;\n\n\n    /* TODO: Don't free this */\n    tdc_release_share(share);\n\n    DBUG_ASSERT(table_list->view);\n\n    DBUG_RETURN(FALSE);\n  }\n\n#ifdef WITH_WSREP\n  if (!((flags & MYSQL_OPEN_IGNORE_FLUSH) ||\n        (thd->wsrep_applier)))\n#else\n  if (!(flags & MYSQL_OPEN_IGNORE_FLUSH))\n#endif\n  {\n    if (share->tdc->flushed)\n    {\n      DBUG_PRINT(\"info\", (\"Found old share version: %lld  current: %lld\",\n                          share->tdc->version, tdc_refresh_version()));\n      /*\n        We already have an MDL lock. But we have encountered an old\n        version of table in the table definition cache which is possible\n        when someone changes the table version directly in the cache\n        without acquiring a metadata lock (e.g. this can happen during\n        \"rolling\" FLUSH TABLE(S)).\n        Release our reference to share, wait until old version of\n        share goes away and then try to get new version of table share.\n      */\n      if (table)\n        tc_release_table(table);\n      else\n        tdc_release_share(share);\n\n      MDL_deadlock_handler mdl_deadlock_handler(ot_ctx);\n      bool wait_result;\n\n      thd->push_internal_handler(&mdl_deadlock_handler);\n      wait_result= tdc_wait_for_old_version(thd, table_list->db.str,\n                                            table_list->table_name.str,\n                                            ot_ctx->get_timeout(),\n                                            mdl_ticket->get_deadlock_weight());\n      thd->pop_internal_handler();\n\n      if (wait_result)\n        DBUG_RETURN(TRUE);\n\n      goto retry_share;\n    }\n\n    if (thd->open_tables && thd->open_tables->s->tdc->flushed)\n    {\n      /*\n        If the version changes while we're opening the tables,\n        we have to back off, close all the tables opened-so-far,\n        and try to reopen them. Note: refresh_version is currently\n        changed only during FLUSH TABLES.\n      */\n      if (table)\n        tc_release_table(table);\n      else\n        tdc_release_share(share);\n      (void)ot_ctx->request_backoff_action(Open_table_context::OT_REOPEN_TABLES,\n                                           NULL);\n      DBUG_RETURN(TRUE);\n    }\n  }\n\n  if (table)\n  {\n    DBUG_ASSERT(table->file != NULL);\n    MYSQL_REBIND_TABLE(table->file);\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n    part_names_error= set_partitions_as_used(table_list, table);\n#endif\n  }\n  else\n  {\n    enum open_frm_error error;\n\n    /* make a new table */\n    if (!(table=(TABLE*) my_malloc(sizeof(*table),MYF(MY_WME))))\n      goto err_lock;\n\n    error= open_table_from_share(thd, share, &table_list->alias,\n                                 HA_OPEN_KEYFILE | HA_TRY_READ_ONLY,\n                                 EXTRA_RECORD,\n                                 thd->open_options, table, FALSE,\n                                 IF_PARTITIONING(table_list->partition_names,0));\n\n    if (unlikely(error))\n    {\n      my_free(table);\n\n      if (error == OPEN_FRM_DISCOVER)\n        (void) ot_ctx->request_backoff_action(Open_table_context::OT_DISCOVER,\n                                              table_list);\n      else if (share->crashed)\n      {\n        if (!(flags & MYSQL_OPEN_IGNORE_REPAIR))\n          (void) ot_ctx->request_backoff_action(Open_table_context::OT_REPAIR,\n                                                table_list);\n        else\n          table_list->crashed= 1;  /* Mark that table was crashed */\n      }\n      goto err_lock;\n    }\n    if (open_table_entry_fini(thd, share, table))\n    {\n      closefrm(table);\n      my_free(table);\n      goto err_lock;\n    }\n\n    /* Add table to the share's used tables list. */\n    tc_add_table(thd, table);\n    from_share= true;\n  }\n\n  table->mdl_ticket= mdl_ticket;\n  table->reginfo.lock_type=TL_READ;\t\t/* Assume read */\n\n  table->init(thd, table_list);\n\n  table->next= thd->open_tables;\t\t/* Link into simple list */\n  thd->set_open_tables(table);\n\n reset:\n  /*\n    Check that there is no reference to a condition from an earlier query\n    (cf. Bug#58553). \n  */\n  DBUG_ASSERT(table->file->pushed_cond == NULL);\n  table_list->updatable= 1; // It is not derived table nor non-updatable VIEW\n  table_list->table= table;\n\n  if (!from_share && table->vcol_fix_expr(thd))\n    DBUG_RETURN(true);\n\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  if (unlikely(table->part_info))\n  {\n    /* Partitions specified were incorrect.*/\n    if (part_names_error)\n    {\n      table->file->print_error(part_names_error, MYF(0));\n      DBUG_RETURN(true);\n    }\n  }\n  else if (table_list->partition_names)\n  {\n    /* Don't allow PARTITION () clause on a nonpartitioned table */\n    my_error(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));\n    DBUG_RETURN(true);\n  }\n#endif\n  if (table_list->sequence && table->s->table_type != TABLE_TYPE_SEQUENCE)\n  {\n    my_error(ER_NOT_SEQUENCE, MYF(0), table_list->db.str, table_list->alias.str);\n    DBUG_RETURN(true);\n  }\n\n  DBUG_RETURN(FALSE);\n\nerr_lock:\n  tdc_release_share(share);\n\n  DBUG_PRINT(\"exit\", (\"failed\"));\n  DBUG_RETURN(TRUE);\n}",
        "label": 0
    },
    {
        "pre_patch": "Status ImmutableExecutorState::Initialize(const Graph& graph) {\n  TF_RETURN_IF_ERROR(gview_.Initialize(&graph));\n\n  // Build the information about frames in this subgraph.\n  ControlFlowInfo cf_info;\n  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));\n\n  for (auto& it : cf_info.unique_frame_names) {\n    EnsureFrameInfo(it)->nodes =\n        absl::make_unique<std::vector<const NodeItem*>>();\n  }\n  root_frame_info_ = frame_info_[\"\"].get();\n\n  pending_ids_.resize(gview_.num_nodes());\n\n  // Preprocess every node in the graph to create an instance of op\n  // kernel for each node.\n  requires_control_flow_ = false;\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {\n      requires_control_flow_ = true;\n    } else if (IsRecv(n)) {\n      // A Recv node from a different device may produce dead tensors from\n      // non-local control-flow nodes.\n      //\n      // TODO(mrry): Track whether control flow was present in the\n      // pre-partitioned graph, and enable the caller (e.g.\n      // `DirectSession`) to relax this constraint.\n      string send_device;\n      string recv_device;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));\n      if (send_device != recv_device) {\n        requires_control_flow_ = true;\n      }\n    }\n\n    const int id = n->id();\n    const string& frame_name = cf_info.frame_names[id];\n    FrameInfo* frame_info = EnsureFrameInfo(frame_name);\n\n    NodeItem* item = gview_.node(id);\n    item->node_id = id;\n\n    item->input_start = frame_info->total_inputs;\n    frame_info->total_inputs += n->num_inputs();\n\n    Status s = params_.create_kernel(n->properties(), &item->kernel);\n    if (!s.ok()) {\n      item->kernel = nullptr;\n      s = AttachDef(s, *n);\n      return s;\n    }\n    CHECK(item->kernel);\n    item->kernel_is_async = (item->kernel->AsAsync() != nullptr);\n    item->is_merge = IsMerge(n);\n    item->is_any_consumer_merge_or_control_trigger = false;\n    for (const Node* consumer : n->out_nodes()) {\n      if (IsMerge(consumer) || IsControlTrigger(consumer)) {\n        item->is_any_consumer_merge_or_control_trigger = true;\n        break;\n      }\n    }\n    const Tensor* const_tensor = item->kernel->const_tensor();\n    if (const_tensor) {\n      // Hold onto a shallow copy of the constant tensor in `*this` so that the\n      // reference count does not drop to 1. This prevents the constant tensor\n      // from being forwarded, and its buffer reused.\n      const_tensors_.emplace_back(*const_tensor);\n    }\n    item->const_tensor = const_tensor;\n    item->is_noop = (item->kernel->type_string_view() == \"NoOp\");\n    item->is_enter = IsEnter(n);\n    if (item->is_enter) {\n      bool is_constant_enter;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));\n      item->is_constant_enter = is_constant_enter;\n\n      string frame_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));\n      FrameInfo* frame_info = frame_info_[frame_name].get();\n\n      int parallel_iterations;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));\n\n      if (frame_info->parallel_iterations == -1) {\n        frame_info->parallel_iterations = parallel_iterations;\n      } else if (frame_info->parallel_iterations != parallel_iterations) {\n        LOG(WARNING) << \"Loop frame \\\"\" << frame_name\n                     << \"\\\" had two different values for parallel_iterations: \"\n                     << frame_info->parallel_iterations << \" vs. \"\n                     << parallel_iterations << \".\";\n      }\n\n      if (enter_frame_info_.size() <= id) {\n        enter_frame_info_.resize(id + 1);\n      }\n      enter_frame_info_[id] = frame_info;\n    } else {\n      item->is_constant_enter = false;\n    }\n    item->is_exit = IsExit(n);\n    item->is_control_trigger = IsControlTrigger(n);\n    item->is_source = IsSource(n);\n    item->is_enter_exit_or_next_iter =\n        (IsEnter(n) || IsExit(n) || IsNextIteration(n));\n    item->is_transfer_node = IsTransferNode(n);\n    item->is_initialization_op = IsInitializationOp(n);\n    item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);\n    item->is_next_iteration = IsNextIteration(n);\n    item->is_distributed_communication = IsDistributedCommunication(n);\n\n    // Compute the maximum values we'll store for this node in the\n    // pending counts data structure, and allocate a handle in\n    // that frame's pending counts data structure that has enough\n    // space to store these maximal count values.\n    size_t max_pending, max_dead;\n    GetMaxPendingCounts(n, &max_pending, &max_dead);\n    pending_ids_[id] =\n        frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);\n\n    // See if this node is a root node, and if so, add item to root_nodes_.\n    if (n->in_edges().empty()) {\n      root_nodes_.push_back(item);\n    }\n\n    // Initialize static information about the frames in the graph.\n    frame_info->nodes->push_back(item);\n    if (item->is_enter) {\n      string enter_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));\n      EnsureFrameInfo(enter_name)->input_count++;\n    }\n\n    // Record information about whether each output of the op is used.\n    std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);\n    std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);\n    int32_t unused_outputs = n->num_outputs();\n    for (const Edge* e : n->out_edges()) {\n      if (IsSink(e->dst())) continue;\n      if (e->src_output() >= 0) {\n        if (!outputs_required[e->src_output()]) {\n          --unused_outputs;\n          outputs_required[e->src_output()] = true;\n        }\n      }\n    }\n    if (unused_outputs > 0) {\n      for (int i = 0; i < n->num_outputs(); ++i) {\n        if (!outputs_required[i]) {\n          metrics::RecordUnusedOutput(n->type_string());\n        }\n      }\n      item->outputs_required = std::move(outputs_required);\n    }\n  }\n\n  // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input\n  // location.\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    const int id = n->id();\n    NodeItem* item = gview_.node(id);\n\n    for (EdgeInfo& e : item->mutable_output_edges()) {\n      const int dst_id = e.dst_id;\n      NodeItem* dst_item = gview_.node(dst_id);\n      e.input_slot += dst_item->input_start;\n    }\n  }\n\n  // Initialize PendingCounts only after pending_ids_[node.id] is initialized\n  // for all nodes.\n  InitializePending(&graph, cf_info);\n  return gview_.SetAllocAttrs(&graph, params_.device);\n}",
        "post_patch": "Status ImmutableExecutorState::Initialize(const Graph& graph) {\n  TF_RETURN_IF_ERROR(gview_.Initialize(&graph));\n\n  // Build the information about frames in this subgraph.\n  ControlFlowInfo cf_info;\n  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));\n\n  for (auto& it : cf_info.unique_frame_names) {\n    EnsureFrameInfo(it)->nodes =\n        absl::make_unique<std::vector<const NodeItem*>>();\n  }\n  root_frame_info_ = frame_info_[\"\"].get();\n\n  pending_ids_.resize(gview_.num_nodes());\n\n  // Preprocess every node in the graph to create an instance of op\n  // kernel for each node.\n  requires_control_flow_ = false;\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {\n      requires_control_flow_ = true;\n    } else if (IsRecv(n)) {\n      // A Recv node from a different device may produce dead tensors from\n      // non-local control-flow nodes.\n      //\n      // TODO(mrry): Track whether control flow was present in the\n      // pre-partitioned graph, and enable the caller (e.g.\n      // `DirectSession`) to relax this constraint.\n      string send_device;\n      string recv_device;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));\n      if (send_device != recv_device) {\n        requires_control_flow_ = true;\n      }\n    }\n\n    const int id = n->id();\n    const string& frame_name = cf_info.frame_names[id];\n    FrameInfo* frame_info = EnsureFrameInfo(frame_name);\n\n    NodeItem* item = gview_.node(id);\n    item->node_id = id;\n\n    item->input_start = frame_info->total_inputs;\n    frame_info->total_inputs += n->num_inputs();\n\n    Status s = params_.create_kernel(n->properties(), &item->kernel);\n    if (!s.ok()) {\n      params_.delete_kernel(item->kernel);\n      item->kernel = nullptr;\n      s = AttachDef(s, *n);\n      return s;\n    }\n    CHECK(item->kernel);\n    item->kernel_is_async = (item->kernel->AsAsync() != nullptr);\n    item->is_merge = IsMerge(n);\n    item->is_any_consumer_merge_or_control_trigger = false;\n    for (const Node* consumer : n->out_nodes()) {\n      if (IsMerge(consumer) || IsControlTrigger(consumer)) {\n        item->is_any_consumer_merge_or_control_trigger = true;\n        break;\n      }\n    }\n    const Tensor* const_tensor = item->kernel->const_tensor();\n    if (const_tensor) {\n      // Hold onto a shallow copy of the constant tensor in `*this` so that the\n      // reference count does not drop to 1. This prevents the constant tensor\n      // from being forwarded, and its buffer reused.\n      const_tensors_.emplace_back(*const_tensor);\n    }\n    item->const_tensor = const_tensor;\n    item->is_noop = (item->kernel->type_string_view() == \"NoOp\");\n    item->is_enter = IsEnter(n);\n    if (item->is_enter) {\n      bool is_constant_enter;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));\n      item->is_constant_enter = is_constant_enter;\n\n      string frame_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));\n      FrameInfo* frame_info = frame_info_[frame_name].get();\n\n      int parallel_iterations;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));\n\n      if (frame_info->parallel_iterations == -1) {\n        frame_info->parallel_iterations = parallel_iterations;\n      } else if (frame_info->parallel_iterations != parallel_iterations) {\n        LOG(WARNING) << \"Loop frame \\\"\" << frame_name\n                     << \"\\\" had two different values for parallel_iterations: \"\n                     << frame_info->parallel_iterations << \" vs. \"\n                     << parallel_iterations << \".\";\n      }\n\n      if (enter_frame_info_.size() <= id) {\n        enter_frame_info_.resize(id + 1);\n      }\n      enter_frame_info_[id] = frame_info;\n    } else {\n      item->is_constant_enter = false;\n    }\n    item->is_exit = IsExit(n);\n    item->is_control_trigger = IsControlTrigger(n);\n    item->is_source = IsSource(n);\n    item->is_enter_exit_or_next_iter =\n        (IsEnter(n) || IsExit(n) || IsNextIteration(n));\n    item->is_transfer_node = IsTransferNode(n);\n    item->is_initialization_op = IsInitializationOp(n);\n    item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);\n    item->is_next_iteration = IsNextIteration(n);\n    item->is_distributed_communication = IsDistributedCommunication(n);\n\n    // Compute the maximum values we'll store for this node in the\n    // pending counts data structure, and allocate a handle in\n    // that frame's pending counts data structure that has enough\n    // space to store these maximal count values.\n    size_t max_pending, max_dead;\n    GetMaxPendingCounts(n, &max_pending, &max_dead);\n    pending_ids_[id] =\n        frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);\n\n    // See if this node is a root node, and if so, add item to root_nodes_.\n    if (n->in_edges().empty()) {\n      root_nodes_.push_back(item);\n    }\n\n    // Initialize static information about the frames in the graph.\n    frame_info->nodes->push_back(item);\n    if (item->is_enter) {\n      string enter_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));\n      EnsureFrameInfo(enter_name)->input_count++;\n    }\n\n    // Record information about whether each output of the op is used.\n    std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);\n    std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);\n    int32_t unused_outputs = n->num_outputs();\n    for (const Edge* e : n->out_edges()) {\n      if (IsSink(e->dst())) continue;\n      if (e->src_output() >= 0) {\n        if (!outputs_required[e->src_output()]) {\n          --unused_outputs;\n          outputs_required[e->src_output()] = true;\n        }\n      }\n    }\n    if (unused_outputs > 0) {\n      for (int i = 0; i < n->num_outputs(); ++i) {\n        if (!outputs_required[i]) {\n          metrics::RecordUnusedOutput(n->type_string());\n        }\n      }\n      item->outputs_required = std::move(outputs_required);\n    }\n  }\n\n  // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input\n  // location.\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    const int id = n->id();\n    NodeItem* item = gview_.node(id);\n\n    for (EdgeInfo& e : item->mutable_output_edges()) {\n      const int dst_id = e.dst_id;\n      NodeItem* dst_item = gview_.node(dst_id);\n      e.input_slot += dst_item->input_start;\n    }\n  }\n\n  // Initialize PendingCounts only after pending_ids_[node.id] is initialized\n  // for all nodes.\n  InitializePending(&graph, cf_info);\n  return gview_.SetAllocAttrs(&graph, params_.device);\n}",
        "label": 1
    },
    {
        "pre_patch": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(!file || file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}",
        "post_patch": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(!file || file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}",
        "label": 0
    },
    {
        "pre_patch": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\t/*\n\t This subquery was excluded as part of some expression so it is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip non-constant subqueries if the caller asked so. */\n        continue;\n      }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      /*\n        If the subquery is a UNION, optimize all the subqueries in the UNION. If\n        there is no UNION, then the loop will execute once for the subquery.\n      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; /* Failure */\n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        /* We need only 1 row to determine existence */\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n\n        if (empty_union_result)\n        {\n          /*\n            If at least one subquery in a union is non-empty, the UNION result\n            is non-empty. If there is no UNION, the only subquery is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n      {\n        /*\n          Some parts of UNION are not correlated. This means we will need to\n          re-execute the whole UNION every time. Mark all parts of the UNION\n          as correlated so that they are prepared to be executed multiple\n          times (if we don't do that, some part of the UNION may free its\n          execution data at the end of first execution and crash on the second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "post_patch": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\t/*\n\t This subquery was excluded as part of some expression so it is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip non-constant subqueries if the caller asked so. */\n        continue;\n      }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      /*\n        If the subquery is a UNION, optimize all the subqueries in the UNION. If\n        there is no UNION, then the loop will execute once for the subquery.\n      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; /* Failure */\n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        /* We need only 1 row to determine existence */\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n\n        if (empty_union_result)\n        {\n          /*\n            If at least one subquery in a union is non-empty, the UNION result\n            is non-empty. If there is no UNION, the only subquery is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n      {\n        /*\n          Some parts of UNION are not correlated. This means we will need to\n          re-execute the whole UNION every time. Mark all parts of the UNION\n          as correlated so that they are prepared to be executed multiple\n          times (if we don't do that, some part of the UNION may free its\n          execution data at the end of first execution and crash on the second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "label": 0
    },
    {
        "pre_patch": "void end_read_record(READ_RECORD *info)\n{\n  /* free cache if used */\n  free_cache(info);\n  if (info->table)\n  {\n    if (info->table->db_stat) // if opened\n      (void) info->table->file->extra(HA_EXTRA_NO_CACHE);\n    if (info->read_record != rr_quick) // otherwise quick_range does it\n      (void) info->table->file->ha_index_or_rnd_end();\n    info->table=0;\n  }\n}",
        "post_patch": "void end_read_record(READ_RECORD *info)\n{\n  /* free cache if used */\n  free_cache(info);\n  if (info->table)\n  {\n    if (info->table->db_stat) // if opened\n      (void) info->table->file->extra(HA_EXTRA_NO_CACHE);\n    if (info->read_record != rr_quick) // otherwise quick_range does it\n      (void) info->table->file->ha_index_or_rnd_end();\n    info->table=0;\n  }\n}",
        "label": 0
    },
    {
        "pre_patch": "int maria_create(const char *name, enum data_file_type datafile_type,\n                 uint keys,MARIA_KEYDEF *keydefs,\n                 uint columns, MARIA_COLUMNDEF *columndef,\n                 uint uniques, MARIA_UNIQUEDEF *uniquedefs,\n                 MARIA_CREATE_INFO *ci,uint flags)\n{\n  register uint i,j;\n  File UNINIT_VAR(dfile), UNINIT_VAR(file);\n  int errpos,save_errno, create_mode= O_RDWR | O_TRUNC, res;\n  myf create_flag;\n  uint length,max_key_length,packed,pack_bytes,pointer,real_length_diff,\n       key_length,info_length,key_segs,options,min_key_length,\n       base_pos,long_varchar_count,\n       unique_key_parts,fulltext_keys,offset, not_block_record_extra_length;\n  uint max_field_lengths, extra_header_size, column_nr;\n  uint internal_table= flags & HA_CREATE_INTERNAL_TABLE;\n  ulong reclength, real_reclength,min_pack_length;\n  char kfilename[FN_REFLEN], klinkname[FN_REFLEN], *klinkname_ptr= NullS;\n  char dfilename[FN_REFLEN], dlinkname[FN_REFLEN], *dlinkname_ptr= 0;\n  ulong pack_reclength;\n  ulonglong tot_length,max_rows, tmp;\n  enum en_fieldtype type;\n  enum data_file_type org_datafile_type= datafile_type;\n  MARIA_SHARE share;\n  MARIA_KEYDEF *keydef,tmp_keydef;\n  MARIA_UNIQUEDEF *uniquedef;\n  HA_KEYSEG *keyseg,tmp_keyseg;\n  MARIA_COLUMNDEF *column, *end_column;\n  double *rec_per_key_part;\n  ulong  *nulls_per_key_part;\n  uint16 *column_array;\n  my_off_t key_root[HA_MAX_POSSIBLE_KEY], kfile_size_before_extension;\n  MARIA_CREATE_INFO tmp_create_info;\n  my_bool tmp_table= FALSE; /* cache for presence of HA_OPTION_TMP_TABLE */\n  my_bool forced_packed;\n  myf     sync_dir=  0;\n  uchar   *log_data= NULL;\n  my_bool encrypted= maria_encrypt_tables && datafile_type == BLOCK_RECORD;\n  my_bool insert_order= MY_TEST(flags & HA_PRESERVE_INSERT_ORDER);\n  uint crypt_page_header_space= 0;\n  DBUG_ENTER(\"maria_create\");\n  DBUG_PRINT(\"enter\", (\"keys: %u  columns: %u  uniques: %u  flags: %u\",\n                      keys, columns, uniques, flags));\n\n  DBUG_ASSERT(maria_inited);\n\n  if (!ci)\n  {\n    bzero((char*) &tmp_create_info,sizeof(tmp_create_info));\n    ci=&tmp_create_info;\n  }\n\n  if (keys + uniques > MARIA_MAX_KEY)\n  {\n    DBUG_RETURN(my_errno=HA_WRONG_CREATE_OPTION);\n  }\n  errpos=0;\n  options=0;\n  bzero((uchar*) &share,sizeof(share));\n\n  if (flags & HA_DONT_TOUCH_DATA)\n  {\n    /* We come here from recreate table */\n    org_datafile_type= ci->org_data_file_type;\n    if (!(ci->old_options & HA_OPTION_TEMP_COMPRESS_RECORD))\n      options= (ci->old_options &\n                (HA_OPTION_COMPRESS_RECORD | HA_OPTION_PACK_RECORD |\n                 HA_OPTION_READ_ONLY_DATA | HA_OPTION_CHECKSUM |\n                 HA_OPTION_TMP_TABLE | HA_OPTION_DELAY_KEY_WRITE |\n                 HA_OPTION_LONG_BLOB_PTR | HA_OPTION_PAGE_CHECKSUM));\n    else\n    {\n      /* Uncompressing rows */\n      options= (ci->old_options &\n                (HA_OPTION_CHECKSUM | HA_OPTION_TMP_TABLE |\n                 HA_OPTION_DELAY_KEY_WRITE | HA_OPTION_LONG_BLOB_PTR |\n                 HA_OPTION_PAGE_CHECKSUM));\n    }\n  }\n  else\n  {\n    /* Transactional tables must be of type BLOCK_RECORD */\n    if (ci->transactional)\n      datafile_type= BLOCK_RECORD;\n  }\n\n  if (!(rec_per_key_part=\n\t(double*) my_malloc((keys + uniques)*HA_MAX_KEY_SEG*sizeof(double) +\n                            (keys + uniques)*HA_MAX_KEY_SEG*sizeof(ulong) +\n                            sizeof(uint16) * columns,\n                            MYF(MY_WME | MY_ZEROFILL))))\n    DBUG_RETURN(my_errno);\n  nulls_per_key_part= (ulong*) (rec_per_key_part +\n                                (keys + uniques) * HA_MAX_KEY_SEG);\n  column_array= (uint16*) (nulls_per_key_part +\n                           (keys + uniques) * HA_MAX_KEY_SEG);\n\n\n  /* Start by checking fields and field-types used */\n  long_varchar_count=packed= not_block_record_extra_length=\n    pack_reclength= max_field_lengths= 0;\n  reclength= min_pack_length= ci->null_bytes;\n  forced_packed= 0;\n  column_nr= 0;\n\n  if (encrypted)\n  {\n    DBUG_ASSERT(datafile_type == BLOCK_RECORD);\n    crypt_page_header_space= ma_crypt_get_data_page_header_space();\n  }\n\n  for (column= columndef, end_column= column + columns ;\n       column != end_column ;\n       column++)\n  {\n    /* Fill in not used struct parts */\n    column->column_nr= column_nr++;\n    column->offset= reclength;\n    column->empty_pos= 0;\n    column->empty_bit= 0;\n    column->fill_length= column->length;\n    if (column->null_bit)\n      options|= HA_OPTION_NULL_FIELDS;\n\n    reclength+= column->length;\n    type= column->type;\n    if (datafile_type == BLOCK_RECORD)\n    {\n      if (type == FIELD_SKIP_PRESPACE)\n        type= column->type= FIELD_NORMAL; /* SKIP_PRESPACE not supported */\n      if (type == FIELD_NORMAL &&\n          column->length > FULL_PAGE_SIZE2(maria_block_size,\n                                           crypt_page_header_space))\n      {\n        /* FIELD_NORMAL can't be split over many blocks, convert to a CHAR */\n        type= column->type= FIELD_SKIP_ENDSPACE;\n      }\n    }\n\n    if (type != FIELD_NORMAL && type != FIELD_CHECK)\n    {\n      column->empty_pos= packed/8;\n      column->empty_bit= (1 << (packed & 7));\n      if (type == FIELD_BLOB)\n      {\n        forced_packed= 1;\n        packed++;\n\tshare.base.blobs++;\n\tif (pack_reclength != INT_MAX32)\n\t{\n\t  if (column->length == 4+portable_sizeof_char_ptr)\n\t    pack_reclength= INT_MAX32;\n\t  else\n          {\n            /* Add max possible blob length */\n\t    pack_reclength+= (1 << ((column->length-\n                                     portable_sizeof_char_ptr)*8));\n          }\n\t}\n        max_field_lengths+= (column->length - portable_sizeof_char_ptr);\n      }\n      else if (type == FIELD_SKIP_PRESPACE ||\n\t       type == FIELD_SKIP_ENDSPACE)\n      {\n        forced_packed= 1;\n        max_field_lengths+= column->length > 255 ? 2 : 1;\n        not_block_record_extra_length++;\n        packed++;\n      }\n      else if (type == FIELD_VARCHAR)\n      {\n\tpack_reclength++;\n        not_block_record_extra_length++;\n        max_field_lengths++;\n        if (datafile_type != DYNAMIC_RECORD)\n          packed++;\n        column->fill_length= 1;\n        options|= HA_OPTION_NULL_FIELDS;        /* Use ma_checksum() */\n\n        /* We must test for 257 as length includes pack-length */\n        if (MY_TEST(column->length >= 257))\n\t{\n\t  long_varchar_count++;\n          max_field_lengths++;\n          column->fill_length= 2;\n\t}\n      }\n      else if (type == FIELD_SKIP_ZERO)\n        packed++;\n      else\n      {\n        if (!column->null_bit)\n          min_pack_length+= column->length;\n        else\n        {\n          /* Only BLOCK_RECORD skips NULL fields for all field values */\n          not_block_record_extra_length+= column->length;\n        }\n        column->empty_pos= 0;\n        column->empty_bit= 0;\n      }\n    }\n    else\t\t\t\t\t/* FIELD_NORMAL */\n    {\n      if (!column->null_bit)\n      {\n        min_pack_length+= column->length;\n        share.base.fixed_not_null_fields++;\n        share.base.fixed_not_null_fields_length+= column->length;\n      }\n      else\n        not_block_record_extra_length+= column->length;\n    }\n  }\n\n  if (datafile_type == STATIC_RECORD && forced_packed)\n  {\n    /* Can't use fixed length records, revert to block records */\n    datafile_type= BLOCK_RECORD;\n  }\n\n  if (datafile_type == NO_RECORD && uniques)\n  {\n    /* Can't do unique without data, revert to block records */\n    datafile_type= BLOCK_RECORD;\n  }\n\n  if (encrypted)\n  {\n    /*\n       datafile_type is set (finally?)\n       update encryption that is only supported for BLOCK_RECORD\n    */\n    if (datafile_type != BLOCK_RECORD)\n    {\n      encrypted= FALSE;\n      crypt_page_header_space= 0;\n    }\n  }\n\n  if (datafile_type == DYNAMIC_RECORD)\n    options|= HA_OPTION_PACK_RECORD;\t/* Must use packed records */\n\n  if (datafile_type == STATIC_RECORD || datafile_type == NO_RECORD)\n  {\n    /* We can't use checksum with static length rows */\n    flags&= ~HA_CREATE_CHECKSUM;\n    options&= ~HA_OPTION_CHECKSUM;\n    min_pack_length= reclength;\n    packed= 0;\n  }\n  else if (datafile_type != BLOCK_RECORD)\n    min_pack_length+= not_block_record_extra_length;\n  else\n    min_pack_length+= 5;                        /* Min row overhead */\n\n  if (flags & HA_CREATE_TMP_TABLE)\n  {\n    options|= HA_OPTION_TMP_TABLE;\n    tmp_table= TRUE;\n    create_mode|= O_NOFOLLOW | (internal_table ? 0 : O_EXCL);\n    /* \"CREATE TEMPORARY\" tables are not crash-safe (dropped at restart) */\n    ci->transactional= FALSE;\n    flags&= ~HA_CREATE_PAGE_CHECKSUM;\n  }\n  share.base.null_bytes= ci->null_bytes;\n  share.base.original_null_bytes= ci->null_bytes;\n  share.base.born_transactional= ci->transactional;\n  share.base.max_field_lengths= max_field_lengths;\n  share.base.field_offsets= 0;                  /* for future */\n\n  if (flags & HA_CREATE_CHECKSUM || (options & HA_OPTION_CHECKSUM))\n  {\n    options|= HA_OPTION_CHECKSUM;\n    min_pack_length++;\n    pack_reclength++;\n  }\n  if (pack_reclength < INT_MAX32)\n    pack_reclength+= max_field_lengths + long_varchar_count;\n  else\n    pack_reclength= INT_MAX32;\n\n  if (flags & HA_CREATE_DELAY_KEY_WRITE)\n    options|= HA_OPTION_DELAY_KEY_WRITE;\n  if (flags & HA_CREATE_RELIES_ON_SQL_LAYER)\n    options|= HA_OPTION_RELIES_ON_SQL_LAYER;\n  if (flags & HA_CREATE_PAGE_CHECKSUM)\n    options|= HA_OPTION_PAGE_CHECKSUM;\n\n  pack_bytes= (packed + 7) / 8;\n  if (pack_reclength != INT_MAX32)\n    pack_reclength+= reclength+pack_bytes +\n      MY_TEST(test_all_bits(options, HA_OPTION_CHECKSUM |\n                                     HA_OPTION_PACK_RECORD));\n  min_pack_length+= pack_bytes;\n  /* Calculate min possible row length for rows-in-block */\n  extra_header_size= MAX_FIXED_HEADER_SIZE;\n  if (ci->transactional)\n  {\n    extra_header_size= TRANS_MAX_FIXED_HEADER_SIZE;\n    DBUG_PRINT(\"info\",(\"creating a transactional table\"));\n  }\n  share.base.min_block_length= (extra_header_size + share.base.null_bytes +\n                                pack_bytes);\n  if (!ci->data_file_length && ci->max_rows)\n  {\n    set_if_bigger(ci->max_rows, ci->reloc_rows);\n    if (pack_reclength == INT_MAX32 ||\n             (~(ulonglong) 0)/ci->max_rows < (ulonglong) pack_reclength)\n      ci->data_file_length= ~(ulonglong) 0;\n    else\n    {\n      ci->data_file_length= _ma_safe_mul(ci->max_rows, pack_reclength);\n      if (datafile_type == BLOCK_RECORD)\n      {\n        /* Assume that blocks are only half full (very pessimistic!) */\n        ci->data_file_length= _ma_safe_mul(ci->data_file_length, 2);\n        set_if_bigger(ci->data_file_length, maria_block_size*2);\n      }\n    }\n  }\n  else if (!ci->max_rows)\n  {\n    if (datafile_type == BLOCK_RECORD)\n    {\n      uint rows_per_page=\n          ((maria_block_size - PAGE_OVERHEAD_SIZE_RAW - crypt_page_header_space)\n           / (min_pack_length + extra_header_size + DIR_ENTRY_SIZE));\n      ulonglong data_file_length= ci->data_file_length;\n      if (!data_file_length)\n        data_file_length= ((((ulonglong) 1 << ((BLOCK_RECORD_POINTER_SIZE-1) *\n                                               8))/2 -1) * maria_block_size);\n      if (rows_per_page > 0)\n      {\n        set_if_smaller(rows_per_page, MAX_ROWS_PER_PAGE);\n        ci->max_rows= (data_file_length / maria_block_size+1) * rows_per_page;\n      }\n      else\n        ci->max_rows= data_file_length / (min_pack_length +\n                                          extra_header_size +\n                                          DIR_ENTRY_SIZE);\n    }\n    else\n      ci->max_rows=(ha_rows) (ci->data_file_length/(min_pack_length +\n                                                    ((options &\n                                                      HA_OPTION_PACK_RECORD) ?\n                                                     3 : 0)));\n    set_if_smaller(ci->reloc_rows, ci->max_rows);\n  }\n  max_rows= (ulonglong) ci->max_rows;\n  if (datafile_type == BLOCK_RECORD)\n  {\n    /*\n      The + 1 is for record position withing page\n      The * 2 is because we need one bit for knowing if there is transid's\n      after the row pointer\n    */\n    pointer= maria_get_pointer_length((ci->data_file_length /\n                                       maria_block_size) * 2, 4) + 1;\n    set_if_smaller(pointer, BLOCK_RECORD_POINTER_SIZE);\n\n    if (!max_rows)\n      max_rows= (((((ulonglong) 1 << ((pointer-1)*8)) -1) * maria_block_size) /\n                 min_pack_length / 2);\n                                      }\n  else\n  {\n    if (datafile_type == NO_RECORD)\n      pointer= 0;\n    else if (datafile_type != STATIC_RECORD)\n      pointer= maria_get_pointer_length(ci->data_file_length,\n                                        maria_data_pointer_size);\n    else\n      pointer= maria_get_pointer_length(ci->max_rows, maria_data_pointer_size);\n    if (!max_rows)\n      max_rows= ((((ulonglong) 1 << (pointer*8)) -1) / min_pack_length);\n  }\n\n  real_reclength=reclength;\n  if (datafile_type == STATIC_RECORD)\n  {\n    if (reclength <= pointer)\n      reclength=pointer+1;\t\t/* reserve place for delete link */\n  }\n  else\n    reclength+= long_varchar_count;\t/* We need space for varchar! */\n\n  max_key_length=0; tot_length=0 ; key_segs=0;\n  fulltext_keys=0;\n  share.state.rec_per_key_part=   rec_per_key_part;\n  share.state.nulls_per_key_part= nulls_per_key_part;\n  share.state.key_root=key_root;\n  share.state.key_del= HA_OFFSET_ERROR;\n  if (uniques)\n    max_key_length= MARIA_UNIQUE_HASH_LENGTH + pointer;\n\n  for (i=0, keydef=keydefs ; i < keys ; i++ , keydef++)\n  {\n    share.state.key_root[i]= HA_OFFSET_ERROR;\n    length= real_length_diff= 0;\n    min_key_length= key_length= pointer;\n\n    if (keydef->key_alg == HA_KEY_ALG_RTREE)\n      keydef->flag|= HA_RTREE_INDEX;            /* For easier tests */\n\n    if (keydef->flag & HA_SPATIAL)\n    {\n#ifdef HAVE_SPATIAL\n      /* BAR TODO to support 3D and more dimensions in the future */\n      uint sp_segs=SPDIMS*2;\n      keydef->flag=HA_SPATIAL;\n\n      if (flags & HA_DONT_TOUCH_DATA)\n      {\n        /*\n          Called by maria_chk - i.e. table structure was taken from\n          MYI file and SPATIAL key *does have* additional sp_segs keysegs.\n          keydef->seg here points right at the GEOMETRY segment,\n          so we only need to decrease keydef->keysegs.\n          (see maria_recreate_table() in _ma_check.c)\n        */\n        keydef->keysegs-=sp_segs-1;\n      }\n\n      for (j=0, keyseg=keydef->seg ; (int) j < keydef->keysegs ;\n\t   j++, keyseg++)\n      {\n        if (keyseg->type != HA_KEYTYPE_BINARY &&\n\t    keyseg->type != HA_KEYTYPE_VARBINARY1 &&\n            keyseg->type != HA_KEYTYPE_VARBINARY2)\n        {\n          my_errno=HA_WRONG_CREATE_OPTION;\n          goto err_no_lock;\n        }\n      }\n      keydef->keysegs+=sp_segs;\n      key_length+=SPLEN*sp_segs;\n      length++;                              /* At least one length uchar */\n      min_key_length++;\n#else\n      my_errno= HA_ERR_UNSUPPORTED;\n      goto err_no_lock;\n#endif /*HAVE_SPATIAL*/\n    }\n    else if (keydef->flag & HA_FULLTEXT)\n    {\n      keydef->flag=HA_FULLTEXT | HA_PACK_KEY | HA_VAR_LENGTH_KEY;\n      options|=HA_OPTION_PACK_KEYS;             /* Using packed keys */\n\n      for (j=0, keyseg=keydef->seg ; (int) j < keydef->keysegs ;\n\t   j++, keyseg++)\n      {\n        if (keyseg->type != HA_KEYTYPE_TEXT &&\n\t    keyseg->type != HA_KEYTYPE_VARTEXT1 &&\n            keyseg->type != HA_KEYTYPE_VARTEXT2)\n        {\n          my_errno=HA_WRONG_CREATE_OPTION;\n          goto err_no_lock;\n        }\n        if (!(keyseg->flag & HA_BLOB_PART) &&\n\t    (keyseg->type == HA_KEYTYPE_VARTEXT1 ||\n             keyseg->type == HA_KEYTYPE_VARTEXT2))\n        {\n          /* Make a flag that this is a VARCHAR */\n          keyseg->flag|= HA_VAR_LENGTH_PART;\n          /* Store in bit_start number of bytes used to pack the length */\n          keyseg->bit_start= ((keyseg->type == HA_KEYTYPE_VARTEXT1)?\n                              1 : 2);\n        }\n      }\n\n      fulltext_keys++;\n      key_length+= HA_FT_MAXBYTELEN+HA_FT_WLEN;\n      length++;                              /* At least one length uchar */\n      min_key_length+= 1 + HA_FT_WLEN;\n      real_length_diff=HA_FT_MAXBYTELEN-FT_MAX_WORD_LEN_FOR_SORT;\n    }\n    else\n    {\n      /* Test if prefix compression */\n      if (keydef->flag & HA_PACK_KEY)\n      {\n\t/* Can't use space_compression on number keys */\n\tif ((keydef->seg[0].flag & HA_SPACE_PACK) &&\n\t    keydef->seg[0].type == (int) HA_KEYTYPE_NUM)\n\t  keydef->seg[0].flag&= ~HA_SPACE_PACK;\n\n\t/* Only use HA_PACK_KEY when first segment is a variable length key */\n\tif (!(keydef->seg[0].flag & (HA_SPACE_PACK | HA_BLOB_PART |\n\t\t\t\t     HA_VAR_LENGTH_PART)))\n\t{\n\t  /* pack relative to previous key */\n\t  keydef->flag&= ~HA_PACK_KEY;\n\t  keydef->flag|= HA_BINARY_PACK_KEY | HA_VAR_LENGTH_KEY;\n\t}\n\telse\n\t{\n\t  keydef->seg[0].flag|=HA_PACK_KEY;\t/* for easyer intern test */\n\t  keydef->flag|=HA_VAR_LENGTH_KEY;\n\t  options|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n\t}\n      }\n      if (keydef->flag & HA_BINARY_PACK_KEY)\n\toptions|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n\n      if (keydef->flag & HA_AUTO_KEY && ci->with_auto_increment)\n\tshare.base.auto_key=i+1;\n      for (j=0, keyseg=keydef->seg ; j < keydef->keysegs ; j++, keyseg++)\n      {\n\t/* numbers are stored with high by first to make compression easier */\n\tswitch (keyseg->type) {\n\tcase HA_KEYTYPE_SHORT_INT:\n\tcase HA_KEYTYPE_LONG_INT:\n\tcase HA_KEYTYPE_FLOAT:\n\tcase HA_KEYTYPE_DOUBLE:\n\tcase HA_KEYTYPE_USHORT_INT:\n\tcase HA_KEYTYPE_ULONG_INT:\n\tcase HA_KEYTYPE_LONGLONG:\n\tcase HA_KEYTYPE_ULONGLONG:\n\tcase HA_KEYTYPE_INT24:\n\tcase HA_KEYTYPE_UINT24:\n\tcase HA_KEYTYPE_INT8:\n\t  keyseg->flag|= HA_SWAP_KEY;\n          break;\n        case HA_KEYTYPE_VARTEXT1:\n        case HA_KEYTYPE_VARTEXT2:\n        case HA_KEYTYPE_VARBINARY1:\n        case HA_KEYTYPE_VARBINARY2:\n          if (!(keyseg->flag & HA_BLOB_PART))\n          {\n            /* Make a flag that this is a VARCHAR */\n            keyseg->flag|= HA_VAR_LENGTH_PART;\n            /* Store in bit_start number of bytes used to pack the length */\n            keyseg->bit_start= ((keyseg->type == HA_KEYTYPE_VARTEXT1 ||\n                                 keyseg->type == HA_KEYTYPE_VARBINARY1) ?\n                                1 : 2);\n          }\n          break;\n\tdefault:\n\t  break;\n\t}\n\tif (keyseg->flag & HA_SPACE_PACK)\n\t{\n          DBUG_ASSERT(!(keyseg->flag & (HA_VAR_LENGTH_PART | HA_BLOB_PART)));\n\t  keydef->flag |= HA_SPACE_PACK_USED | HA_VAR_LENGTH_KEY;\n\t  options|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n\t  length++;\t\t\t\t/* At least one length uchar */\n          if (!keyseg->null_bit)\n            min_key_length++;\n          key_length+= keyseg->length;\n\t  if (keyseg->length >= 255)\n\t  {\n            /* prefix may be 3 bytes */\n\t    length+= 2;\n\t  }\n\t}\n\telse if (keyseg->flag & (HA_VAR_LENGTH_PART | HA_BLOB_PART))\n\t{\n          DBUG_ASSERT(!test_all_bits(keyseg->flag,\n                                    (HA_VAR_LENGTH_PART | HA_BLOB_PART)));\n\t  keydef->flag|=HA_VAR_LENGTH_KEY;\n\t  length++;\t\t\t\t/* At least one length uchar */\n          if (!keyseg->null_bit)\n            min_key_length++;\n\t  options|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n          key_length+= keyseg->length;\n\t  if (keyseg->length >= 255)\n\t  {\n            /* prefix may be 3 bytes */\n\t    length+= 2;\n\t  }\n\t}\n        else\n        {\n          key_length+= keyseg->length;\n          if (!keyseg->null_bit)\n            min_key_length+= keyseg->length;\n        }\n\tif (keyseg->null_bit)\n\t{\n\t  key_length++;\n          /* min key part is 1 byte */\n          min_key_length++;\n\t  options|=HA_OPTION_PACK_KEYS;\n\t  keyseg->flag|=HA_NULL_PART;\n\t  keydef->flag|=HA_VAR_LENGTH_KEY | HA_NULL_PART_KEY;\n\t}\n      }\n    } /* if HA_FULLTEXT */\n    key_segs+=keydef->keysegs;\n    if (keydef->keysegs > HA_MAX_KEY_SEG)\n    {\n      my_errno=HA_WRONG_CREATE_OPTION;\n      goto err_no_lock;\n    }\n    /*\n      key_segs may be 0 in the case when we only want to be able to\n      add on row into the table. This can happen with some DISTINCT queries\n      in MySQL\n    */\n    if ((keydef->flag & (HA_NOSAME | HA_NULL_PART_KEY)) == HA_NOSAME &&\n\tkey_segs)\n      share.state.rec_per_key_part[key_segs-1]=1L;\n    length+=key_length;\n    /*\n      A key can't be longer than than half a index block (as we have\n      to be able to put at least 2 keys on an index block for the key\n      algorithms to work).\n    */\n    if (length > _ma_max_key_length())\n    {\n      my_errno=HA_WRONG_CREATE_OPTION;\n      goto err_no_lock;\n    }\n    keydef->block_length= (uint16) maria_block_size;\n    keydef->keylength= (uint16) key_length;\n    keydef->minlength= (uint16) min_key_length;\n    keydef->maxlength= (uint16) length;\n\n    if (length > max_key_length)\n      max_key_length= length;\n\n    tot_length= update_tot_length(tot_length, max_rows, length);\n  }\n\n  unique_key_parts=0;\n  for (i=0, uniquedef=uniquedefs ; i < uniques ; i++ , uniquedef++)\n  {\n    uniquedef->key=keys+i;\n    unique_key_parts+=uniquedef->keysegs;\n    share.state.key_root[keys+i]= HA_OFFSET_ERROR;\n\n    tot_length= update_tot_length(tot_length, max_rows, MARIA_UNIQUE_HASH_LENGTH + pointer);\n  }\n  keys+=uniques;\t\t\t\t/* Each unique has 1 key */\n  key_segs+=uniques;\t\t\t\t/* Each unique has 1 key seg */\n\n  base_pos=(MARIA_STATE_INFO_SIZE + keys * MARIA_STATE_KEY_SIZE +\n\t    key_segs * MARIA_STATE_KEYSEG_SIZE);\n  info_length= base_pos+(uint) (MARIA_BASE_INFO_SIZE+\n                                keys * MARIA_KEYDEF_SIZE+\n                                uniques * MARIA_UNIQUEDEF_SIZE +\n                                (key_segs + unique_key_parts)*HA_KEYSEG_SIZE+\n                                columns*(MARIA_COLUMNDEF_SIZE + 2));\n\n  if (encrypted)\n  {\n    share.base.extra_options|= MA_EXTRA_OPTIONS_ENCRYPTED;\n\n    /* store crypt data in info */\n    info_length+= ma_crypt_get_file_length();\n  }\n\n  if (insert_order)\n  {\n    share.base.extra_options|= MA_EXTRA_OPTIONS_INSERT_ORDER;\n  }\n\n  share.state.state.key_file_length= MY_ALIGN(info_length, maria_block_size);\n  DBUG_PRINT(\"info\", (\"info_length: %u\", info_length));\n  /* There are only 16 bits for the total header length. */\n  if (share.state.state.key_file_length > 65535)\n  {\n    my_printf_error(HA_WRONG_CREATE_OPTION,\n                    \"Aria table '%s' has too many columns and/or \"\n                    \"indexes and/or unique constraints.\",\n                    MYF(0), name + dirname_length(name));\n    my_errno= HA_WRONG_CREATE_OPTION;\n    goto err_no_lock;\n  }\n\n  bmove(share.state.header.file_version, maria_file_magic, 4);\n  ci->old_options=options | (ci->old_options & HA_OPTION_TEMP_COMPRESS_RECORD ?\n                             HA_OPTION_COMPRESS_RECORD |\n                             HA_OPTION_TEMP_COMPRESS_RECORD: 0);\n  mi_int2store(share.state.header.options,ci->old_options);\n  mi_int2store(share.state.header.header_length,info_length);\n  mi_int2store(share.state.header.state_info_length,MARIA_STATE_INFO_SIZE);\n  mi_int2store(share.state.header.base_info_length,MARIA_BASE_INFO_SIZE);\n  mi_int2store(share.state.header.base_pos,base_pos);\n  share.state.header.data_file_type= share.data_file_type= datafile_type;\n  share.state.header.org_data_file_type= org_datafile_type;\n  share.state.header.not_used= 0;\n\n  share.state.dellink = HA_OFFSET_ERROR;\n  share.state.first_bitmap_with_space= 0;\n#ifdef MARIA_EXTERNAL_LOCKING\n  share.state.process=\t(ulong) getpid();\n#endif\n  share.state.version=\t(ulong) time((time_t*) 0);\n  share.state.sortkey=  (ushort) ~0;\n  share.state.auto_increment=ci->auto_increment;\n  share.options=options;\n  share.base.rec_reflength=pointer;\n  share.base.block_size= maria_block_size;\n  share.base.language= (ci->language ? ci->language :\n                        default_charset_info->number);\n\n  /*\n    Get estimate for index file length (this may be wrong for FT keys)\n    This is used for pointers to other key pages.\n  */\n  tmp= (tot_length / maria_block_size + keys * MARIA_INDEX_BLOCK_MARGIN);\n\n  /*\n    use maximum of key_file_length we calculated and key_file_length value we\n    got from MAI file header (see also mariapack.c:save_state)\n  */\n  share.base.key_reflength=\n    maria_get_pointer_length(MY_MAX(ci->key_file_length,tmp),3);\n  share.base.keys= share.state.header.keys= keys;\n  share.state.header.uniques= uniques;\n  share.state.header.fulltext_keys= fulltext_keys;\n  mi_int2store(share.state.header.key_parts,key_segs);\n  mi_int2store(share.state.header.unique_key_parts,unique_key_parts);\n\n  maria_set_all_keys_active(share.state.key_map, keys);\n\n  share.base.keystart = share.state.state.key_file_length;\n  share.base.max_key_block_length= maria_block_size;\n  share.base.max_key_length=ALIGN_SIZE(max_key_length+4);\n  share.base.records=ci->max_rows;\n  share.base.reloc=  ci->reloc_rows;\n  share.base.reclength=real_reclength;\n  share.base.pack_reclength= reclength + MY_TEST(options & HA_OPTION_CHECKSUM);\n  share.base.max_pack_length=pack_reclength;\n  share.base.min_pack_length=min_pack_length;\n  share.base.pack_bytes= pack_bytes;\n  share.base.fields= columns;\n  share.base.pack_fields= packed;\n\n  if (share.data_file_type == BLOCK_RECORD)\n  {\n    /*\n      we are going to create a first bitmap page, set data_file_length\n      to reflect this, before the state goes to disk\n    */\n    share.state.state.data_file_length= maria_block_size;\n    /* Add length of packed fields + length */\n    share.base.pack_reclength+= share.base.max_field_lengths+3;\n    share.base.max_pack_length= share.base.pack_reclength;\n\n    /* Adjust max_pack_length, to be used if we have short rows */\n    if (share.base.max_pack_length < maria_block_size)\n    {\n      share.base.max_pack_length+= FLAG_SIZE;\n      if (ci->transactional)\n        share.base.max_pack_length+= TRANSID_SIZE * 2;\n    }\n  }\n\n  /* max_data_file_length and max_key_file_length are recalculated on open */\n  if (tmp_table)\n    share.base.max_data_file_length= (my_off_t) ci->data_file_length;\n  else if (ci->transactional && translog_status == TRANSLOG_OK &&\n           !maria_in_recovery)\n  {\n    /*\n      we have checked translog_inited above, because maria_chk may call us\n      (via maria_recreate_table()) and it does not have a log.\n    */\n    sync_dir= MY_SYNC_DIR;\n    /*\n      If crash between _ma_state_info_write_sub() and\n      _ma_update_state__lsns_sub(), table should be ignored by Recovery (or\n      old REDOs would fail), so we cannot let LSNs be 0:\n    */\n    share.state.skip_redo_lsn= share.state.is_of_horizon=\n      share.state.create_rename_lsn= LSN_MAX;\n  }\n\n  if (datafile_type == DYNAMIC_RECORD)\n  {\n    share.base.min_block_length=\n      (share.base.pack_reclength+3 < MARIA_EXTEND_BLOCK_LENGTH &&\n       ! share.base.blobs) ?\n      MY_MAX(share.base.pack_reclength,MARIA_MIN_BLOCK_LENGTH) :\n      MARIA_EXTEND_BLOCK_LENGTH;\n  }\n  else if (datafile_type == STATIC_RECORD)\n    share.base.min_block_length= share.base.pack_reclength;\n\n  if (! (flags & HA_DONT_TOUCH_DATA))\n    share.state.create_time= time((time_t*) 0);\n\n  if (!internal_table)\n    mysql_mutex_lock(&THR_LOCK_maria);\n\n  /*\n    NOTE: For test_if_reopen() we need a real path name. Hence we need\n    MY_RETURN_REAL_PATH for every fn_format(filename, ...).\n  */\n  if (ci->index_file_name)\n  {\n    char *iext= strrchr(ci->index_file_name, '.');\n    int have_iext= iext && !strcmp(iext, MARIA_NAME_IEXT);\n    if (tmp_table)\n    {\n      char *path;\n      /* chop off the table name, tempory tables use generated name */\n      if ((path= strrchr(ci->index_file_name, FN_LIBCHAR)))\n        *path= '\\0';\n      fn_format(kfilename, name, ci->index_file_name, MARIA_NAME_IEXT,\n                MY_REPLACE_DIR | MY_UNPACK_FILENAME |\n                MY_RETURN_REAL_PATH | MY_APPEND_EXT);\n    }\n    else\n    {\n      fn_format(kfilename, ci->index_file_name, \"\", MARIA_NAME_IEXT,\n                MY_UNPACK_FILENAME | MY_RETURN_REAL_PATH |\n                (have_iext ? MY_REPLACE_EXT : MY_APPEND_EXT));\n    }\n    fn_format(klinkname, name, \"\", MARIA_NAME_IEXT,\n              MY_UNPACK_FILENAME|MY_APPEND_EXT);\n    klinkname_ptr= klinkname;\n    /*\n      Don't create the table if the link or file exists to ensure that one\n      doesn't accidently destroy another table.\n      Don't sync dir now if the data file has the same path.\n    */\n    create_flag=\n      (ci->data_file_name &&\n       !strcmp(ci->index_file_name, ci->data_file_name)) ? 0 : sync_dir;\n  }\n  else\n  {\n    char *iext= strrchr(name, '.');\n    int have_iext= iext && !strcmp(iext, MARIA_NAME_IEXT);\n    fn_format(kfilename, name, \"\", MARIA_NAME_IEXT, MY_UNPACK_FILENAME |\n              (internal_table ? 0 : MY_RETURN_REAL_PATH) |\n              (have_iext ? MY_REPLACE_EXT : MY_APPEND_EXT));\n    /*\n      Replace the current file.\n      Don't sync dir now if the data file has the same path.\n    */\n    create_flag=  (flags & HA_CREATE_KEEP_FILES) ? 0 : MY_DELETE_OLD;\n    create_flag|= (!ci->data_file_name ? 0 : sync_dir);\n  }\n\n  /*\n    If a MRG_MARIA table is in use, the mapped MARIA tables are open,\n    but no entry is made in the table cache for them.\n    A TRUNCATE command checks for the table in the cache only and could\n    be fooled to believe, the table is not open.\n    Pull the emergency brake in this situation. (Bug #8306)\n\n\n    NOTE: The filename is compared against unique_file_name of every\n    open table. Hence we need a real path here.\n  */\n  if (!internal_table && _ma_test_if_reopen(kfilename))\n  {\n    my_printf_error(HA_ERR_TABLE_EXIST, \"Aria table '%s' is in use \"\n                    \"(most likely by a MERGE table). Try FLUSH TABLES.\",\n                    MYF(0), name + dirname_length(name));\n    my_errno= HA_ERR_TABLE_EXIST;\n    goto err;\n  }\n\n  if ((file= mysql_file_create_with_symlink(key_file_kfile, klinkname_ptr,\n                                            kfilename, 0, create_mode,\n                                            MYF(MY_WME|create_flag))) < 0)\n    goto err;\n  errpos=1;\n\n  DBUG_PRINT(\"info\", (\"write state info and base info\"));\n  if (_ma_state_info_write_sub(file, &share.state,\n                               MA_STATE_INFO_WRITE_FULL_INFO) ||\n      _ma_base_info_write(file, &share.base))\n    goto err;\n  DBUG_PRINT(\"info\", (\"base_pos: %d  base_info_size: %d\",\n                      base_pos, MARIA_BASE_INFO_SIZE));\n  DBUG_ASSERT(mysql_file_tell(file,MYF(0)) == base_pos+ MARIA_BASE_INFO_SIZE);\n\n  /* Write key and keyseg definitions */\n  DBUG_PRINT(\"info\", (\"write key and keyseg definitions\"));\n  for (i=0 ; i < share.base.keys - uniques; i++)\n  {\n    uint sp_segs=(keydefs[i].flag & HA_SPATIAL) ? 2*SPDIMS : 0;\n\n    if (_ma_keydef_write(file, &keydefs[i]))\n      goto err;\n    for (j=0 ; j < keydefs[i].keysegs-sp_segs ; j++)\n      if (_ma_keyseg_write(file, &keydefs[i].seg[j]))\n       goto err;\n#ifdef HAVE_SPATIAL\n    for (j=0 ; j < sp_segs ; j++)\n    {\n      HA_KEYSEG sseg;\n      sseg.type=SPTYPE;\n      sseg.language= 7;                         /* Binary */\n      sseg.null_bit=0;\n      sseg.bit_start=0;\n      sseg.bit_length= 0;\n      sseg.bit_pos= 0;\n      sseg.length=SPLEN;\n      sseg.null_pos=0;\n      sseg.start=j*SPLEN;\n      sseg.flag= HA_SWAP_KEY;\n      if (_ma_keyseg_write(file, &sseg))\n        goto err;\n    }\n#endif\n  }\n  /* Create extra keys for unique definitions */\n  offset= real_reclength - uniques*MARIA_UNIQUE_HASH_LENGTH;\n  bzero((char*) &tmp_keydef,sizeof(tmp_keydef));\n  bzero((char*) &tmp_keyseg,sizeof(tmp_keyseg));\n  for (i=0; i < uniques ; i++)\n  {\n    tmp_keydef.keysegs=1;\n    tmp_keydef.flag=\t\tHA_UNIQUE_CHECK;\n    tmp_keydef.block_length=\t(uint16) maria_block_size;\n    tmp_keydef.keylength=\tMARIA_UNIQUE_HASH_LENGTH + pointer;\n    tmp_keydef.minlength=tmp_keydef.maxlength=tmp_keydef.keylength;\n    tmp_keyseg.type=\t\tMARIA_UNIQUE_HASH_TYPE;\n    tmp_keyseg.length=\t\tMARIA_UNIQUE_HASH_LENGTH;\n    tmp_keyseg.start=\t\toffset;\n    offset+=\t\t\tMARIA_UNIQUE_HASH_LENGTH;\n    if (_ma_keydef_write(file,&tmp_keydef) ||\n\t_ma_keyseg_write(file,(&tmp_keyseg)))\n      goto err;\n  }\n\n  /* Save unique definition */\n  DBUG_PRINT(\"info\", (\"write unique definitions\"));\n  for (i=0 ; i < share.state.header.uniques ; i++)\n  {\n    HA_KEYSEG *keyseg_end;\n    keyseg= uniquedefs[i].seg;\n    if (_ma_uniquedef_write(file, &uniquedefs[i]))\n      goto err;\n    for (keyseg= uniquedefs[i].seg, keyseg_end= keyseg+ uniquedefs[i].keysegs;\n         keyseg < keyseg_end;\n         keyseg++)\n    {\n      switch (keyseg->type) {\n      case HA_KEYTYPE_VARTEXT1:\n      case HA_KEYTYPE_VARTEXT2:\n      case HA_KEYTYPE_VARBINARY1:\n      case HA_KEYTYPE_VARBINARY2:\n        if (!(keyseg->flag & HA_BLOB_PART))\n        {\n          keyseg->flag|= HA_VAR_LENGTH_PART;\n          keyseg->bit_start= ((keyseg->type == HA_KEYTYPE_VARTEXT1 ||\n                               keyseg->type == HA_KEYTYPE_VARBINARY1) ?\n                              1 : 2);\n        }\n        break;\n      default:\n        DBUG_ASSERT((keyseg->flag & HA_VAR_LENGTH_PART) == 0);\n        break;\n      }\n      if (_ma_keyseg_write(file, keyseg))\n\tgoto err;\n    }\n  }\n  DBUG_PRINT(\"info\", (\"write field definitions\"));\n  if (datafile_type == BLOCK_RECORD)\n  {\n    /* Store columns in a more efficent order */\n    MARIA_COLUMNDEF **col_order, **pos;\n    if (!(col_order= (MARIA_COLUMNDEF**) my_malloc(share.base.fields *\n                                                   sizeof(MARIA_COLUMNDEF*),\n                                                   MYF(MY_WME))))\n      goto err;\n    for (column= columndef, pos= col_order ;\n         column != end_column ;\n         column++, pos++)\n      *pos= column;\n    qsort(col_order, share.base.fields, sizeof(*col_order),\n          (qsort_cmp) compare_columns);\n    for (i=0 ; i < share.base.fields ; i++)\n    {\n      column_array[col_order[i]->column_nr]= i;\n      if (_ma_columndef_write(file, col_order[i]))\n      {\n        my_free(col_order);\n        goto err;\n      }\n    }\n    my_free(col_order);\n  }\n  else\n  {\n    for (i=0 ; i < share.base.fields ; i++)\n    {\n      column_array[i]= (uint16) i;\n      if (_ma_columndef_write(file, &columndef[i]))\n        goto err;\n    }\n  }\n  if (_ma_column_nr_write(file, column_array, columns))\n    goto err;\n\n  if (encrypted)\n  {\n    if (ma_crypt_create(&share) ||\n        ma_crypt_write(&share, file))\n      goto err;\n  }\n\n  if ((kfile_size_before_extension= mysql_file_tell(file,MYF(0))) == MY_FILEPOS_ERROR)\n    goto err;\n#ifndef DBUG_OFF\n  if (kfile_size_before_extension != info_length)\n    DBUG_PRINT(\"warning\",(\"info_length: %u  != used_length: %u\",\n\t\t\t  info_length, (uint)kfile_size_before_extension));\n#endif\n\n  if (sync_dir)\n  {\n    /*\n      we log the first bytes and then the size to which we extend; this is\n      not log 1 KB of mostly zeroes if this is a small table.\n    */\n    char empty_string[]= \"\";\n    LEX_CUSTRING log_array[TRANSLOG_INTERNAL_PARTS + 4];\n    translog_size_t total_rec_length= 0;\n    uint k;\n    LSN lsn;\n    log_array[TRANSLOG_INTERNAL_PARTS + 1].length= 1 + 2 + 2 +\n      (uint) kfile_size_before_extension;\n    /* we are needing maybe 64 kB, so don't use the stack */\n    log_data= my_malloc(log_array[TRANSLOG_INTERNAL_PARTS + 1].length, MYF(0));\n    if ((log_data == NULL) ||\n        mysql_file_pread(file, 1 + 2 + 2 + log_data,\n                 (size_t) kfile_size_before_extension, 0, MYF(MY_NABP)))\n      goto err;\n    /*\n      remember if the data file was created or not, to know if Recovery can\n      do it or not, in the future\n    */\n    log_data[0]= MY_TEST(flags & HA_DONT_TOUCH_DATA);\n    int2store(log_data + 1, kfile_size_before_extension);\n    int2store(log_data + 1 + 2, share.base.keystart);\n    log_array[TRANSLOG_INTERNAL_PARTS + 0].str= (uchar *)name;\n    /* we store the end-zero, for Recovery to just pass it to my_create() */\n    log_array[TRANSLOG_INTERNAL_PARTS + 0].length= strlen(name) + 1;\n    log_array[TRANSLOG_INTERNAL_PARTS + 1].str= log_data;\n    /* symlink description is also needed for re-creation by Recovery: */\n    {\n      const char *s= ci->data_file_name ? ci->data_file_name : empty_string;\n      log_array[TRANSLOG_INTERNAL_PARTS + 2].str= (uchar*)s;\n      log_array[TRANSLOG_INTERNAL_PARTS + 2].length= strlen(s) + 1;\n      s= ci->index_file_name ? ci->index_file_name : empty_string;\n      log_array[TRANSLOG_INTERNAL_PARTS + 3].str= (uchar*)s;\n      log_array[TRANSLOG_INTERNAL_PARTS + 3].length= strlen(s) + 1;\n    }\n    for (k= TRANSLOG_INTERNAL_PARTS;\n         k < (sizeof(log_array)/sizeof(log_array[0])); k++)\n      total_rec_length+= (translog_size_t) log_array[k].length;\n    /**\n       For this record to be of any use for Recovery, we need the upper\n       MySQL layer to be crash-safe, which it is not now (that would require\n       work using the ddl_log of sql/sql_table.cc); when it is, we should\n       reconsider the moment of writing this log record (before or after op,\n       under THR_LOCK_maria or not...), how to use it in Recovery.\n       For now this record can serve when we apply logs to a backup,\n       so we sync it. This happens before the data file is created. If the\n       data file was created before, and we crashed before writing the log\n       record, at restart the table may be used, so we would not have a\n       trustable history in the log (impossible to apply this log to a\n       backup). The way we do it, if we crash before writing the log record\n       then there is no data file and the table cannot be used.\n       @todo Note that in case of TRUNCATE TABLE we also come here; for\n       Recovery to be able to finish TRUNCATE TABLE, instead of leaving a\n       half-truncated table, we should log the record at start of\n       maria_create(); for that we shouldn't write to the index file but to a\n       buffer (DYNAMIC_STRING), put the buffer into the record, then put the\n       buffer into the index file (so, change _ma_keydef_write() etc). That\n       would also enable Recovery to finish a CREATE TABLE. The final result\n       would be that we would be able to finish what the SQL layer has asked\n       for: it would be atomic.\n       When in CREATE/TRUNCATE (or DROP or RENAME or REPAIR) we have not\n       called external_lock(), so have no TRN. It does not matter, as all\n       these operations are non-transactional and sync their files.\n    */\n    if (unlikely(translog_write_record(&lsn,\n                                       LOGREC_REDO_CREATE_TABLE,\n                                       &dummy_transaction_object, NULL,\n                                       total_rec_length,\n                                       sizeof(log_array)/sizeof(log_array[0]),\n                                       log_array, NULL, NULL) ||\n                 translog_flush(lsn)))\n      goto err;\n    share.kfile.file= file;\n    DBUG_EXECUTE_IF(\"maria_flush_whole_log\",\n                    {\n                      DBUG_PRINT(\"maria_flush_whole_log\", (\"now\"));\n                      translog_flush(translog_get_horizon());\n                    });\n    DBUG_EXECUTE_IF(\"maria_crash_create_table\",\n                    {\n                      DBUG_PRINT(\"maria_crash_create_table\", (\"now\"));\n                      DBUG_ABORT();\n                    });\n    /*\n      store LSN into file, needed for Recovery to not be confused if a\n      DROP+CREATE happened (applying REDOs to the wrong table).\n    */\n    if (_ma_update_state_lsns_sub(&share, lsn, trnman_get_min_safe_trid(),\n                                  FALSE, TRUE))\n      goto err;\n    my_free(log_data);\n  }\n\n  if (!(flags & HA_DONT_TOUCH_DATA))\n  {\n    if (ci->data_file_name)\n    {\n      char *dext= strrchr(ci->data_file_name, '.');\n      int have_dext= dext && !strcmp(dext, MARIA_NAME_DEXT);\n\n      if (tmp_table)\n      {\n        char *path;\n        /* chop off the table name, tempory tables use generated name */\n        if ((path= strrchr(ci->data_file_name, FN_LIBCHAR)))\n          *path= '\\0';\n        fn_format(dfilename, name, ci->data_file_name, MARIA_NAME_DEXT,\n                  MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_APPEND_EXT);\n      }\n      else\n      {\n        fn_format(dfilename, ci->data_file_name, \"\", MARIA_NAME_DEXT,\n                  MY_UNPACK_FILENAME |\n                  (have_dext ? MY_REPLACE_EXT : MY_APPEND_EXT));\n      }\n      fn_format(dlinkname, name, \"\",MARIA_NAME_DEXT,\n                MY_UNPACK_FILENAME | MY_APPEND_EXT);\n      dlinkname_ptr= dlinkname;\n      create_flag=0;\n    }\n    else\n    {\n      fn_format(dfilename,name,\"\", MARIA_NAME_DEXT,\n                MY_UNPACK_FILENAME | MY_APPEND_EXT);\n      create_flag= (flags & HA_CREATE_KEEP_FILES) ? 0 : MY_DELETE_OLD;\n    }\n    if ((dfile=\n         mysql_file_create_with_symlink(key_file_dfile, dlinkname_ptr,\n                                        dfilename, 0, create_mode,\n                                        MYF(MY_WME | create_flag | sync_dir))) < 0)\n      goto err;\n    errpos=3;\n\n    if (_ma_initialize_data_file(&share, dfile))\n      goto err;\n  }\n\n\t/* Enlarge files */\n  DBUG_PRINT(\"info\", (\"enlarge to keystart: %lu\",\n                      (ulong) share.base.keystart));\n  if (mysql_file_chsize(file,(ulong) share.base.keystart,0,MYF(0)))\n    goto err;\n\n  if (!internal_table && sync_dir && mysql_file_sync(file, MYF(0)))\n    goto err;\n\n  if (! (flags & HA_DONT_TOUCH_DATA))\n  {\n#ifdef USE_RELOC\n    if (mysql_file_chsize(key_file_dfile, dfile,\n                          share.base.min_pack_length*ci->reloc_rows,0,MYF(0)))\n      goto err;\n#endif\n    if (!internal_table && sync_dir && mysql_file_sync(dfile, MYF(0)))\n      goto err;\n    if (mysql_file_close(dfile,MYF(0)))\n      goto err;\n  }\n  if (!internal_table)\n    mysql_mutex_unlock(&THR_LOCK_maria);\n  res= 0;\n  my_free((char*) rec_per_key_part);\n  ma_crypt_free(&share);\n  errpos=0;\n  if (mysql_file_close(file,MYF(0)))\n    res= my_errno;\n  DBUG_RETURN(res);\n\nerr:\n  if (!internal_table)\n    mysql_mutex_unlock(&THR_LOCK_maria);\n\nerr_no_lock:\n  save_errno=my_errno;\n  switch (errpos) {\n  case 3:\n    mysql_file_close(dfile, MYF(0));\n    if (! (flags & HA_DONT_TOUCH_DATA))\n    {\n      mysql_file_delete(key_file_dfile, dfilename, MYF(sync_dir));\n      if (dlinkname_ptr)\n        mysql_file_delete(key_file_dfile, dlinkname_ptr, MYF(sync_dir));\n    }\n    /* fall through */\n  case 1:\n    mysql_file_close(file, MYF(0));\n    if (! (flags & HA_DONT_TOUCH_DATA))\n    {\n      mysql_file_delete(key_file_kfile, kfilename, MYF(sync_dir));\n      if (klinkname_ptr)\n        mysql_file_delete(key_file_kfile, klinkname_ptr, MYF(sync_dir));\n    }\n  }\n  ma_crypt_free(&share);\n  my_free(log_data);\n  my_free(rec_per_key_part);\n  DBUG_RETURN(my_errno=save_errno);\t\t/* return the fatal errno */\n}",
        "post_patch": "int maria_create(const char *name, enum data_file_type datafile_type,\n                 uint keys,MARIA_KEYDEF *keydefs,\n                 uint columns, MARIA_COLUMNDEF *columndef,\n                 uint uniques, MARIA_UNIQUEDEF *uniquedefs,\n                 MARIA_CREATE_INFO *ci,uint flags)\n{\n  register uint i,j;\n  File UNINIT_VAR(dfile), UNINIT_VAR(file);\n  int errpos,save_errno, create_mode= O_RDWR | O_TRUNC, res;\n  myf create_flag;\n  uint length,max_key_length,packed,pack_bytes,pointer,real_length_diff,\n       key_length,info_length,key_segs,options,min_key_length,\n       base_pos,long_varchar_count,\n       unique_key_parts,fulltext_keys,offset, not_block_record_extra_length;\n  uint max_field_lengths, extra_header_size, column_nr;\n  uint internal_table= flags & HA_CREATE_INTERNAL_TABLE;\n  ulong reclength, real_reclength,min_pack_length;\n  char kfilename[FN_REFLEN], klinkname[FN_REFLEN], *klinkname_ptr= NullS;\n  char dfilename[FN_REFLEN], dlinkname[FN_REFLEN], *dlinkname_ptr= 0;\n  ulong pack_reclength;\n  ulonglong tot_length,max_rows, tmp;\n  enum en_fieldtype type;\n  enum data_file_type org_datafile_type= datafile_type;\n  MARIA_SHARE share;\n  MARIA_KEYDEF *keydef,tmp_keydef;\n  MARIA_UNIQUEDEF *uniquedef;\n  HA_KEYSEG *keyseg,tmp_keyseg;\n  MARIA_COLUMNDEF *column, *end_column;\n  double *rec_per_key_part;\n  ulong  *nulls_per_key_part;\n  uint16 *column_array;\n  my_off_t key_root[HA_MAX_POSSIBLE_KEY], kfile_size_before_extension;\n  MARIA_CREATE_INFO tmp_create_info;\n  my_bool tmp_table= FALSE; /* cache for presence of HA_OPTION_TMP_TABLE */\n  my_bool forced_packed;\n  myf     sync_dir=  0;\n  uchar   *log_data= NULL;\n  my_bool encrypted= maria_encrypt_tables && datafile_type == BLOCK_RECORD;\n  my_bool insert_order= MY_TEST(flags & HA_PRESERVE_INSERT_ORDER);\n  uint crypt_page_header_space= 0;\n  DBUG_ENTER(\"maria_create\");\n  DBUG_PRINT(\"enter\", (\"keys: %u  columns: %u  uniques: %u  flags: %u\",\n                      keys, columns, uniques, flags));\n\n  DBUG_ASSERT(maria_inited);\n\n  if (!ci)\n  {\n    bzero((char*) &tmp_create_info,sizeof(tmp_create_info));\n    ci=&tmp_create_info;\n  }\n\n  if (keys + uniques > MARIA_MAX_KEY)\n  {\n    DBUG_RETURN(my_errno=HA_WRONG_CREATE_OPTION);\n  }\n  errpos=0;\n  options=0;\n  bzero((uchar*) &share,sizeof(share));\n\n  if (flags & HA_DONT_TOUCH_DATA)\n  {\n    /* We come here from recreate table */\n    org_datafile_type= ci->org_data_file_type;\n    if (!(ci->old_options & HA_OPTION_TEMP_COMPRESS_RECORD))\n      options= (ci->old_options &\n                (HA_OPTION_COMPRESS_RECORD | HA_OPTION_PACK_RECORD |\n                 HA_OPTION_READ_ONLY_DATA | HA_OPTION_CHECKSUM |\n                 HA_OPTION_TMP_TABLE | HA_OPTION_DELAY_KEY_WRITE |\n                 HA_OPTION_LONG_BLOB_PTR | HA_OPTION_PAGE_CHECKSUM));\n    else\n    {\n      /* Uncompressing rows */\n      options= (ci->old_options &\n                (HA_OPTION_CHECKSUM | HA_OPTION_TMP_TABLE |\n                 HA_OPTION_DELAY_KEY_WRITE | HA_OPTION_LONG_BLOB_PTR |\n                 HA_OPTION_PAGE_CHECKSUM));\n    }\n  }\n  else\n  {\n    /* Transactional tables must be of type BLOCK_RECORD */\n    if (ci->transactional)\n      datafile_type= BLOCK_RECORD;\n  }\n\n  if (!(rec_per_key_part=\n\t(double*) my_malloc((keys + uniques)*HA_MAX_KEY_SEG*sizeof(double) +\n                            (keys + uniques)*HA_MAX_KEY_SEG*sizeof(ulong) +\n                            sizeof(uint16) * columns,\n                            MYF(MY_WME | MY_ZEROFILL))))\n    DBUG_RETURN(my_errno);\n  nulls_per_key_part= (ulong*) (rec_per_key_part +\n                                (keys + uniques) * HA_MAX_KEY_SEG);\n  column_array= (uint16*) (nulls_per_key_part +\n                           (keys + uniques) * HA_MAX_KEY_SEG);\n\n\n  /* Start by checking fields and field-types used */\n  long_varchar_count=packed= not_block_record_extra_length=\n    pack_reclength= max_field_lengths= 0;\n  reclength= min_pack_length= ci->null_bytes;\n  forced_packed= 0;\n  column_nr= 0;\n\n  if (encrypted)\n  {\n    DBUG_ASSERT(datafile_type == BLOCK_RECORD);\n    crypt_page_header_space= ma_crypt_get_data_page_header_space();\n  }\n\n  for (column= columndef, end_column= column + columns ;\n       column != end_column ;\n       column++)\n  {\n    /* Fill in not used struct parts */\n    column->column_nr= column_nr++;\n    column->offset= reclength;\n    column->empty_pos= 0;\n    column->empty_bit= 0;\n    column->fill_length= column->length;\n    if (column->null_bit)\n      options|= HA_OPTION_NULL_FIELDS;\n\n    reclength+= column->length;\n    type= column->type;\n    if (datafile_type == BLOCK_RECORD)\n    {\n      if (type == FIELD_SKIP_PRESPACE)\n        type= column->type= FIELD_NORMAL; /* SKIP_PRESPACE not supported */\n      if (type == FIELD_NORMAL &&\n          column->length > FULL_PAGE_SIZE2(maria_block_size,\n                                           crypt_page_header_space))\n      {\n        /* FIELD_NORMAL can't be split over many blocks, convert to a CHAR */\n        type= column->type= FIELD_SKIP_ENDSPACE;\n      }\n    }\n\n    if (type != FIELD_NORMAL && type != FIELD_CHECK)\n    {\n      column->empty_pos= packed/8;\n      column->empty_bit= (1 << (packed & 7));\n      if (type == FIELD_BLOB)\n      {\n        forced_packed= 1;\n        packed++;\n\tshare.base.blobs++;\n\tif (pack_reclength != INT_MAX32)\n\t{\n\t  if (column->length == 4+portable_sizeof_char_ptr)\n\t    pack_reclength= INT_MAX32;\n\t  else\n          {\n            /* Add max possible blob length */\n\t    pack_reclength+= (1 << ((column->length-\n                                     portable_sizeof_char_ptr)*8));\n          }\n\t}\n        max_field_lengths+= (column->length - portable_sizeof_char_ptr);\n      }\n      else if (type == FIELD_SKIP_PRESPACE ||\n\t       type == FIELD_SKIP_ENDSPACE)\n      {\n        forced_packed= 1;\n        max_field_lengths+= column->length > 255 ? 2 : 1;\n        not_block_record_extra_length++;\n        packed++;\n      }\n      else if (type == FIELD_VARCHAR)\n      {\n\tpack_reclength++;\n        not_block_record_extra_length++;\n        max_field_lengths++;\n        if (datafile_type != DYNAMIC_RECORD)\n          packed++;\n        column->fill_length= 1;\n        options|= HA_OPTION_NULL_FIELDS;        /* Use ma_checksum() */\n\n        /* We must test for 257 as length includes pack-length */\n        if (MY_TEST(column->length >= 257))\n\t{\n\t  long_varchar_count++;\n          max_field_lengths++;\n          column->fill_length= 2;\n\t}\n      }\n      else if (type == FIELD_SKIP_ZERO)\n        packed++;\n      else\n      {\n        if (!column->null_bit)\n          min_pack_length+= column->length;\n        else\n        {\n          /* Only BLOCK_RECORD skips NULL fields for all field values */\n          not_block_record_extra_length+= column->length;\n        }\n        column->empty_pos= 0;\n        column->empty_bit= 0;\n      }\n    }\n    else\t\t\t\t\t/* FIELD_NORMAL */\n    {\n      if (!column->null_bit)\n      {\n        min_pack_length+= column->length;\n        share.base.fixed_not_null_fields++;\n        share.base.fixed_not_null_fields_length+= column->length;\n      }\n      else\n        not_block_record_extra_length+= column->length;\n    }\n  }\n\n  if (datafile_type == STATIC_RECORD && forced_packed)\n  {\n    /* Can't use fixed length records, revert to block records */\n    datafile_type= BLOCK_RECORD;\n  }\n\n  if (datafile_type == NO_RECORD && uniques)\n  {\n    /* Can't do unique without data, revert to block records */\n    datafile_type= BLOCK_RECORD;\n  }\n\n  if (encrypted)\n  {\n    /*\n       datafile_type is set (finally?)\n       update encryption that is only supported for BLOCK_RECORD\n    */\n    if (datafile_type != BLOCK_RECORD)\n    {\n      encrypted= FALSE;\n      crypt_page_header_space= 0;\n    }\n  }\n\n  if (datafile_type == DYNAMIC_RECORD)\n    options|= HA_OPTION_PACK_RECORD;\t/* Must use packed records */\n\n  if (datafile_type == STATIC_RECORD || datafile_type == NO_RECORD)\n  {\n    /* We can't use checksum with static length rows */\n    flags&= ~HA_CREATE_CHECKSUM;\n    options&= ~HA_OPTION_CHECKSUM;\n    min_pack_length= reclength;\n    packed= 0;\n  }\n  else if (datafile_type != BLOCK_RECORD)\n    min_pack_length+= not_block_record_extra_length;\n  else\n    min_pack_length+= 5;                        /* Min row overhead */\n\n  if (flags & HA_CREATE_TMP_TABLE)\n  {\n    options|= HA_OPTION_TMP_TABLE;\n    tmp_table= TRUE;\n    create_mode|= O_NOFOLLOW | (internal_table ? 0 : O_EXCL);\n    /* \"CREATE TEMPORARY\" tables are not crash-safe (dropped at restart) */\n    ci->transactional= FALSE;\n    flags&= ~HA_CREATE_PAGE_CHECKSUM;\n  }\n  share.base.null_bytes= ci->null_bytes;\n  share.base.original_null_bytes= ci->null_bytes;\n  share.base.born_transactional= ci->transactional;\n  share.base.max_field_lengths= max_field_lengths;\n  share.base.field_offsets= 0;                  /* for future */\n\n  if (flags & HA_CREATE_CHECKSUM || (options & HA_OPTION_CHECKSUM))\n  {\n    options|= HA_OPTION_CHECKSUM;\n    min_pack_length++;\n    pack_reclength++;\n  }\n  if (pack_reclength < INT_MAX32)\n    pack_reclength+= max_field_lengths + long_varchar_count;\n  else\n    pack_reclength= INT_MAX32;\n\n  if (flags & HA_CREATE_DELAY_KEY_WRITE)\n    options|= HA_OPTION_DELAY_KEY_WRITE;\n  if (flags & HA_CREATE_RELIES_ON_SQL_LAYER)\n    options|= HA_OPTION_RELIES_ON_SQL_LAYER;\n  if (flags & HA_CREATE_PAGE_CHECKSUM)\n    options|= HA_OPTION_PAGE_CHECKSUM;\n\n  pack_bytes= (packed + 7) / 8;\n  if (pack_reclength != INT_MAX32)\n    pack_reclength+= reclength+pack_bytes +\n      MY_TEST(test_all_bits(options, HA_OPTION_CHECKSUM |\n                                     HA_OPTION_PACK_RECORD));\n  min_pack_length+= pack_bytes;\n  /* Calculate min possible row length for rows-in-block */\n  extra_header_size= MAX_FIXED_HEADER_SIZE;\n  if (ci->transactional)\n  {\n    extra_header_size= TRANS_MAX_FIXED_HEADER_SIZE;\n    DBUG_PRINT(\"info\",(\"creating a transactional table\"));\n  }\n  share.base.min_block_length= (extra_header_size + share.base.null_bytes +\n                                pack_bytes);\n  if (!ci->data_file_length && ci->max_rows)\n  {\n    set_if_bigger(ci->max_rows, ci->reloc_rows);\n    if (pack_reclength == INT_MAX32 ||\n             (~(ulonglong) 0)/ci->max_rows < (ulonglong) pack_reclength)\n      ci->data_file_length= ~(ulonglong) 0;\n    else\n    {\n      ci->data_file_length= _ma_safe_mul(ci->max_rows, pack_reclength);\n      if (datafile_type == BLOCK_RECORD)\n      {\n        /* Assume that blocks are only half full (very pessimistic!) */\n        ci->data_file_length= _ma_safe_mul(ci->data_file_length, 2);\n        set_if_bigger(ci->data_file_length, maria_block_size*2);\n      }\n    }\n  }\n  else if (!ci->max_rows)\n  {\n    if (datafile_type == BLOCK_RECORD)\n    {\n      uint rows_per_page=\n          ((maria_block_size - PAGE_OVERHEAD_SIZE_RAW - crypt_page_header_space)\n           / (min_pack_length + extra_header_size + DIR_ENTRY_SIZE));\n      ulonglong data_file_length= ci->data_file_length;\n      if (!data_file_length)\n        data_file_length= ((((ulonglong) 1 << ((BLOCK_RECORD_POINTER_SIZE-1) *\n                                               8))/2 -1) * maria_block_size);\n      if (rows_per_page > 0)\n      {\n        set_if_smaller(rows_per_page, MAX_ROWS_PER_PAGE);\n        ci->max_rows= (data_file_length / maria_block_size+1) * rows_per_page;\n      }\n      else\n        ci->max_rows= data_file_length / (min_pack_length +\n                                          extra_header_size +\n                                          DIR_ENTRY_SIZE);\n    }\n    else\n      ci->max_rows=(ha_rows) (ci->data_file_length/(min_pack_length +\n                                                    ((options &\n                                                      HA_OPTION_PACK_RECORD) ?\n                                                     3 : 0)));\n    set_if_smaller(ci->reloc_rows, ci->max_rows);\n  }\n  max_rows= (ulonglong) ci->max_rows;\n  if (datafile_type == BLOCK_RECORD)\n  {\n    /*\n      The + 1 is for record position withing page\n      The * 2 is because we need one bit for knowing if there is transid's\n      after the row pointer\n    */\n    pointer= maria_get_pointer_length((ci->data_file_length /\n                                       maria_block_size) * 2, 4) + 1;\n    set_if_smaller(pointer, BLOCK_RECORD_POINTER_SIZE);\n\n    if (!max_rows)\n      max_rows= (((((ulonglong) 1 << ((pointer-1)*8)) -1) * maria_block_size) /\n                 min_pack_length / 2);\n                                      }\n  else\n  {\n    if (datafile_type == NO_RECORD)\n      pointer= 0;\n    else if (datafile_type != STATIC_RECORD)\n      pointer= maria_get_pointer_length(ci->data_file_length,\n                                        maria_data_pointer_size);\n    else\n      pointer= maria_get_pointer_length(ci->max_rows, maria_data_pointer_size);\n    if (!max_rows)\n      max_rows= ((((ulonglong) 1 << (pointer*8)) -1) / min_pack_length);\n  }\n\n  real_reclength=reclength;\n  if (datafile_type == STATIC_RECORD)\n  {\n    if (reclength <= pointer)\n      reclength=pointer+1;\t\t/* reserve place for delete link */\n  }\n  else\n    reclength+= long_varchar_count;\t/* We need space for varchar! */\n\n  max_key_length=0; tot_length=0 ; key_segs=0;\n  fulltext_keys=0;\n  share.state.rec_per_key_part=   rec_per_key_part;\n  share.state.nulls_per_key_part= nulls_per_key_part;\n  share.state.key_root=key_root;\n  share.state.key_del= HA_OFFSET_ERROR;\n  if (uniques)\n    max_key_length= MARIA_UNIQUE_HASH_LENGTH + pointer;\n\n  for (i=0, keydef=keydefs ; i < keys ; i++ , keydef++)\n  {\n    share.state.key_root[i]= HA_OFFSET_ERROR;\n    length= real_length_diff= 0;\n    min_key_length= key_length= pointer;\n\n    if (keydef->key_alg == HA_KEY_ALG_RTREE)\n      keydef->flag|= HA_RTREE_INDEX;            /* For easier tests */\n\n    if (keydef->flag & HA_SPATIAL)\n    {\n#ifdef HAVE_SPATIAL\n      /* BAR TODO to support 3D and more dimensions in the future */\n      uint sp_segs=SPDIMS*2;\n      keydef->flag=HA_SPATIAL;\n\n      if (flags & HA_DONT_TOUCH_DATA)\n      {\n        /*\n          Called by maria_chk - i.e. table structure was taken from\n          MYI file and SPATIAL key *does have* additional sp_segs keysegs.\n          keydef->seg here points right at the GEOMETRY segment,\n          so we only need to decrease keydef->keysegs.\n          (see maria_recreate_table() in _ma_check.c)\n        */\n        keydef->keysegs-=sp_segs-1;\n      }\n\n      for (j=0, keyseg=keydef->seg ; (int) j < keydef->keysegs ;\n\t   j++, keyseg++)\n      {\n        if (keyseg->type != HA_KEYTYPE_BINARY &&\n\t    keyseg->type != HA_KEYTYPE_VARBINARY1 &&\n            keyseg->type != HA_KEYTYPE_VARBINARY2)\n        {\n          my_errno=HA_WRONG_CREATE_OPTION;\n          goto err_no_lock;\n        }\n      }\n      keydef->keysegs+=sp_segs;\n      key_length+=SPLEN*sp_segs;\n      length++;                              /* At least one length uchar */\n      min_key_length++;\n#else\n      my_errno= HA_ERR_UNSUPPORTED;\n      goto err_no_lock;\n#endif /*HAVE_SPATIAL*/\n    }\n    else if (keydef->flag & HA_FULLTEXT)\n    {\n      keydef->flag=HA_FULLTEXT | HA_PACK_KEY | HA_VAR_LENGTH_KEY;\n      options|=HA_OPTION_PACK_KEYS;             /* Using packed keys */\n\n      for (j=0, keyseg=keydef->seg ; (int) j < keydef->keysegs ;\n\t   j++, keyseg++)\n      {\n        if (keyseg->type != HA_KEYTYPE_TEXT &&\n\t    keyseg->type != HA_KEYTYPE_VARTEXT1 &&\n            keyseg->type != HA_KEYTYPE_VARTEXT2)\n        {\n          my_errno=HA_WRONG_CREATE_OPTION;\n          goto err_no_lock;\n        }\n        if (!(keyseg->flag & HA_BLOB_PART) &&\n\t    (keyseg->type == HA_KEYTYPE_VARTEXT1 ||\n             keyseg->type == HA_KEYTYPE_VARTEXT2))\n        {\n          /* Make a flag that this is a VARCHAR */\n          keyseg->flag|= HA_VAR_LENGTH_PART;\n          /* Store in bit_start number of bytes used to pack the length */\n          keyseg->bit_start= ((keyseg->type == HA_KEYTYPE_VARTEXT1)?\n                              1 : 2);\n        }\n      }\n\n      fulltext_keys++;\n      key_length+= HA_FT_MAXBYTELEN+HA_FT_WLEN;\n      length++;                              /* At least one length uchar */\n      min_key_length+= 1 + HA_FT_WLEN;\n      real_length_diff=HA_FT_MAXBYTELEN-FT_MAX_WORD_LEN_FOR_SORT;\n    }\n    else\n    {\n      /* Test if prefix compression */\n      if (keydef->flag & HA_PACK_KEY)\n      {\n\t/* Can't use space_compression on number keys */\n\tif ((keydef->seg[0].flag & HA_SPACE_PACK) &&\n\t    keydef->seg[0].type == (int) HA_KEYTYPE_NUM)\n\t  keydef->seg[0].flag&= ~HA_SPACE_PACK;\n\n\t/* Only use HA_PACK_KEY when first segment is a variable length key */\n\tif (!(keydef->seg[0].flag & (HA_SPACE_PACK | HA_BLOB_PART |\n\t\t\t\t     HA_VAR_LENGTH_PART)))\n\t{\n\t  /* pack relative to previous key */\n\t  keydef->flag&= ~HA_PACK_KEY;\n\t  keydef->flag|= HA_BINARY_PACK_KEY | HA_VAR_LENGTH_KEY;\n\t}\n\telse\n\t{\n\t  keydef->seg[0].flag|=HA_PACK_KEY;\t/* for easyer intern test */\n\t  keydef->flag|=HA_VAR_LENGTH_KEY;\n\t  options|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n\t}\n      }\n      if (keydef->flag & HA_BINARY_PACK_KEY)\n\toptions|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n\n      if (keydef->flag & HA_AUTO_KEY && ci->with_auto_increment)\n\tshare.base.auto_key=i+1;\n      for (j=0, keyseg=keydef->seg ; j < keydef->keysegs ; j++, keyseg++)\n      {\n\t/* numbers are stored with high by first to make compression easier */\n\tswitch (keyseg->type) {\n\tcase HA_KEYTYPE_SHORT_INT:\n\tcase HA_KEYTYPE_LONG_INT:\n\tcase HA_KEYTYPE_FLOAT:\n\tcase HA_KEYTYPE_DOUBLE:\n\tcase HA_KEYTYPE_USHORT_INT:\n\tcase HA_KEYTYPE_ULONG_INT:\n\tcase HA_KEYTYPE_LONGLONG:\n\tcase HA_KEYTYPE_ULONGLONG:\n\tcase HA_KEYTYPE_INT24:\n\tcase HA_KEYTYPE_UINT24:\n\tcase HA_KEYTYPE_INT8:\n\t  keyseg->flag|= HA_SWAP_KEY;\n          break;\n        case HA_KEYTYPE_VARTEXT1:\n        case HA_KEYTYPE_VARTEXT2:\n        case HA_KEYTYPE_VARBINARY1:\n        case HA_KEYTYPE_VARBINARY2:\n          if (!(keyseg->flag & HA_BLOB_PART))\n          {\n            /* Make a flag that this is a VARCHAR */\n            keyseg->flag|= HA_VAR_LENGTH_PART;\n            /* Store in bit_start number of bytes used to pack the length */\n            keyseg->bit_start= ((keyseg->type == HA_KEYTYPE_VARTEXT1 ||\n                                 keyseg->type == HA_KEYTYPE_VARBINARY1) ?\n                                1 : 2);\n          }\n          break;\n\tdefault:\n\t  break;\n\t}\n\tif (keyseg->flag & HA_SPACE_PACK)\n\t{\n          DBUG_ASSERT(!(keyseg->flag & (HA_VAR_LENGTH_PART | HA_BLOB_PART)));\n\t  keydef->flag |= HA_SPACE_PACK_USED | HA_VAR_LENGTH_KEY;\n\t  options|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n\t  length++;\t\t\t\t/* At least one length uchar */\n          if (!keyseg->null_bit)\n            min_key_length++;\n          key_length+= keyseg->length;\n\t  if (keyseg->length >= 255)\n\t  {\n            /* prefix may be 3 bytes */\n\t    length+= 2;\n\t  }\n\t}\n\telse if (keyseg->flag & (HA_VAR_LENGTH_PART | HA_BLOB_PART))\n\t{\n          DBUG_ASSERT(!test_all_bits(keyseg->flag,\n                                    (HA_VAR_LENGTH_PART | HA_BLOB_PART)));\n\t  keydef->flag|=HA_VAR_LENGTH_KEY;\n\t  length++;\t\t\t\t/* At least one length uchar */\n          if (!keyseg->null_bit)\n            min_key_length++;\n\t  options|=HA_OPTION_PACK_KEYS;\t\t/* Using packed keys */\n          key_length+= keyseg->length;\n\t  if (keyseg->length >= 255)\n\t  {\n            /* prefix may be 3 bytes */\n\t    length+= 2;\n\t  }\n\t}\n        else\n        {\n          key_length+= keyseg->length;\n          if (!keyseg->null_bit)\n            min_key_length+= keyseg->length;\n        }\n\tif (keyseg->null_bit)\n\t{\n\t  key_length++;\n          /* min key part is 1 byte */\n          min_key_length++;\n\t  options|=HA_OPTION_PACK_KEYS;\n\t  keyseg->flag|=HA_NULL_PART;\n\t  keydef->flag|=HA_VAR_LENGTH_KEY | HA_NULL_PART_KEY;\n\t}\n      }\n    } /* if HA_FULLTEXT */\n    key_segs+=keydef->keysegs;\n    if (keydef->keysegs > HA_MAX_KEY_SEG)\n    {\n      my_errno=HA_WRONG_CREATE_OPTION;\n      goto err_no_lock;\n    }\n    /*\n      key_segs may be 0 in the case when we only want to be able to\n      add on row into the table. This can happen with some DISTINCT queries\n      in MySQL\n    */\n    if ((keydef->flag & (HA_NOSAME | HA_NULL_PART_KEY)) == HA_NOSAME &&\n\tkey_segs)\n      share.state.rec_per_key_part[key_segs-1]=1L;\n    length+=key_length;\n    /*\n      A key can't be longer than than half a index block (as we have\n      to be able to put at least 2 keys on an index block for the key\n      algorithms to work).\n    */\n    if (length > _ma_max_key_length())\n    {\n      my_errno=HA_WRONG_CREATE_OPTION;\n      goto err_no_lock;\n    }\n    keydef->block_length= (uint16) maria_block_size;\n    keydef->keylength= (uint16) key_length;\n    keydef->minlength= (uint16) min_key_length;\n    keydef->maxlength= (uint16) length;\n\n    if (length > max_key_length)\n      max_key_length= length;\n\n    tot_length= update_tot_length(tot_length, max_rows, length);\n  }\n\n  unique_key_parts=0;\n  for (i=0, uniquedef=uniquedefs ; i < uniques ; i++ , uniquedef++)\n  {\n    uniquedef->key=keys+i;\n    unique_key_parts+=uniquedef->keysegs;\n    share.state.key_root[keys+i]= HA_OFFSET_ERROR;\n\n    tot_length= update_tot_length(tot_length, max_rows, MARIA_UNIQUE_HASH_LENGTH + pointer);\n  }\n  keys+=uniques;\t\t\t\t/* Each unique has 1 key */\n  key_segs+=uniques;\t\t\t\t/* Each unique has 1 key seg */\n\n  base_pos=(MARIA_STATE_INFO_SIZE + keys * MARIA_STATE_KEY_SIZE +\n\t    key_segs * MARIA_STATE_KEYSEG_SIZE);\n  info_length= base_pos+(uint) (MARIA_BASE_INFO_SIZE+\n                                keys * MARIA_KEYDEF_SIZE+\n                                uniques * MARIA_UNIQUEDEF_SIZE +\n                                (key_segs + unique_key_parts)*HA_KEYSEG_SIZE+\n                                columns*(MARIA_COLUMNDEF_SIZE + 2));\n\n  if (encrypted)\n  {\n    share.base.extra_options|= MA_EXTRA_OPTIONS_ENCRYPTED;\n\n    /* store crypt data in info */\n    info_length+= ma_crypt_get_file_length();\n  }\n\n  if (insert_order)\n  {\n    share.base.extra_options|= MA_EXTRA_OPTIONS_INSERT_ORDER;\n  }\n\n  share.state.state.key_file_length= MY_ALIGN(info_length, maria_block_size);\n  DBUG_PRINT(\"info\", (\"info_length: %u\", info_length));\n  /* There are only 16 bits for the total header length. */\n  if (share.state.state.key_file_length > 65535)\n  {\n    my_printf_error(HA_WRONG_CREATE_OPTION,\n                    \"Aria table '%s' has too many columns and/or \"\n                    \"indexes and/or unique constraints.\",\n                    MYF(0), name + dirname_length(name));\n    my_errno= HA_WRONG_CREATE_OPTION;\n    goto err_no_lock;\n  }\n\n  bmove(share.state.header.file_version, maria_file_magic, 4);\n  ci->old_options=options | (ci->old_options & HA_OPTION_TEMP_COMPRESS_RECORD ?\n                             HA_OPTION_COMPRESS_RECORD |\n                             HA_OPTION_TEMP_COMPRESS_RECORD: 0);\n  mi_int2store(share.state.header.options,ci->old_options);\n  mi_int2store(share.state.header.header_length,info_length);\n  mi_int2store(share.state.header.state_info_length,MARIA_STATE_INFO_SIZE);\n  mi_int2store(share.state.header.base_info_length,MARIA_BASE_INFO_SIZE);\n  mi_int2store(share.state.header.base_pos,base_pos);\n  share.state.header.data_file_type= share.data_file_type= datafile_type;\n  share.state.header.org_data_file_type= org_datafile_type;\n  share.state.header.not_used= 0;\n\n  share.state.dellink = HA_OFFSET_ERROR;\n  share.state.first_bitmap_with_space= 0;\n#ifdef MARIA_EXTERNAL_LOCKING\n  share.state.process=\t(ulong) getpid();\n#endif\n  share.state.version=\t(ulong) time((time_t*) 0);\n  share.state.sortkey=  (ushort) ~0;\n  share.state.auto_increment=ci->auto_increment;\n  share.options=options;\n  share.base.rec_reflength=pointer;\n  share.base.block_size= maria_block_size;\n  share.base.language= (ci->language ? ci->language :\n                        default_charset_info->number);\n\n  /*\n    Get estimate for index file length (this may be wrong for FT keys)\n    This is used for pointers to other key pages.\n  */\n  tmp= (tot_length / maria_block_size + keys * MARIA_INDEX_BLOCK_MARGIN);\n\n  /*\n    use maximum of key_file_length we calculated and key_file_length value we\n    got from MAI file header (see also mariapack.c:save_state)\n  */\n  share.base.key_reflength=\n    maria_get_pointer_length(MY_MAX(ci->key_file_length,tmp),3);\n  share.base.keys= share.state.header.keys= keys;\n  share.state.header.uniques= uniques;\n  share.state.header.fulltext_keys= fulltext_keys;\n  mi_int2store(share.state.header.key_parts,key_segs);\n  mi_int2store(share.state.header.unique_key_parts,unique_key_parts);\n\n  maria_set_all_keys_active(share.state.key_map, keys);\n\n  share.base.keystart = share.state.state.key_file_length;\n  share.base.max_key_block_length= maria_block_size;\n  share.base.max_key_length=ALIGN_SIZE(max_key_length+4);\n  share.base.records=ci->max_rows;\n  share.base.reloc=  ci->reloc_rows;\n  share.base.reclength=real_reclength;\n  share.base.pack_reclength= reclength + MY_TEST(options & HA_OPTION_CHECKSUM);\n  share.base.max_pack_length=pack_reclength;\n  share.base.min_pack_length=min_pack_length;\n  share.base.pack_bytes= pack_bytes;\n  share.base.fields= columns;\n  share.base.pack_fields= packed;\n\n  if (share.data_file_type == BLOCK_RECORD)\n  {\n    /*\n      we are going to create a first bitmap page, set data_file_length\n      to reflect this, before the state goes to disk\n    */\n    share.state.state.data_file_length= maria_block_size;\n    /* Add length of packed fields + length */\n    share.base.pack_reclength+= share.base.max_field_lengths+3;\n    share.base.max_pack_length= share.base.pack_reclength;\n\n    /* Adjust max_pack_length, to be used if we have short rows */\n    if (share.base.max_pack_length < maria_block_size)\n    {\n      share.base.max_pack_length+= FLAG_SIZE;\n      if (ci->transactional)\n        share.base.max_pack_length+= TRANSID_SIZE * 2;\n    }\n  }\n\n  /* max_data_file_length and max_key_file_length are recalculated on open */\n  if (tmp_table)\n    share.base.max_data_file_length= (my_off_t) ci->data_file_length;\n  else if (ci->transactional && translog_status == TRANSLOG_OK &&\n           !maria_in_recovery)\n  {\n    /*\n      we have checked translog_inited above, because maria_chk may call us\n      (via maria_recreate_table()) and it does not have a log.\n    */\n    sync_dir= MY_SYNC_DIR;\n    /*\n      If crash between _ma_state_info_write_sub() and\n      _ma_update_state__lsns_sub(), table should be ignored by Recovery (or\n      old REDOs would fail), so we cannot let LSNs be 0:\n    */\n    share.state.skip_redo_lsn= share.state.is_of_horizon=\n      share.state.create_rename_lsn= LSN_MAX;\n  }\n\n  if (datafile_type == DYNAMIC_RECORD)\n  {\n    share.base.min_block_length=\n      (share.base.pack_reclength+3 < MARIA_EXTEND_BLOCK_LENGTH &&\n       ! share.base.blobs) ?\n      MY_MAX(share.base.pack_reclength,MARIA_MIN_BLOCK_LENGTH) :\n      MARIA_EXTEND_BLOCK_LENGTH;\n  }\n  else if (datafile_type == STATIC_RECORD)\n    share.base.min_block_length= share.base.pack_reclength;\n\n  if (! (flags & HA_DONT_TOUCH_DATA))\n    share.state.create_time= time((time_t*) 0);\n\n  if (!internal_table)\n    mysql_mutex_lock(&THR_LOCK_maria);\n\n  /*\n    NOTE: For test_if_reopen() we need a real path name. Hence we need\n    MY_RETURN_REAL_PATH for every fn_format(filename, ...).\n  */\n  if (ci->index_file_name)\n  {\n    char *iext= strrchr(ci->index_file_name, '.');\n    int have_iext= iext && !strcmp(iext, MARIA_NAME_IEXT);\n    if (tmp_table)\n    {\n      char *path;\n      /* chop off the table name, tempory tables use generated name */\n      if ((path= strrchr(ci->index_file_name, FN_LIBCHAR)))\n        *path= '\\0';\n      fn_format(kfilename, name, ci->index_file_name, MARIA_NAME_IEXT,\n                MY_REPLACE_DIR | MY_UNPACK_FILENAME |\n                MY_RETURN_REAL_PATH | MY_APPEND_EXT);\n    }\n    else\n    {\n      fn_format(kfilename, ci->index_file_name, \"\", MARIA_NAME_IEXT,\n                MY_UNPACK_FILENAME | MY_RETURN_REAL_PATH |\n                (have_iext ? MY_REPLACE_EXT : MY_APPEND_EXT));\n    }\n    fn_format(klinkname, name, \"\", MARIA_NAME_IEXT,\n              MY_UNPACK_FILENAME|MY_APPEND_EXT);\n    klinkname_ptr= klinkname;\n    /*\n      Don't create the table if the link or file exists to ensure that one\n      doesn't accidently destroy another table.\n      Don't sync dir now if the data file has the same path.\n    */\n    create_flag=\n      (ci->data_file_name &&\n       !strcmp(ci->index_file_name, ci->data_file_name)) ? 0 : sync_dir;\n  }\n  else\n  {\n    char *iext= strrchr(name, '.');\n    int have_iext= iext && !strcmp(iext, MARIA_NAME_IEXT);\n    fn_format(kfilename, name, \"\", MARIA_NAME_IEXT, MY_UNPACK_FILENAME |\n              (internal_table ? 0 : MY_RETURN_REAL_PATH) |\n              (have_iext ? MY_REPLACE_EXT : MY_APPEND_EXT));\n    /*\n      Replace the current file.\n      Don't sync dir now if the data file has the same path.\n    */\n    create_flag=  (flags & HA_CREATE_KEEP_FILES) ? 0 : MY_DELETE_OLD;\n    create_flag|= (!ci->data_file_name ? 0 : sync_dir);\n  }\n\n  /*\n    If a MRG_MARIA table is in use, the mapped MARIA tables are open,\n    but no entry is made in the table cache for them.\n    A TRUNCATE command checks for the table in the cache only and could\n    be fooled to believe, the table is not open.\n    Pull the emergency brake in this situation. (Bug #8306)\n\n\n    NOTE: The filename is compared against unique_file_name of every\n    open table. Hence we need a real path here.\n  */\n  if (!internal_table && _ma_test_if_reopen(kfilename))\n  {\n    my_printf_error(HA_ERR_TABLE_EXIST, \"Aria table '%s' is in use \"\n                    \"(most likely by a MERGE table). Try FLUSH TABLES.\",\n                    MYF(0), name + dirname_length(name));\n    my_errno= HA_ERR_TABLE_EXIST;\n    goto err;\n  }\n\n  if ((file= mysql_file_create_with_symlink(key_file_kfile, klinkname_ptr,\n                                            kfilename, 0, create_mode,\n                                            MYF(MY_WME|create_flag))) < 0)\n    goto err;\n  errpos=1;\n\n  DBUG_PRINT(\"info\", (\"write state info and base info\"));\n  if (_ma_state_info_write_sub(file, &share.state,\n                               MA_STATE_INFO_WRITE_FULL_INFO) ||\n      _ma_base_info_write(file, &share.base))\n    goto err;\n  DBUG_PRINT(\"info\", (\"base_pos: %d  base_info_size: %d\",\n                      base_pos, MARIA_BASE_INFO_SIZE));\n  DBUG_ASSERT(mysql_file_tell(file,MYF(0)) == base_pos+ MARIA_BASE_INFO_SIZE);\n\n  /* Write key and keyseg definitions */\n  DBUG_PRINT(\"info\", (\"write key and keyseg definitions\"));\n  for (i=0 ; i < share.base.keys - uniques; i++)\n  {\n    uint sp_segs=(keydefs[i].flag & HA_SPATIAL) ? 2*SPDIMS : 0;\n\n    if (_ma_keydef_write(file, &keydefs[i]))\n      goto err;\n    for (j=0 ; j < keydefs[i].keysegs-sp_segs ; j++)\n      if (_ma_keyseg_write(file, &keydefs[i].seg[j]))\n       goto err;\n#ifdef HAVE_SPATIAL\n    for (j=0 ; j < sp_segs ; j++)\n    {\n      HA_KEYSEG sseg;\n      sseg.type=SPTYPE;\n      sseg.language= 7;                         /* Binary */\n      sseg.null_bit=0;\n      sseg.bit_start=0;\n      sseg.bit_length= 0;\n      sseg.bit_pos= 0;\n      sseg.length=SPLEN;\n      sseg.null_pos=0;\n      sseg.start=j*SPLEN;\n      sseg.flag= HA_SWAP_KEY;\n      if (_ma_keyseg_write(file, &sseg))\n        goto err;\n    }\n#endif\n  }\n  /* Create extra keys for unique definitions */\n  offset= real_reclength - uniques*MARIA_UNIQUE_HASH_LENGTH;\n  bzero((char*) &tmp_keydef,sizeof(tmp_keydef));\n  bzero((char*) &tmp_keyseg,sizeof(tmp_keyseg));\n  for (i=0; i < uniques ; i++)\n  {\n    tmp_keydef.keysegs=1;\n    tmp_keydef.flag=\t\tHA_UNIQUE_CHECK;\n    tmp_keydef.block_length=\t(uint16) maria_block_size;\n    tmp_keydef.keylength=\tMARIA_UNIQUE_HASH_LENGTH + pointer;\n    tmp_keydef.minlength=tmp_keydef.maxlength=tmp_keydef.keylength;\n    tmp_keyseg.type=\t\tMARIA_UNIQUE_HASH_TYPE;\n    tmp_keyseg.length=\t\tMARIA_UNIQUE_HASH_LENGTH;\n    tmp_keyseg.start=\t\toffset;\n    offset+=\t\t\tMARIA_UNIQUE_HASH_LENGTH;\n    if (_ma_keydef_write(file,&tmp_keydef) ||\n\t_ma_keyseg_write(file,(&tmp_keyseg)))\n      goto err;\n  }\n\n  /* Save unique definition */\n  DBUG_PRINT(\"info\", (\"write unique definitions\"));\n  for (i=0 ; i < share.state.header.uniques ; i++)\n  {\n    HA_KEYSEG *keyseg_end;\n    keyseg= uniquedefs[i].seg;\n    if (_ma_uniquedef_write(file, &uniquedefs[i]))\n      goto err;\n    for (keyseg= uniquedefs[i].seg, keyseg_end= keyseg+ uniquedefs[i].keysegs;\n         keyseg < keyseg_end;\n         keyseg++)\n    {\n      switch (keyseg->type) {\n      case HA_KEYTYPE_VARTEXT1:\n      case HA_KEYTYPE_VARTEXT2:\n      case HA_KEYTYPE_VARBINARY1:\n      case HA_KEYTYPE_VARBINARY2:\n        if (!(keyseg->flag & HA_BLOB_PART))\n        {\n          keyseg->flag|= HA_VAR_LENGTH_PART;\n          keyseg->bit_start= ((keyseg->type == HA_KEYTYPE_VARTEXT1 ||\n                               keyseg->type == HA_KEYTYPE_VARBINARY1) ?\n                              1 : 2);\n        }\n        break;\n      default:\n        DBUG_ASSERT((keyseg->flag & HA_VAR_LENGTH_PART) == 0);\n        break;\n      }\n      if (_ma_keyseg_write(file, keyseg))\n\tgoto err;\n    }\n  }\n  DBUG_PRINT(\"info\", (\"write field definitions\"));\n  if (datafile_type == BLOCK_RECORD)\n  {\n    /* Store columns in a more efficent order */\n    MARIA_COLUMNDEF **col_order, **pos;\n    if (!(col_order= (MARIA_COLUMNDEF**) my_malloc(share.base.fields *\n                                                   sizeof(MARIA_COLUMNDEF*),\n                                                   MYF(MY_WME))))\n      goto err;\n    for (column= columndef, pos= col_order ;\n         column != end_column ;\n         column++, pos++)\n      *pos= column;\n    qsort(col_order, share.base.fields, sizeof(*col_order),\n          (qsort_cmp) compare_columns);\n    for (i=0 ; i < share.base.fields ; i++)\n    {\n      column_array[col_order[i]->column_nr]= i;\n      if (_ma_columndef_write(file, col_order[i]))\n      {\n        my_free(col_order);\n        goto err;\n      }\n    }\n    my_free(col_order);\n  }\n  else\n  {\n    for (i=0 ; i < share.base.fields ; i++)\n    {\n      column_array[i]= (uint16) i;\n      if (_ma_columndef_write(file, &columndef[i]))\n        goto err;\n    }\n  }\n  if (_ma_column_nr_write(file, column_array, columns))\n    goto err;\n\n  if (encrypted)\n  {\n    if (ma_crypt_create(&share) ||\n        ma_crypt_write(&share, file))\n      goto err;\n  }\n\n  if ((kfile_size_before_extension= mysql_file_tell(file,MYF(0))) == MY_FILEPOS_ERROR)\n    goto err;\n#ifndef DBUG_OFF\n  if (kfile_size_before_extension != info_length)\n    DBUG_PRINT(\"warning\",(\"info_length: %u  != used_length: %u\",\n\t\t\t  info_length, (uint)kfile_size_before_extension));\n#endif\n\n  if (sync_dir)\n  {\n    /*\n      we log the first bytes and then the size to which we extend; this is\n      not log 1 KB of mostly zeroes if this is a small table.\n    */\n    char empty_string[]= \"\";\n    LEX_CUSTRING log_array[TRANSLOG_INTERNAL_PARTS + 4];\n    translog_size_t total_rec_length= 0;\n    uint k;\n    LSN lsn;\n    log_array[TRANSLOG_INTERNAL_PARTS + 1].length= 1 + 2 + 2 +\n      (uint) kfile_size_before_extension;\n    /* we are needing maybe 64 kB, so don't use the stack */\n    log_data= my_malloc(log_array[TRANSLOG_INTERNAL_PARTS + 1].length, MYF(0));\n    if ((log_data == NULL) ||\n        mysql_file_pread(file, 1 + 2 + 2 + log_data,\n                 (size_t) kfile_size_before_extension, 0, MYF(MY_NABP)))\n      goto err;\n    /*\n      remember if the data file was created or not, to know if Recovery can\n      do it or not, in the future\n    */\n    log_data[0]= MY_TEST(flags & HA_DONT_TOUCH_DATA);\n    int2store(log_data + 1, kfile_size_before_extension);\n    int2store(log_data + 1 + 2, share.base.keystart);\n    log_array[TRANSLOG_INTERNAL_PARTS + 0].str= (uchar *)name;\n    /* we store the end-zero, for Recovery to just pass it to my_create() */\n    log_array[TRANSLOG_INTERNAL_PARTS + 0].length= strlen(name) + 1;\n    log_array[TRANSLOG_INTERNAL_PARTS + 1].str= log_data;\n    /* symlink description is also needed for re-creation by Recovery: */\n    {\n      const char *s= ci->data_file_name ? ci->data_file_name : empty_string;\n      log_array[TRANSLOG_INTERNAL_PARTS + 2].str= (uchar*)s;\n      log_array[TRANSLOG_INTERNAL_PARTS + 2].length= strlen(s) + 1;\n      s= ci->index_file_name ? ci->index_file_name : empty_string;\n      log_array[TRANSLOG_INTERNAL_PARTS + 3].str= (uchar*)s;\n      log_array[TRANSLOG_INTERNAL_PARTS + 3].length= strlen(s) + 1;\n    }\n    for (k= TRANSLOG_INTERNAL_PARTS;\n         k < (sizeof(log_array)/sizeof(log_array[0])); k++)\n      total_rec_length+= (translog_size_t) log_array[k].length;\n    /**\n       For this record to be of any use for Recovery, we need the upper\n       MySQL layer to be crash-safe, which it is not now (that would require\n       work using the ddl_log of sql/sql_table.cc); when it is, we should\n       reconsider the moment of writing this log record (before or after op,\n       under THR_LOCK_maria or not...), how to use it in Recovery.\n       For now this record can serve when we apply logs to a backup,\n       so we sync it. This happens before the data file is created. If the\n       data file was created before, and we crashed before writing the log\n       record, at restart the table may be used, so we would not have a\n       trustable history in the log (impossible to apply this log to a\n       backup). The way we do it, if we crash before writing the log record\n       then there is no data file and the table cannot be used.\n       @todo Note that in case of TRUNCATE TABLE we also come here; for\n       Recovery to be able to finish TRUNCATE TABLE, instead of leaving a\n       half-truncated table, we should log the record at start of\n       maria_create(); for that we shouldn't write to the index file but to a\n       buffer (DYNAMIC_STRING), put the buffer into the record, then put the\n       buffer into the index file (so, change _ma_keydef_write() etc). That\n       would also enable Recovery to finish a CREATE TABLE. The final result\n       would be that we would be able to finish what the SQL layer has asked\n       for: it would be atomic.\n       When in CREATE/TRUNCATE (or DROP or RENAME or REPAIR) we have not\n       called external_lock(), so have no TRN. It does not matter, as all\n       these operations are non-transactional and sync their files.\n    */\n    if (unlikely(translog_write_record(&lsn,\n                                       LOGREC_REDO_CREATE_TABLE,\n                                       &dummy_transaction_object, NULL,\n                                       total_rec_length,\n                                       sizeof(log_array)/sizeof(log_array[0]),\n                                       log_array, NULL, NULL) ||\n                 translog_flush(lsn)))\n      goto err;\n    share.kfile.file= file;\n    DBUG_EXECUTE_IF(\"maria_flush_whole_log\",\n                    {\n                      DBUG_PRINT(\"maria_flush_whole_log\", (\"now\"));\n                      translog_flush(translog_get_horizon());\n                    });\n    DBUG_EXECUTE_IF(\"maria_crash_create_table\",\n                    {\n                      DBUG_PRINT(\"maria_crash_create_table\", (\"now\"));\n                      DBUG_ABORT();\n                    });\n    /*\n      store LSN into file, needed for Recovery to not be confused if a\n      DROP+CREATE happened (applying REDOs to the wrong table).\n    */\n    if (_ma_update_state_lsns_sub(&share, lsn, trnman_get_min_safe_trid(),\n                                  FALSE, TRUE))\n      goto err;\n    my_free(log_data);\n  }\n\n  if (!(flags & HA_DONT_TOUCH_DATA))\n  {\n    if (ci->data_file_name)\n    {\n      char *dext= strrchr(ci->data_file_name, '.');\n      int have_dext= dext && !strcmp(dext, MARIA_NAME_DEXT);\n\n      if (tmp_table)\n      {\n        char *path;\n        /* chop off the table name, tempory tables use generated name */\n        if ((path= strrchr(ci->data_file_name, FN_LIBCHAR)))\n          *path= '\\0';\n        fn_format(dfilename, name, ci->data_file_name, MARIA_NAME_DEXT,\n                  MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_APPEND_EXT);\n      }\n      else\n      {\n        fn_format(dfilename, ci->data_file_name, \"\", MARIA_NAME_DEXT,\n                  MY_UNPACK_FILENAME |\n                  (have_dext ? MY_REPLACE_EXT : MY_APPEND_EXT));\n      }\n      fn_format(dlinkname, name, \"\",MARIA_NAME_DEXT,\n                MY_UNPACK_FILENAME | MY_APPEND_EXT);\n      dlinkname_ptr= dlinkname;\n      create_flag=0;\n    }\n    else\n    {\n      fn_format(dfilename,name,\"\", MARIA_NAME_DEXT,\n                MY_UNPACK_FILENAME | MY_APPEND_EXT);\n      create_flag= (flags & HA_CREATE_KEEP_FILES) ? 0 : MY_DELETE_OLD;\n    }\n    if ((dfile=\n         mysql_file_create_with_symlink(key_file_dfile, dlinkname_ptr,\n                                        dfilename, 0, create_mode,\n                                        MYF(MY_WME | create_flag | sync_dir))) < 0)\n      goto err;\n    errpos=3;\n\n    if (_ma_initialize_data_file(&share, dfile))\n      goto err;\n  }\n\n\t/* Enlarge files */\n  DBUG_PRINT(\"info\", (\"enlarge to keystart: %lu\",\n                      (ulong) share.base.keystart));\n  if (mysql_file_chsize(file,(ulong) share.base.keystart,0,MYF(0)))\n    goto err;\n\n  if (!internal_table && sync_dir && mysql_file_sync(file, MYF(0)))\n    goto err;\n\n  if (! (flags & HA_DONT_TOUCH_DATA))\n  {\n#ifdef USE_RELOC\n    if (mysql_file_chsize(key_file_dfile, dfile,\n                          share.base.min_pack_length*ci->reloc_rows,0,MYF(0)))\n      goto err;\n#endif\n    if (!internal_table && sync_dir && mysql_file_sync(dfile, MYF(0)))\n      goto err;\n    if (mysql_file_close(dfile,MYF(0)))\n      goto err;\n  }\n  if (!internal_table)\n    mysql_mutex_unlock(&THR_LOCK_maria);\n  res= 0;\n  my_free((char*) rec_per_key_part);\n  ma_crypt_free(&share);\n  errpos=0;\n  if (mysql_file_close(file,MYF(0)))\n    res= my_errno;\n  DBUG_RETURN(res);\n\nerr:\n  if (!internal_table)\n    mysql_mutex_unlock(&THR_LOCK_maria);\n\nerr_no_lock:\n  save_errno=my_errno;\n  switch (errpos) {\n  case 3:\n    mysql_file_close(dfile, MYF(0));\n    if (! (flags & HA_DONT_TOUCH_DATA))\n    {\n      mysql_file_delete(key_file_dfile, dfilename, MYF(sync_dir));\n      if (dlinkname_ptr)\n        mysql_file_delete(key_file_dfile, dlinkname_ptr, MYF(sync_dir));\n    }\n    /* fall through */\n  case 1:\n    mysql_file_close(file, MYF(0));\n    if (! (flags & HA_DONT_TOUCH_DATA))\n    {\n      mysql_file_delete(key_file_kfile, kfilename, MYF(sync_dir));\n      if (klinkname_ptr)\n        mysql_file_delete(key_file_kfile, klinkname_ptr, MYF(sync_dir));\n    }\n  }\n  ma_crypt_free(&share);\n  my_free(log_data);\n  my_free(rec_per_key_part);\n  DBUG_RETURN(my_errno=save_errno);\t\t/* return the fatal errno */\n}",
        "label": 0
    },
    {
        "pre_patch": "find_field_in_tables(THD *thd, Item_ident *item,\n                     TABLE_LIST *first_table, TABLE_LIST *last_table,\n\t\t     Item **ref, find_item_error_report_type report_error,\n                     bool check_privileges, bool register_tree_change)\n{\n  Field *found=0;\n  const char *db= item->db_name;\n  const char *table_name= item->table_name;\n  const char *name= item->field_name;\n  uint length=(uint) strlen(name);\n  char name_buff[SAFE_NAME_LEN+1];\n  TABLE_LIST *cur_table= first_table;\n  TABLE_LIST *actual_table;\n  bool allow_rowid;\n\n  if (!table_name || !table_name[0])\n  {\n    table_name= 0;                              // For easier test\n    db= 0;\n  }\n\n  allow_rowid= table_name || (cur_table && !cur_table->next_local);\n\n  if (item->cached_table)\n  {\n    DBUG_PRINT(\"info\", (\"using cached table\"));\n    /*\n      This shortcut is used by prepared statements. We assume that\n      TABLE_LIST *first_table is not changed during query execution (which\n      is true for all queries except RENAME but luckily RENAME doesn't\n      use fields...) so we can rely on reusing pointer to its member.\n      With this optimization we also miss case when addition of one more\n      field makes some prepared query ambiguous and so erroneous, but we\n      accept this trade off.\n    */\n    TABLE_LIST *table_ref= item->cached_table;\n    /*\n      The condition (table_ref->view == NULL) ensures that we will call\n      find_field_in_table even in the case of information schema tables\n      when table_ref->field_translation != NULL.\n      */\n    if (table_ref->table && !table_ref->view &&\n        (!table_ref->is_merged_derived() ||\n         (!table_ref->is_multitable() && table_ref->merged_for_insert)))\n    {\n\n      found= find_field_in_table(thd, table_ref->table, name, length,\n                                 TRUE, &(item->cached_field_index));\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n      /* Check if there are sufficient access rights to the found field. */\n      if (found && check_privileges && !is_temporary_table(table_ref) &&\n          check_column_grant_in_table_ref(thd, table_ref, name, length))\n        found= WRONG_GRANT;\n#endif\n    }\n    else\n      found= find_field_in_table_ref(thd, table_ref, name, length, item->name,\n                                     NULL, NULL, ref, check_privileges,\n                                     TRUE, &(item->cached_field_index),\n                                     register_tree_change,\n                                     &actual_table);\n    if (found)\n    {\n      if (found == WRONG_GRANT)\n\treturn (Field*) 0;\n\n      /*\n        Only views fields should be marked as dependent, not an underlying\n        fields.\n      */\n      if (!table_ref->belong_to_view &&\n          !table_ref->belong_to_derived)\n      {\n        SELECT_LEX *current_sel= item->context->select_lex;\n        SELECT_LEX *last_select= table_ref->select_lex;\n        bool all_merged= TRUE;\n        for (SELECT_LEX *sl= current_sel; sl && sl!=last_select;\n             sl=sl->outer_select())\n        {\n          Item *subs= sl->master_unit()->item;\n          if (!subs ||\n              (subs->type() == Item::SUBSELECT_ITEM &&\n               ((Item_subselect*)subs)->substype() == Item_subselect::IN_SUBS &&\n               ((Item_in_subselect*)subs)->test_strategy(SUBS_SEMI_JOIN)))\n          {\n            continue;\n          }\n          all_merged= FALSE;\n          break;\n        }\n        /*\n          If the field was an outer referencee, mark all selects using this\n          sub query as dependent on the outer query\n        */\n        if (!all_merged && current_sel != last_select)\n        {\n          mark_select_range_as_dependent(thd, last_select, current_sel,\n                                         found, *ref, item, true);\n        }\n      }\n      return found;\n    }\n  }\n  else\n    item->can_be_depended= TRUE;\n\n  if (db && lower_case_table_names)\n  {\n    /*\n      convert database to lower case for comparison.\n      We can't do this in Item_field as this would change the\n      'name' of the item which may be used in the select list\n    */\n    strmake_buf(name_buff, db);\n    my_casedn_str(files_charset_info, name_buff);\n    db= name_buff;\n  }\n\n  if (last_table)\n    last_table= last_table->next_name_resolution_table;\n\n  for (; cur_table != last_table ;\n       cur_table= cur_table->next_name_resolution_table)\n  {\n    Field *cur_field= find_field_in_table_ref(thd, cur_table, name, length,\n                                              item->name, db, table_name, ref,\n                                              (thd->lex->sql_command ==\n                                               SQLCOM_SHOW_FIELDS)\n                                              ? false : check_privileges,\n                                              allow_rowid,\n                                              &(item->cached_field_index),\n                                              register_tree_change,\n                                              &actual_table);\n    if (cur_field)\n    {\n      if (cur_field == WRONG_GRANT)\n      {\n        if (thd->lex->sql_command != SQLCOM_SHOW_FIELDS)\n          return (Field*) 0;\n\n        thd->clear_error();\n        cur_field= find_field_in_table_ref(thd, cur_table, name, length,\n                                           item->name, db, table_name, ref,\n                                           false,\n                                           allow_rowid,\n                                           &(item->cached_field_index),\n                                           register_tree_change,\n                                           &actual_table);\n        if (cur_field)\n        {\n          Field *nf=new Field_null(NULL,0,Field::NONE,\n                                   cur_field->field_name,\n                                   &my_charset_bin);\n          nf->init(cur_table->table);\n          cur_field= nf;\n        }\n      }\n\n      /*\n        Store the original table of the field, which may be different from\n        cur_table in the case of NATURAL/USING join.\n      */\n      item->cached_table= (!actual_table->cacheable_table || found) ?\n                          0 : actual_table;\n\n      DBUG_ASSERT(thd->where);\n      /*\n        If we found a fully qualified field we return it directly as it can't\n        have duplicates.\n       */\n      if (db)\n        return cur_field;\n      \n      if (found)\n      {\n        if (report_error == REPORT_ALL_ERRORS ||\n            report_error == IGNORE_EXCEPT_NON_UNIQUE)\n          my_error(ER_NON_UNIQ_ERROR, MYF(0),\n                   table_name ? item->full_name() : name, thd->where);\n        return (Field*) 0;\n      }\n      found= cur_field;\n    }\n  }\n\n  if (found)\n    return found;\n  \n  /*\n    If the field was qualified and there were no tables to search, issue\n    an error that an unknown table was given. The situation is detected\n    as follows: if there were no tables we wouldn't go through the loop\n    and cur_table wouldn't be updated by the loop increment part, so it\n    will be equal to the first table.\n  */\n  if (table_name && (cur_table == first_table) &&\n      (report_error == REPORT_ALL_ERRORS ||\n       report_error == REPORT_EXCEPT_NON_UNIQUE))\n  {\n    char buff[SAFE_NAME_LEN*2 + 2];\n    if (db && db[0])\n    {\n      strxnmov(buff,sizeof(buff)-1,db,\".\",table_name,NullS);\n      table_name=buff;\n    }\n    my_error(ER_UNKNOWN_TABLE, MYF(0), table_name, thd->where);\n  }\n  else\n  {\n    if (report_error == REPORT_ALL_ERRORS ||\n        report_error == REPORT_EXCEPT_NON_UNIQUE)\n      my_error(ER_BAD_FIELD_ERROR, MYF(0), item->full_name(), thd->where);\n    else\n      found= not_found_field;\n  }\n  return found;\n}",
        "post_patch": "find_field_in_tables(THD *thd, Item_ident *item,\n                     TABLE_LIST *first_table, TABLE_LIST *last_table,\n\t\t     Item **ref, find_item_error_report_type report_error,\n                     bool check_privileges, bool register_tree_change)\n{\n  Field *found=0;\n  const char *db= item->db_name;\n  const char *table_name= item->table_name;\n  const char *name= item->field_name;\n  uint length=(uint) strlen(name);\n  char name_buff[SAFE_NAME_LEN+1];\n  TABLE_LIST *cur_table= first_table;\n  TABLE_LIST *actual_table;\n  bool allow_rowid;\n\n  if (!table_name || !table_name[0])\n  {\n    table_name= 0;                              // For easier test\n    db= 0;\n  }\n\n  allow_rowid= table_name || (cur_table && !cur_table->next_local);\n\n  if (item->cached_table)\n  {\n    DBUG_PRINT(\"info\", (\"using cached table\"));\n    /*\n      This shortcut is used by prepared statements. We assume that\n      TABLE_LIST *first_table is not changed during query execution (which\n      is true for all queries except RENAME but luckily RENAME doesn't\n      use fields...) so we can rely on reusing pointer to its member.\n      With this optimization we also miss case when addition of one more\n      field makes some prepared query ambiguous and so erroneous, but we\n      accept this trade off.\n    */\n    TABLE_LIST *table_ref= item->cached_table;\n    /*\n      The condition (table_ref->view == NULL) ensures that we will call\n      find_field_in_table even in the case of information schema tables\n      when table_ref->field_translation != NULL.\n      */\n    if (table_ref->table && !table_ref->view &&\n        (!table_ref->is_merged_derived() ||\n         (!table_ref->is_multitable() && table_ref->merged_for_insert)))\n    {\n\n      found= find_field_in_table(thd, table_ref->table, name, length,\n                                 TRUE, &(item->cached_field_index));\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n      /* Check if there are sufficient access rights to the found field. */\n      if (found && check_privileges && !is_temporary_table(table_ref) &&\n          check_column_grant_in_table_ref(thd, table_ref, name, length))\n        found= WRONG_GRANT;\n#endif\n    }\n    else\n      found= find_field_in_table_ref(thd, table_ref, name, length, item->name,\n                                     NULL, NULL, ref, check_privileges,\n                                     TRUE, &(item->cached_field_index),\n                                     register_tree_change,\n                                     &actual_table);\n    if (found)\n    {\n      if (found == WRONG_GRANT)\n\treturn (Field*) 0;\n\n      /*\n        Only views fields should be marked as dependent, not an underlying\n        fields.\n      */\n      if (!table_ref->belong_to_view &&\n          !table_ref->belong_to_derived)\n      {\n        SELECT_LEX *current_sel= item->context->select_lex;\n        SELECT_LEX *last_select= table_ref->select_lex;\n        bool all_merged= TRUE;\n        for (SELECT_LEX *sl= current_sel; sl && sl!=last_select;\n             sl=sl->outer_select())\n        {\n          Item *subs= sl->master_unit()->item;\n          if (!subs ||\n              (subs->type() == Item::SUBSELECT_ITEM &&\n               ((Item_subselect*)subs)->substype() == Item_subselect::IN_SUBS &&\n               ((Item_in_subselect*)subs)->test_strategy(SUBS_SEMI_JOIN)))\n          {\n            continue;\n          }\n          all_merged= FALSE;\n          break;\n        }\n        /*\n          If the field was an outer referencee, mark all selects using this\n          sub query as dependent on the outer query\n        */\n        if (!all_merged && current_sel != last_select)\n        {\n          mark_select_range_as_dependent(thd, last_select, current_sel,\n                                         found, *ref, item, true);\n        }\n      }\n      return found;\n    }\n  }\n  else\n    item->can_be_depended= TRUE;\n\n  if (db && lower_case_table_names)\n  {\n    /*\n      convert database to lower case for comparison.\n      We can't do this in Item_field as this would change the\n      'name' of the item which may be used in the select list\n    */\n    strmake_buf(name_buff, db);\n    my_casedn_str(files_charset_info, name_buff);\n    db= name_buff;\n  }\n\n  if (last_table)\n    last_table= last_table->next_name_resolution_table;\n\n  for (; cur_table != last_table ;\n       cur_table= cur_table->next_name_resolution_table)\n  {\n    Field *cur_field= find_field_in_table_ref(thd, cur_table, name, length,\n                                              item->name, db, table_name, ref,\n                                              (thd->lex->sql_command ==\n                                               SQLCOM_SHOW_FIELDS)\n                                              ? false : check_privileges,\n                                              allow_rowid,\n                                              &(item->cached_field_index),\n                                              register_tree_change,\n                                              &actual_table);\n    if (cur_field)\n    {\n      if (cur_field == WRONG_GRANT)\n      {\n        if (thd->lex->sql_command != SQLCOM_SHOW_FIELDS)\n          return (Field*) 0;\n\n        thd->clear_error();\n        cur_field= find_field_in_table_ref(thd, cur_table, name, length,\n                                           item->name, db, table_name, ref,\n                                           false,\n                                           allow_rowid,\n                                           &(item->cached_field_index),\n                                           register_tree_change,\n                                           &actual_table);\n        if (cur_field)\n        {\n          Field *nf=new Field_null(NULL,0,Field::NONE,\n                                   cur_field->field_name,\n                                   &my_charset_bin);\n          nf->init(cur_table->table);\n          cur_field= nf;\n        }\n      }\n\n      /*\n        Store the original table of the field, which may be different from\n        cur_table in the case of NATURAL/USING join.\n      */\n      item->cached_table= (!actual_table->cacheable_table || found) ?\n                          0 : actual_table;\n\n      DBUG_ASSERT(thd->where);\n      /*\n        If we found a fully qualified field we return it directly as it can't\n        have duplicates.\n       */\n      if (db)\n        return cur_field;\n      \n      if (found)\n      {\n        if (report_error == REPORT_ALL_ERRORS ||\n            report_error == IGNORE_EXCEPT_NON_UNIQUE)\n          my_error(ER_NON_UNIQ_ERROR, MYF(0),\n                   table_name ? item->full_name() : name, thd->where);\n        return (Field*) 0;\n      }\n      found= cur_field;\n    }\n  }\n\n  if (found)\n    return found;\n  \n  /*\n    If the field was qualified and there were no tables to search, issue\n    an error that an unknown table was given. The situation is detected\n    as follows: if there were no tables we wouldn't go through the loop\n    and cur_table wouldn't be updated by the loop increment part, so it\n    will be equal to the first table.\n  */\n  if (table_name && (cur_table == first_table) &&\n      (report_error == REPORT_ALL_ERRORS ||\n       report_error == REPORT_EXCEPT_NON_UNIQUE))\n  {\n    char buff[SAFE_NAME_LEN*2 + 2];\n    if (db && db[0])\n    {\n      strxnmov(buff,sizeof(buff)-1,db,\".\",table_name,NullS);\n      table_name=buff;\n    }\n    my_error(ER_UNKNOWN_TABLE, MYF(0), table_name, thd->where);\n  }\n  else\n  {\n    if (report_error == REPORT_ALL_ERRORS ||\n        report_error == REPORT_EXCEPT_NON_UNIQUE)\n      my_error(ER_BAD_FIELD_ERROR, MYF(0), item->full_name(), thd->where);\n    else\n      found= not_found_field;\n  }\n  return found;\n}",
        "label": 0
    },
    {
        "pre_patch": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (params->order == NULL\n            || params->base == NULL\n            || params->base->data == NULL\n            || params->base->length == 0) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}",
        "post_patch": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (params->order == NULL\n            || params->base == NULL\n            || params->base->data == NULL\n            || params->base->length == 0) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}",
        "label": 0
    },
    {
        "pre_patch": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    ADD_TEST(test_GENERAL_NAME_cmp);\n    return 1;\n}",
        "post_patch": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    ADD_TEST(test_GENERAL_NAME_cmp);\n    return 1;\n}",
        "label": 0
    },
    {
        "pre_patch": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\n\tif (p > end)\n\t\treturn 0;\n\n\tlen = *p++;\n\tif (p + len > end || len == 0)\n\t\treturn 0;\n\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\n\t*data += 1 + len;\n\n\treturn len;\n}",
        "post_patch": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\n\tif (p > end)\n\t\treturn 0;\n\n\tlen = *p++;\n\tif (p + len > end || len == 0)\n\t\treturn 0;\n\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\n\t*data += 1 + len;\n\n\treturn len;\n}",
        "label": 0
    },
    {
        "pre_patch": "static int smtp_command_parse_parameters(struct smtp_command_parser *parser)\n{\n\tconst unsigned char *p, *mp;\n\tuoff_t max_size = (parser->auth_response ?\n\t\tparser->limits.max_auth_size :\n\t\tparser->limits.max_parameters_size);\n\tint nch = 1;\n\n\t/* We assume parameters to match textstr (HT, SP, Printable US-ASCII).\n\t   For command parameters, we also accept valid UTF-8 characters.\n\t */\n\tp = parser->cur + parser->state.poff;\n\twhile (p < parser->end) {\n\t\tunichar_t ch;\n\n\t\tif (parser->auth_response)\n\t\t\tch = *p;\n\t\telse {\n\t\t\tnch = uni_utf8_get_char_n(p, (size_t)(p - parser->end),\n\t\t\t\t\t\t  &ch);\n\t\t}\n\t\tif (nch == 0)\n\t\t\tbreak;\n\t\tif (nch < 0) {\n\t\t\tsmtp_command_parser_error(parser,\n\t\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\t\"Invalid UTF-8 character in command parameters\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ((parser->auth_response || (ch & 0x80) == 0x00) &&\n\t\t    !smtp_char_is_textstr((unsigned char)ch))\n\t\t\tbreak;\n\t\tp += nch;\n\t}\n\tif (max_size > 0 && (uoff_t)(p - parser->cur) > max_size) {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG,\n\t\t\t\"%s line is too long\",\n\t\t\t(parser->auth_response ?\n\t\t\t\t\"AUTH response\" : \"Command\"));\n\t\treturn -1;\n\t}\n\tparser->state.poff = p - parser->cur;\n\tif (p == parser->end || nch == 0)\n\t\treturn 0;\n\n\t/* In the interest of improved interoperability, SMTP receivers SHOULD\n\t   tolerate trailing white space before the terminating <CRLF>.\n\n\t   WSP =  SP / HTAB ; white space\n\n\t   --> Trim the end of the buffer\n\t */\n\tmp = p;\n\tif (mp > parser->cur) {\n\t\twhile (mp > parser->cur && (*(mp-1) == ' ' || *(mp-1) == '\\t'))\n\t\t\tmp--;\n\t}\n\n\tif (!parser->auth_response && mp > parser->cur && *parser->cur == ' ') {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\"Duplicate space after command name\");\n\t\treturn -1;\n\t}\n\n\tparser->state.cmd_params = i_strdup_until(parser->cur, mp);\n\tparser->cur = p;\n\tparser->state.poff = 0;\n\treturn 1;\n}",
        "post_patch": "static int smtp_command_parse_parameters(struct smtp_command_parser *parser)\n{\n\tconst unsigned char *p, *mp;\n\tuoff_t max_size = (parser->auth_response ?\n\t\tparser->limits.max_auth_size :\n\t\tparser->limits.max_parameters_size);\n\tint nch = 1;\n\n\t/* We assume parameters to match textstr (HT, SP, Printable US-ASCII).\n\t   For command parameters, we also accept valid UTF-8 characters.\n\t */\n\tp = parser->cur + parser->state.poff;\n\twhile (p < parser->end) {\n\t\tunichar_t ch;\n\n\t\tif (parser->auth_response)\n\t\t\tch = *p;\n\t\telse {\n\t\t\tnch = uni_utf8_get_char_n(p, (size_t)(p - parser->end),\n\t\t\t\t\t\t  &ch);\n\t\t}\n\t\tif (nch == 0)\n\t\t\tbreak;\n\t\tif (nch < 0) {\n\t\t\tsmtp_command_parser_error(parser,\n\t\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\t\"Invalid UTF-8 character in command parameters\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ((parser->auth_response || (ch & 0x80) == 0x00) &&\n\t\t    !smtp_char_is_textstr((unsigned char)ch))\n\t\t\tbreak;\n\t\tp += nch;\n\t}\n\tif (max_size > 0 && (uoff_t)(p - parser->cur) > max_size) {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG,\n\t\t\t\"%s line is too long\",\n\t\t\t(parser->auth_response ?\n\t\t\t\t\"AUTH response\" : \"Command\"));\n\t\treturn -1;\n\t}\n\tparser->state.poff = p - parser->cur;\n\tif (p == parser->end || nch == 0)\n\t\treturn 0;\n\n\t/* In the interest of improved interoperability, SMTP receivers SHOULD\n\t   tolerate trailing white space before the terminating <CRLF>.\n\n\t   WSP =  SP / HTAB ; white space\n\n\t   --> Trim the end of the buffer\n\t */\n\tmp = p;\n\tif (mp > parser->cur) {\n\t\twhile (mp > parser->cur && (*(mp-1) == ' ' || *(mp-1) == '\\t'))\n\t\t\tmp--;\n\t}\n\n\tif (!parser->auth_response && mp > parser->cur && *parser->cur == ' ') {\n\t\tsmtp_command_parser_error(parser,\n\t\t\tSMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,\n\t\t\t\"Duplicate space after command name\");\n\t\treturn -1;\n\t}\n\n\tparser->state.cmd_params = i_strdup_until(parser->cur, mp);\n\tparser->cur = p;\n\tparser->state.poff = 0;\n\treturn 1;\n}",
        "label": 0
    },
    {
        "pre_patch": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
        "post_patch": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
        "label": 0
    },
    {
        "pre_patch": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "post_patch": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "label": 0
    },
    {
        "pre_patch": "auth_request_get_var_expand_table_full(const struct auth_request *auth_request,\n\t\t\t\t       auth_request_escape_func_t *escape_func,\n\t\t\t\t       unsigned int *count)\n{\n\tconst unsigned int auth_count =\n\t\tN_ELEMENTS(auth_request_var_expand_static_tab);\n\tstruct var_expand_table *tab, *ret_tab;\n\tconst char *orig_user, *auth_user, *username;\n\n\tif (escape_func == NULL)\n\t\tescape_func = escape_none;\n\n\t/* keep the extra fields at the beginning. the last static_tab field\n\t   contains the ending NULL-fields. */\n\ttab = ret_tab = t_malloc((*count + auth_count) * sizeof(*tab));\n\tmemset(tab, 0, *count * sizeof(*tab));\n\ttab += *count;\n\t*count += auth_count;\n\n\tmemcpy(tab, auth_request_var_expand_static_tab,\n\t       auth_count * sizeof(*tab));\n\n\tusername = auth_request->user != NULL ? auth_request->user : \"\";\n\ttab[0].value = escape_func(username, auth_request);\n\ttab[1].value = escape_func(t_strcut(username, '@'),\n\t\t\t\t   auth_request);\n\ttab[2].value = strchr(username, '@');\n\tif (tab[2].value != NULL)\n\t\ttab[2].value = escape_func(tab[2].value+1, auth_request);\n\ttab[3].value = escape_func(auth_request->service, auth_request);\n\t/* tab[4] = we have no home dir */\n\tif (auth_request->local_ip.family != 0)\n\t\ttab[5].value = net_ip2addr(&auth_request->local_ip);\n\tif (auth_request->remote_ip.family != 0)\n\t\ttab[6].value = net_ip2addr(&auth_request->remote_ip);\n\ttab[7].value = dec2str(auth_request->client_pid);\n\tif (auth_request->mech_password != NULL) {\n\t\ttab[8].value = escape_func(auth_request->mech_password,\n\t\t\t\t\t   auth_request);\n\t}\n\tif (auth_request->userdb_lookup) {\n\t\ttab[9].value = auth_request->userdb == NULL ? \"\" :\n\t\t\tdec2str(auth_request->userdb->userdb->id);\n\t} else {\n\t\ttab[9].value = auth_request->passdb == NULL ? \"\" :\n\t\t\tdec2str(auth_request->passdb->passdb->id);\n\t}\n\ttab[10].value = auth_request->mech_name == NULL ? \"\" :\n\t\tescape_func(auth_request->mech_name, auth_request);\n\ttab[11].value = auth_request->secured ? \"secured\" : \"\";\n\ttab[12].value = dec2str(auth_request->local_port);\n\ttab[13].value = dec2str(auth_request->remote_port);\n\ttab[14].value = auth_request->valid_client_cert ? \"valid\" : \"\";\n\n\tif (auth_request->requested_login_user != NULL) {\n\t\tconst char *login_user = auth_request->requested_login_user;\n\n\t\ttab[15].value = escape_func(login_user, auth_request);\n\t\ttab[16].value = escape_func(t_strcut(login_user, '@'),\n\t\t\t\t\t    auth_request);\n\t\ttab[17].value = strchr(login_user, '@');\n\t\tif (tab[17].value != NULL) {\n\t\t\ttab[17].value = escape_func(tab[17].value+1,\n\t\t\t\t\t\t    auth_request);\n\t\t}\n\t}\n\ttab[18].value = auth_request->session_id == NULL ? NULL :\n\t\tescape_func(auth_request->session_id, auth_request);\n\tif (auth_request->real_local_ip.family != 0)\n\t\ttab[19].value = net_ip2addr(&auth_request->real_local_ip);\n\tif (auth_request->real_remote_ip.family != 0)\n\t\ttab[20].value = net_ip2addr(&auth_request->real_remote_ip);\n\ttab[21].value = dec2str(auth_request->real_local_port);\n\ttab[22].value = dec2str(auth_request->real_remote_port);\n\ttab[23].value = strchr(username, '@');\n\tif (tab[23].value != NULL) {\n\t\ttab[23].value = escape_func(t_strcut(tab[23].value+1, '@'),\n\t\t\t\t\t    auth_request);\n\t}\n\ttab[24].value = strrchr(username, '@');\n\tif (tab[24].value != NULL)\n\t\ttab[24].value = escape_func(tab[24].value+1, auth_request);\n\ttab[25].value = auth_request->master_user == NULL ? NULL :\n\t\tescape_func(auth_request->master_user, auth_request);\n\ttab[26].value = auth_request->session_pid == (pid_t)-1 ? NULL :\n\t\tdec2str(auth_request->session_pid);\n\n\torig_user = auth_request->original_username != NULL ?\n\t\tauth_request->original_username : username;\n\ttab[27].value = escape_func(orig_user, auth_request);\n\ttab[28].value = escape_func(t_strcut(orig_user, '@'), auth_request);\n\ttab[29].value = strchr(orig_user, '@');\n\tif (tab[29].value != NULL)\n\t\ttab[29].value = escape_func(tab[29].value+1, auth_request);\n\n\tif (auth_request->master_user != NULL)\n\t\tauth_user = auth_request->master_user;\n\telse\n\t\tauth_user = orig_user;\n\ttab[30].value = escape_func(auth_user, auth_request);\n\ttab[31].value = escape_func(t_strcut(auth_user, '@'), auth_request);\n\ttab[32].value = strchr(auth_user, '@');\n\tif (tab[32].value != NULL)\n\t\ttab[32].value = escape_func(tab[32].value+1, auth_request);\n\tif (auth_request->local_name != NULL)\n\t\ttab[33].value = escape_func(auth_request->local_name, auth_request);\n\telse\n\t\ttab[33].value = \"\";\n\treturn ret_tab;\n}",
        "post_patch": "auth_request_get_var_expand_table_full(const struct auth_request *auth_request,\n\t\t\t\t       auth_request_escape_func_t *escape_func,\n\t\t\t\t       unsigned int *count)\n{\n\tconst unsigned int auth_count =\n\t\tN_ELEMENTS(auth_request_var_expand_static_tab);\n\tstruct var_expand_table *tab, *ret_tab;\n\tconst char *orig_user, *auth_user, *username;\n\n\tif (escape_func == NULL)\n\t\tescape_func = escape_none;\n\n\t/* keep the extra fields at the beginning. the last static_tab field\n\t   contains the ending NULL-fields. */\n\ttab = ret_tab = t_malloc((*count + auth_count) * sizeof(*tab));\n\tmemset(tab, 0, *count * sizeof(*tab));\n\ttab += *count;\n\t*count += auth_count;\n\n\tmemcpy(tab, auth_request_var_expand_static_tab,\n\t       auth_count * sizeof(*tab));\n\n\tusername = auth_request->user != NULL ? auth_request->user : \"\";\n\ttab[0].value = escape_func(username, auth_request);\n\ttab[1].value = escape_func(t_strcut(username, '@'),\n\t\t\t\t   auth_request);\n\ttab[2].value = strchr(username, '@');\n\tif (tab[2].value != NULL)\n\t\ttab[2].value = escape_func(tab[2].value+1, auth_request);\n\ttab[3].value = escape_func(auth_request->service, auth_request);\n\t/* tab[4] = we have no home dir */\n\tif (auth_request->local_ip.family != 0)\n\t\ttab[5].value = net_ip2addr(&auth_request->local_ip);\n\tif (auth_request->remote_ip.family != 0)\n\t\ttab[6].value = net_ip2addr(&auth_request->remote_ip);\n\ttab[7].value = dec2str(auth_request->client_pid);\n\tif (auth_request->mech_password != NULL) {\n\t\ttab[8].value = escape_func(auth_request->mech_password,\n\t\t\t\t\t   auth_request);\n\t}\n\tif (auth_request->userdb_lookup) {\n\t\ttab[9].value = auth_request->userdb == NULL ? \"\" :\n\t\t\tdec2str(auth_request->userdb->userdb->id);\n\t} else {\n\t\ttab[9].value = auth_request->passdb == NULL ? \"\" :\n\t\t\tdec2str(auth_request->passdb->passdb->id);\n\t}\n\ttab[10].value = auth_request->mech_name == NULL ? \"\" :\n\t\tescape_func(auth_request->mech_name, auth_request);\n\ttab[11].value = auth_request->secured ? \"secured\" : \"\";\n\ttab[12].value = dec2str(auth_request->local_port);\n\ttab[13].value = dec2str(auth_request->remote_port);\n\ttab[14].value = auth_request->valid_client_cert ? \"valid\" : \"\";\n\n\tif (auth_request->requested_login_user != NULL) {\n\t\tconst char *login_user = auth_request->requested_login_user;\n\n\t\ttab[15].value = escape_func(login_user, auth_request);\n\t\ttab[16].value = escape_func(t_strcut(login_user, '@'),\n\t\t\t\t\t    auth_request);\n\t\ttab[17].value = strchr(login_user, '@');\n\t\tif (tab[17].value != NULL) {\n\t\t\ttab[17].value = escape_func(tab[17].value+1,\n\t\t\t\t\t\t    auth_request);\n\t\t}\n\t}\n\ttab[18].value = auth_request->session_id == NULL ? NULL :\n\t\tescape_func(auth_request->session_id, auth_request);\n\tif (auth_request->real_local_ip.family != 0)\n\t\ttab[19].value = net_ip2addr(&auth_request->real_local_ip);\n\tif (auth_request->real_remote_ip.family != 0)\n\t\ttab[20].value = net_ip2addr(&auth_request->real_remote_ip);\n\ttab[21].value = dec2str(auth_request->real_local_port);\n\ttab[22].value = dec2str(auth_request->real_remote_port);\n\ttab[23].value = strchr(username, '@');\n\tif (tab[23].value != NULL) {\n\t\ttab[23].value = escape_func(t_strcut(tab[23].value+1, '@'),\n\t\t\t\t\t    auth_request);\n\t}\n\ttab[24].value = strrchr(username, '@');\n\tif (tab[24].value != NULL)\n\t\ttab[24].value = escape_func(tab[24].value+1, auth_request);\n\ttab[25].value = auth_request->master_user == NULL ? NULL :\n\t\tescape_func(auth_request->master_user, auth_request);\n\ttab[26].value = auth_request->session_pid == (pid_t)-1 ? NULL :\n\t\tdec2str(auth_request->session_pid);\n\n\torig_user = auth_request->original_username != NULL ?\n\t\tauth_request->original_username : username;\n\ttab[27].value = escape_func(orig_user, auth_request);\n\ttab[28].value = escape_func(t_strcut(orig_user, '@'), auth_request);\n\ttab[29].value = strchr(orig_user, '@');\n\tif (tab[29].value != NULL)\n\t\ttab[29].value = escape_func(tab[29].value+1, auth_request);\n\n\tif (auth_request->master_user != NULL)\n\t\tauth_user = auth_request->master_user;\n\telse\n\t\tauth_user = orig_user;\n\ttab[30].value = escape_func(auth_user, auth_request);\n\ttab[31].value = escape_func(t_strcut(auth_user, '@'), auth_request);\n\ttab[32].value = strchr(auth_user, '@');\n\tif (tab[32].value != NULL)\n\t\ttab[32].value = escape_func(tab[32].value+1, auth_request);\n\tif (auth_request->local_name != NULL)\n\t\ttab[33].value = escape_func(auth_request->local_name, auth_request);\n\telse\n\t\ttab[33].value = \"\";\n\treturn ret_tab;\n}",
        "label": 0
    },
    {
        "pre_patch": "SCM_DEFINE (scm_mkdir, \"mkdir\", 1, 1, 0,\n            (SCM path, SCM mode),\n\t    \"Create a new directory named by @var{path}.  If @var{mode} is omitted\\n\"\n\t    \"then the permissions of the directory are set to @code{#o777}\\n\"\n\t    \"masked with the current umask (@pxref{Processes, @code{umask}}).\\n\"\n\t    \"Otherwise they are set to the value specified with @var{mode}.\\n\"\n\t    \"The return value is unspecified.\")\n#define FUNC_NAME s_scm_mkdir\n{\n  int rv;\n  mode_t c_mode;\n\n  c_mode = SCM_UNBNDP (mode) ? 0777 : scm_to_uint (mode);\n\n  STRING_SYSCALL (path, c_path, rv = mkdir (c_path, c_mode));\n  if (rv != 0)\n    SCM_SYSERROR;\n\n  return SCM_UNSPECIFIED;\n}",
        "post_patch": "SCM_DEFINE (scm_mkdir, \"mkdir\", 1, 1, 0,\n            (SCM path, SCM mode),\n\t    \"Create a new directory named by @var{path}.  If @var{mode} is omitted\\n\"\n\t    \"then the permissions of the directory are set to @code{#o777}\\n\"\n\t    \"masked with the current umask (@pxref{Processes, @code{umask}}).\\n\"\n\t    \"Otherwise they are set to the value specified with @var{mode}.\\n\"\n\t    \"The return value is unspecified.\")\n#define FUNC_NAME s_scm_mkdir\n{\n  int rv;\n  mode_t c_mode;\n\n  c_mode = SCM_UNBNDP (mode) ? 0777 : scm_to_uint (mode);\n\n  STRING_SYSCALL (path, c_path, rv = mkdir (c_path, c_mode));\n  if (rv != 0)\n    SCM_SYSERROR;\n\n  return SCM_UNSPECIFIED;\n}",
        "label": 0
    },
    {
        "pre_patch": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (n < 6) {\n        /* need at least ticket_lifetime_hint + ticket length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache\n             */\n            if (i & SSL_SESS_CACHE_NO_INTERNAL_STORE) {\n                if (s->session_ctx->remove_session_cb != NULL)\n                    s->session_ctx->remove_session_cb(s->session_ctx,\n                                                      s->session);\n            } else {\n                /* We carry on if this fails */\n                SSL_CTX_remove_session(s->session_ctx, s->session);\n            }\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    /* ticket_lifetime_hint + ticket_length + ticket */\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "post_patch": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (n < 6) {\n        /* need at least ticket_lifetime_hint + ticket length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache\n             */\n            if (i & SSL_SESS_CACHE_NO_INTERNAL_STORE) {\n                if (s->session_ctx->remove_session_cb != NULL)\n                    s->session_ctx->remove_session_cb(s->session_ctx,\n                                                      s->session);\n            } else {\n                /* We carry on if this fails */\n                SSL_CTX_remove_session(s->session_ctx, s->session);\n            }\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    /* ticket_lifetime_hint + ticket_length + ticket */\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "label": 0
    },
    {
        "pre_patch": "BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n{\n    int i, j;\n    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\n    unsigned char *tmp = NULL;\n    X509_ALGOR *xa;\n    ASN1_OCTET_STRING *data_body = NULL;\n    const EVP_MD *evp_md;\n    const EVP_CIPHER *evp_cipher = NULL;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n            }\n\n            j = OBJ_obj2nid(xa->algorithm);\n            evp_md = EVP_get_digestbynid(j);\n            if (evp_md == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_UNKNOWN_DIGEST_TYPE);\n                goto err;\n            }\n\n            BIO_set_md(btmp, evp_md);\n            if (out == NULL)\n                out = btmp;\n            else\n                BIO_push(out, btmp);\n            btmp = NULL;\n        }\n    }\n\n    if (evp_cipher != NULL) {\n#if 0\n        unsigned char key[EVP_MAX_KEY_LENGTH];\n        unsigned char iv[EVP_MAX_IV_LENGTH];\n        unsigned char *p;\n        int keylen, ivlen;\n        int max;\n        X509_OBJECT ret;\n#endif\n        unsigned char *tkey = NULL;\n        int tkeylen;\n        int jj;\n\n        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n            goto err;\n        }\n\n        /*\n         * It was encrypted, we need to decrypt the secret key with the\n         * private key\n         */\n\n        /*\n         * Find the recipientInfo which matches the passed certificate (if\n         * any)\n         */\n\n        if (pcert) {\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                if (!pkcs7_cmp_ri(ri, pcert))\n                    break;\n                ri = NULL;\n            }\n            if (ri == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n                goto err;\n            }\n        }\n\n        jj = EVP_PKEY_size(pkey);\n        tmp = (unsigned char *)OPENSSL_malloc(jj + 10);\n        if (tmp == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* If we haven't got a certificate try each ri in turn */\n\n        if (pcert == NULL) {\n            /*\n             * Temporary storage in case EVP_PKEY_decrypt overwrites output\n             * buffer on error.\n             */\n            unsigned char *tmp2;\n            tmp2 = OPENSSL_malloc(jj);\n            if (!tmp2)\n                goto err;\n            jj = -1;\n            /*\n             * Always attempt to decrypt all cases to avoid leaking timing\n             * information about a successful decrypt.\n             */\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                int tret;\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                tret = EVP_PKEY_decrypt(tmp2,\n                                        M_ASN1_STRING_data(ri->enc_key),\n                                        M_ASN1_STRING_length(ri->enc_key),\n                                        pkey);\n                if (tret > 0) {\n                    memcpy(tmp, tmp2, tret);\n                    OPENSSL_cleanse(tmp2, tret);\n                    jj = tret;\n                }\n                ERR_clear_error();\n            }\n            OPENSSL_free(tmp2);\n        } else {\n            jj = EVP_PKEY_decrypt(tmp,\n                                  M_ASN1_STRING_data(ri->enc_key),\n                                  M_ASN1_STRING_length(ri->enc_key), pkey);\n            ERR_clear_error();\n        }\n\n        evp_ctx = NULL;\n        BIO_get_cipher_ctx(etmp, &evp_ctx);\n        if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\n            goto err;\n        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\n            goto err;\n        /* Generate random key to counter MMA */\n        tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n        tkey = OPENSSL_malloc(tkeylen);\n        if (!tkey)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n            goto err;\n        /* If we have no key use random key */\n        if (jj <= 0) {\n            OPENSSL_free(tmp);\n            jj = tkeylen;\n            tmp = tkey;\n            tkey = NULL;\n        }\n\n        if (jj != tkeylen) {\n            /*\n             * Some S/MIME clients don't use the same key and effective key\n             * length. The key length is determined by the size of the\n             * decrypted RSA key.\n             */\n            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, jj)) {\n                /* As MMA defence use random key instead */\n                OPENSSL_cleanse(tmp, jj);\n                OPENSSL_free(tmp);\n                jj = tkeylen;\n                tmp = tkey;\n                tkey = NULL;\n            }\n        }\n        ERR_clear_error();\n        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, tmp, NULL, 0) <= 0)\n            goto err;\n\n        OPENSSL_cleanse(tmp, jj);\n\n        if (tkey) {\n            OPENSSL_cleanse(tkey, tkeylen);\n            OPENSSL_free(tkey);\n        }\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n#if 1\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n# if 0\n        bio = BIO_new(BIO_s_mem());\n        /*\n         * We need to set this so that when we have read all the data, the\n         * encrypt BIO, if present, will read EOF and encode the last few\n         * bytes\n         */\n        BIO_set_mem_eof_return(bio, 0);\n\n        if (data_body->length > 0)\n            BIO_write(bio, (char *)data_body->data, data_body->length);\n# else\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;\n# endif\n    }\n    BIO_push(out, bio);\n    bio = NULL;\n#endif\n    if (0) {\n err:\n        if (out != NULL)\n            BIO_free_all(out);\n        if (btmp != NULL)\n            BIO_free_all(btmp);\n        if (etmp != NULL)\n            BIO_free_all(etmp);\n        if (bio != NULL)\n            BIO_free_all(bio);\n        out = NULL;\n    }\n    if (tmp != NULL)\n        OPENSSL_free(tmp);\n    return (out);\n}",
        "post_patch": "BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n{\n    int i, j;\n    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\n    unsigned char *tmp = NULL;\n    X509_ALGOR *xa;\n    ASN1_OCTET_STRING *data_body = NULL;\n    const EVP_MD *evp_md;\n    const EVP_CIPHER *evp_cipher = NULL;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n            }\n\n            j = OBJ_obj2nid(xa->algorithm);\n            evp_md = EVP_get_digestbynid(j);\n            if (evp_md == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_UNKNOWN_DIGEST_TYPE);\n                goto err;\n            }\n\n            BIO_set_md(btmp, evp_md);\n            if (out == NULL)\n                out = btmp;\n            else\n                BIO_push(out, btmp);\n            btmp = NULL;\n        }\n    }\n\n    if (evp_cipher != NULL) {\n#if 0\n        unsigned char key[EVP_MAX_KEY_LENGTH];\n        unsigned char iv[EVP_MAX_IV_LENGTH];\n        unsigned char *p;\n        int keylen, ivlen;\n        int max;\n        X509_OBJECT ret;\n#endif\n        unsigned char *tkey = NULL;\n        int tkeylen;\n        int jj;\n\n        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n            goto err;\n        }\n\n        /*\n         * It was encrypted, we need to decrypt the secret key with the\n         * private key\n         */\n\n        /*\n         * Find the recipientInfo which matches the passed certificate (if\n         * any)\n         */\n\n        if (pcert) {\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                if (!pkcs7_cmp_ri(ri, pcert))\n                    break;\n                ri = NULL;\n            }\n            if (ri == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n                goto err;\n            }\n        }\n\n        jj = EVP_PKEY_size(pkey);\n        tmp = (unsigned char *)OPENSSL_malloc(jj + 10);\n        if (tmp == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* If we haven't got a certificate try each ri in turn */\n\n        if (pcert == NULL) {\n            /*\n             * Temporary storage in case EVP_PKEY_decrypt overwrites output\n             * buffer on error.\n             */\n            unsigned char *tmp2;\n            tmp2 = OPENSSL_malloc(jj);\n            if (!tmp2)\n                goto err;\n            jj = -1;\n            /*\n             * Always attempt to decrypt all cases to avoid leaking timing\n             * information about a successful decrypt.\n             */\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                int tret;\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                tret = EVP_PKEY_decrypt(tmp2,\n                                        M_ASN1_STRING_data(ri->enc_key),\n                                        M_ASN1_STRING_length(ri->enc_key),\n                                        pkey);\n                if (tret > 0) {\n                    memcpy(tmp, tmp2, tret);\n                    OPENSSL_cleanse(tmp2, tret);\n                    jj = tret;\n                }\n                ERR_clear_error();\n            }\n            OPENSSL_free(tmp2);\n        } else {\n            jj = EVP_PKEY_decrypt(tmp,\n                                  M_ASN1_STRING_data(ri->enc_key),\n                                  M_ASN1_STRING_length(ri->enc_key), pkey);\n            ERR_clear_error();\n        }\n\n        evp_ctx = NULL;\n        BIO_get_cipher_ctx(etmp, &evp_ctx);\n        if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\n            goto err;\n        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\n            goto err;\n        /* Generate random key to counter MMA */\n        tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n        tkey = OPENSSL_malloc(tkeylen);\n        if (!tkey)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n            goto err;\n        /* If we have no key use random key */\n        if (jj <= 0) {\n            OPENSSL_free(tmp);\n            jj = tkeylen;\n            tmp = tkey;\n            tkey = NULL;\n        }\n\n        if (jj != tkeylen) {\n            /*\n             * Some S/MIME clients don't use the same key and effective key\n             * length. The key length is determined by the size of the\n             * decrypted RSA key.\n             */\n            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, jj)) {\n                /* As MMA defence use random key instead */\n                OPENSSL_cleanse(tmp, jj);\n                OPENSSL_free(tmp);\n                jj = tkeylen;\n                tmp = tkey;\n                tkey = NULL;\n            }\n        }\n        ERR_clear_error();\n        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, tmp, NULL, 0) <= 0)\n            goto err;\n\n        OPENSSL_cleanse(tmp, jj);\n\n        if (tkey) {\n            OPENSSL_cleanse(tkey, tkeylen);\n            OPENSSL_free(tkey);\n        }\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n#if 1\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n# if 0\n        bio = BIO_new(BIO_s_mem());\n        /*\n         * We need to set this so that when we have read all the data, the\n         * encrypt BIO, if present, will read EOF and encode the last few\n         * bytes\n         */\n        BIO_set_mem_eof_return(bio, 0);\n\n        if (data_body->length > 0)\n            BIO_write(bio, (char *)data_body->data, data_body->length);\n# else\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;\n# endif\n    }\n    BIO_push(out, bio);\n    bio = NULL;\n#endif\n    if (0) {\n err:\n        if (out != NULL)\n            BIO_free_all(out);\n        if (btmp != NULL)\n            BIO_free_all(btmp);\n        if (etmp != NULL)\n            BIO_free_all(etmp);\n        if (bio != NULL)\n            BIO_free_all(bio);\n        out = NULL;\n    }\n    if (tmp != NULL)\n        OPENSSL_free(tmp);\n    return (out);\n}",
        "label": 0
    },
    {
        "pre_patch": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n    return -1;\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n\n  /* By specification, this command only returns SSH_FXP_STATUS */\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        /*\n         * mkdir always returns a failure, even if the path already exists.\n         * To be POSIX conform and to be able to map it to EEXIST a stat\n         * call is needed here.\n         */\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    /*\n     * The status should be SSH_FX_OK if the command was successful, if it\n     * didn't, then there was an error\n     */\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n\n  return -1;\n}",
        "post_patch": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n    return -1;\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n\n  /* By specification, this command only returns SSH_FXP_STATUS */\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        /*\n         * mkdir always returns a failure, even if the path already exists.\n         * To be POSIX conform and to be able to map it to EEXIST a stat\n         * call is needed here.\n         */\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    /*\n     * The status should be SSH_FX_OK if the command was successful, if it\n     * didn't, then there was an error\n     */\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n\n  return -1;\n}",
        "label": 0
    },
    {
        "pre_patch": "    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)\n{\n    krb5_context\t\tkrb5context = NULL;\n    krb5_keytab \t\tkrb5keytab = NULL;\n    krb5_keytab_entry           entry;\n    krb5_principal              princ = NULL;\n    krb5_error_code  \t\tkrb5rc = KRB5KRB_ERR_GENERIC;\n    int rc = 0;\n\n    if ((krb5rc = krb5_init_context(&krb5context)))\n        return(0);\n\n    /*\tkssl_ctx->keytab_file == NULL ==> use Kerberos default\n    */\n    if (kssl_ctx->keytab_file)\n    {\n        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\n                                  &krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    else\n    {\n        krb5rc = krb5_kt_default(krb5context,&krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n\n    /* the host key we are looking for */\n    krb5rc = krb5_sname_to_principal(krb5context, NULL, \n                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\n                                     KRB5_NT_SRV_HST, &princ);\n\n    if (krb5rc)\n\tgoto exit;\n\n    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, \n                                princ,\n                                0 /* IGNORE_VNO */,\n                                0 /* IGNORE_ENCTYPE */,\n                                &entry);\n    if ( krb5rc == KRB5_KT_NOTFOUND ) {\n        rc = 1;\n        goto exit;\n    } else if ( krb5rc )\n        goto exit;\n    \n    krb5_kt_free_entry(krb5context, &entry);\n    rc = 1;\n\n  exit:\n    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);\n    if (princ)          krb5_free_principal(krb5context, princ);\n    if (krb5context)\tkrb5_free_context(krb5context);\n    return(rc);\n}",
        "post_patch": "    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)\n{\n    krb5_context\t\tkrb5context = NULL;\n    krb5_keytab \t\tkrb5keytab = NULL;\n    krb5_keytab_entry           entry;\n    krb5_principal              princ = NULL;\n    krb5_error_code  \t\tkrb5rc = KRB5KRB_ERR_GENERIC;\n    int rc = 0;\n\n    if ((krb5rc = krb5_init_context(&krb5context)))\n        return(0);\n\n    /*\tkssl_ctx->keytab_file == NULL ==> use Kerberos default\n    */\n    if (kssl_ctx->keytab_file)\n    {\n        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\n                                  &krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    else\n    {\n        krb5rc = krb5_kt_default(krb5context,&krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n\n    /* the host key we are looking for */\n    krb5rc = krb5_sname_to_principal(krb5context, NULL, \n                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\n                                     KRB5_NT_SRV_HST, &princ);\n\n    if (krb5rc)\n\tgoto exit;\n\n    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, \n                                princ,\n                                0 /* IGNORE_VNO */,\n                                0 /* IGNORE_ENCTYPE */,\n                                &entry);\n    if ( krb5rc == KRB5_KT_NOTFOUND ) {\n        rc = 1;\n        goto exit;\n    } else if ( krb5rc )\n        goto exit;\n    \n    krb5_kt_free_entry(krb5context, &entry);\n    rc = 1;\n\n  exit:\n    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);\n    if (princ)          krb5_free_principal(krb5context, princ);\n    if (krb5context)\tkrb5_free_context(krb5context);\n    return(rc);\n}",
        "label": 0
    },
    {
        "pre_patch": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}",
        "post_patch": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}",
        "label": 0
    },
    {
        "pre_patch": "ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t u1, u0;\n  mp_size_t n;\n\n  n = 2*p->size;\n  u1 = rp[--n];\n  u0 = rp[n-1];\n\n  /* This is not particularly fast, but should work well with assembly implementation. */\n  for (; n >= p->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, cy;\n\n      /* <q2, q1, q0> = v * u1 + <u1,u0>, with v = 2^32 - 1:\n\n\t   +---+---+\n\t   | u1| u0|\n\t   +---+---+\n\t       |-u1|\n\t     +-+-+-+\n\t     | u1|\n       +---+-+-+-+-+\n       | q2| q1| q0|\n       +---+---+---+\n      */\n      q1 = u1 - (u1 > u0);\n      q0 = u0 - u1;\n      t = u1 << 32;\n      q0 += t;\n      t = (u1 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n\n      /* Compute candidate remainder */\n      u1 = u0 + (q1 << 32) - q1;\n      t = -(mp_limb_t) (u1 > q0);\n      u1 -= t & 0xffffffff;\n      q1 += t;\n      q2 += t + (q1 < t);\n\n      assert (q2 < 2);\n\n      /*\n\t n-1 n-2 n-3 n-4\n        +---+---+---+---+\n        | u1| u0| u low |\n        +---+---+---+---+\n          - | q1(2^96-1)|\n            +-------+---+\n            |q2(2^.)|\n            +-------+\n\n\t We multiply by two low limbs of p, 2^96 - 1, so we could use\n\t shifts rather than mul.\n      */\n      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n      t += (-q2) & 0xffffffff;\n\n      u0 = rp[n-2];\n      cy = (u0 < t);\n      u0 -= t;\n      t = (u1 < cy);\n      u1 -= cy;\n\n      cy = cnd_add_n (t, rp + n - 4, p->m, 2);\n      u0 += cy;\n      u1 += (u0 < cy);\n      u1 -= (-t) & 0xffffffff;\n    }\n  rp[2] = u0;\n  rp[3] = u1;\n}",
        "post_patch": "ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t u1, u0;\n  mp_size_t n;\n\n  n = 2*p->size;\n  u1 = rp[--n];\n  u0 = rp[n-1];\n\n  /* This is not particularly fast, but should work well with assembly implementation. */\n  for (; n >= p->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, cy;\n\n      /* <q2, q1, q0> = v * u1 + <u1,u0>, with v = 2^32 - 1:\n\n\t   +---+---+\n\t   | u1| u0|\n\t   +---+---+\n\t       |-u1|\n\t     +-+-+-+\n\t     | u1|\n       +---+-+-+-+-+\n       | q2| q1| q0|\n       +---+---+---+\n      */\n      q1 = u1 - (u1 > u0);\n      q0 = u0 - u1;\n      t = u1 << 32;\n      q0 += t;\n      t = (u1 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n\n      /* Compute candidate remainder */\n      u1 = u0 + (q1 << 32) - q1;\n      t = -(mp_limb_t) (u1 > q0);\n      u1 -= t & 0xffffffff;\n      q1 += t;\n      q2 += t + (q1 < t);\n\n      assert (q2 < 2);\n\n      /*\n\t n-1 n-2 n-3 n-4\n        +---+---+---+---+\n        | u1| u0| u low |\n        +---+---+---+---+\n          - | q1(2^96-1)|\n            +-------+---+\n            |q2(2^.)|\n            +-------+\n\n\t We multiply by two low limbs of p, 2^96 - 1, so we could use\n\t shifts rather than mul.\n      */\n      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n      t += (-q2) & 0xffffffff;\n\n      u0 = rp[n-2];\n      cy = (u0 < t);\n      u0 -= t;\n      t = (u1 < cy);\n      u1 -= cy;\n\n      cy = cnd_add_n (t, rp + n - 4, p->m, 2);\n      u0 += cy;\n      u1 += (u0 < cy);\n      u1 -= (-t) & 0xffffffff;\n    }\n  rp[2] = u0;\n  rp[3] = u1;\n}",
        "label": 0
    },
    {
        "pre_patch": "void cgit_print_http_headers(void)\n{\n\tif (ctx.env.no_http && !strcmp(ctx.env.no_http, \"1\"))\n\t\treturn;\n\n\tif (ctx.page.status)\n\t\thtmlf(\"Status: %d %s\\n\", ctx.page.status, ctx.page.statusmsg);\n\tif (ctx.page.mimetype && ctx.page.charset)\n\t\thtmlf(\"Content-Type: %s; charset=%s\\n\", ctx.page.mimetype,\n\t\t      ctx.page.charset);\n\telse if (ctx.page.mimetype)\n\t\thtmlf(\"Content-Type: %s\\n\", ctx.page.mimetype);\n\tif (ctx.page.size)\n\t\thtmlf(\"Content-Length: %zd\\n\", ctx.page.size);\n\tif (ctx.page.filename) {\n\t\thtml(\"Content-Disposition: inline; filename=\\\"\");\n\t\thtml_header_arg_in_quotes(ctx.page.filename);\n\t\thtml(\"\\\"\\n\");\n\t}\n\tif (!ctx.env.authenticated)\n\t\thtml(\"Cache-Control: no-cache, no-store\\n\");\n\thtmlf(\"Last-Modified: %s\\n\", http_date(ctx.page.modified));\n\thtmlf(\"Expires: %s\\n\", http_date(ctx.page.expires));\n\tif (ctx.page.etag)\n\t\thtmlf(\"ETag: \\\"%s\\\"\\n\", ctx.page.etag);\n\thtml(\"\\n\");\n\tif (ctx.env.request_method && !strcmp(ctx.env.request_method, \"HEAD\"))\n\t\texit(0);\n}",
        "post_patch": "void cgit_print_http_headers(void)\n{\n\tif (ctx.env.no_http && !strcmp(ctx.env.no_http, \"1\"))\n\t\treturn;\n\n\tif (ctx.page.status)\n\t\thtmlf(\"Status: %d %s\\n\", ctx.page.status, ctx.page.statusmsg);\n\tif (ctx.page.mimetype && ctx.page.charset)\n\t\thtmlf(\"Content-Type: %s; charset=%s\\n\", ctx.page.mimetype,\n\t\t      ctx.page.charset);\n\telse if (ctx.page.mimetype)\n\t\thtmlf(\"Content-Type: %s\\n\", ctx.page.mimetype);\n\tif (ctx.page.size)\n\t\thtmlf(\"Content-Length: %zd\\n\", ctx.page.size);\n\tif (ctx.page.filename) {\n\t\thtml(\"Content-Disposition: inline; filename=\\\"\");\n\t\thtml_header_arg_in_quotes(ctx.page.filename);\n\t\thtml(\"\\\"\\n\");\n\t}\n\tif (!ctx.env.authenticated)\n\t\thtml(\"Cache-Control: no-cache, no-store\\n\");\n\thtmlf(\"Last-Modified: %s\\n\", http_date(ctx.page.modified));\n\thtmlf(\"Expires: %s\\n\", http_date(ctx.page.expires));\n\tif (ctx.page.etag)\n\t\thtmlf(\"ETag: \\\"%s\\\"\\n\", ctx.page.etag);\n\thtml(\"\\n\");\n\tif (ctx.env.request_method && !strcmp(ctx.env.request_method, \"HEAD\"))\n\t\texit(0);\n}",
        "label": 0
    },
    {
        "pre_patch": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n\n  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */\n  if (size > 12 * len)\n    /* 11 is not a bug, the initial offset happens only once. */\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n\n                    /* As a heuristic, prefer memchr to seeking by\n                       delta1 when the latter doesn't advance much.  */\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                    if (ep <= tp)\n                      break;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n\n  /* Now we have only a few characters left to search.  We\n     carefully avoid ever producing an out-of-bounds pointer. */\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n\n  return -1;\n}",
        "post_patch": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n\n  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */\n  if (size > 12 * len)\n    /* 11 is not a bug, the initial offset happens only once. */\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n\n                    /* As a heuristic, prefer memchr to seeking by\n                       delta1 when the latter doesn't advance much.  */\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                    if (ep <= tp)\n                      break;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n\n  /* Now we have only a few characters left to search.  We\n     carefully avoid ever producing an out-of-bounds pointer. */\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n\n  return -1;\n}",
        "label": 0
    },
    {
        "pre_patch": "vte_sequence_handler_window_manipulation (VteTerminal *terminal, GValueArray *params)\n{\n\tGdkScreen *gscreen;\n\tVteScreen *screen;\n\tGValue *value;\n\tGtkWidget *widget;\n\tchar buf[128];\n\tlong param, arg1, arg2;\n\tgint width, height;\n\tguint i;\n\tGtkAllocation allocation;\n\n\twidget = &terminal->widget;\n\tscreen = terminal->pvt->screen;\n\n\tfor (i = 0; ((params != NULL) && (i < params->n_values)); i++) {\n\t\targ1 = arg2 = -1;\n\t\tif (i + 1 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 1);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ1 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tif (i + 2 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 2);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ2 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t\tswitch (param) {\n\t\tcase 1:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Deiconifying window.\\n\");\n\t\t\tvte_terminal_emit_deiconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Iconifying window.\\n\");\n\t\t\tvte_terminal_emit_iconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((arg1 != -1) && (arg2 != -2)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Moving window to \"\n\t\t\t\t\t\t\"%ld,%ld.\\n\", arg1, arg2);\n\t\t\t\tvte_terminal_emit_move_window(terminal,\n\t\t\t\t\t\t\t      arg1, arg2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ldx%ld pixels).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Raising window.\\n\");\n\t\t\tvte_terminal_emit_raise_window(terminal);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Lowering window.\\n\");\n\t\t\tvte_terminal_emit_lower_window(terminal);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Refreshing window.\\n\");\n\t\t\t_vte_invalidate_all(terminal);\n\t\t\tvte_terminal_emit_refresh_window(terminal);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ld columns, %ld rows).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 * terminal->char_width +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (arg1) {\n\t\t\tcase 0:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Restoring window.\\n\");\n\t\t\t\tvte_terminal_emit_restore_window(terminal);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Maximizing window.\\n\");\n\t\t\t\tvte_terminal_emit_maximize_window(terminal);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\t/* If we're unmapped, then we're iconified. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%dt\",\n\t\t\t\t   1 + !gtk_widget_get_mapped(widget));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window state %s.\\n\",\n\t\t\t\t\tgtk_widget_get_mapped(widget) ?\n\t\t\t\t\t\"non-iconified\" : \"iconified\");\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t/* Send window location, in pixels. */\n\t\t\tgdk_window_get_origin(gtk_widget_get_window(widget),\n\t\t\t\t\t      &width, &height);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"3;%d;%dt\",\n\t\t\t\t   width + terminal->pvt->inner_border.left,\n                                   height + terminal->pvt->inner_border.top);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window location\"\n\t\t\t\t\t\"(%d++,%d++).\\n\",\n\t\t\t\t\twidth, height);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t/* Send window size, in pixels. */\n\t\t\tgtk_widget_get_allocation(widget, &allocation);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"4;%d;%dt\",\n\t\t\t\t   allocation.height -\n                                       (terminal->pvt->inner_border.top +\n                                        terminal->pvt->inner_border.bottom),\n\t\t\t\t   allocation.width -\n                                       (terminal->pvt->inner_border.left +\n                                        terminal->pvt->inner_border.right));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window size \"\n\t\t\t\t\t\"(%dx%dn\",\n\t\t\t\t\twidth - (terminal->pvt->inner_border.left + terminal->pvt->inner_border.right),\n\t\t\t\t\theight - (terminal->pvt->inner_border.top + terminal->pvt->inner_border.bottom));\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\t/* Send widget size, in cells. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting widget size.\\n\");\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"8;%ld;%ldt\",\n\t\t\t\t   terminal->row_count,\n\t\t\t\t   terminal->column_count);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting screen size.\\n\");\n\t\t\tgscreen = gtk_widget_get_screen(widget);\n\t\t\theight = gdk_screen_get_height(gscreen);\n\t\t\twidth = gdk_screen_get_width(gscreen);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"9;%ld;%ldt\",\n\t\t\t\t   height / terminal->char_height,\n\t\t\t\t   width / terminal->char_width);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t/* Report a static icon title, since the real\n\t\t\t   icon title should NEVER be reported, as it\n\t\t\t   creates a security vulnerability.  See\n\t\t\t   http://marc.info/?l=bugtraq&m=104612710031920&w=2\n\t\t\t   and CVE-2003-0070. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\"Reporting fake icon title.\\n\");\n\t\t\t/* never use terminal->icon_title here! */\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"LTerminal\" _VTE_CAP_ST);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t/* Report a static window title, since the real\n\t\t\t   window title should NEVER be reported, as it\n\t\t\t   creates a security vulnerability.  See\n\t\t\t   http://marc.info/?l=bugtraq&m=104612710031920&w=2\n\t\t\t   and CVE-2003-0070. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting fake window title.\\n\");\n\t\t\t/* never use terminal->window_title here! */\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"lTerminal\" _VTE_CAP_ST);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (param >= 24) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing to %ld rows.\\n\",\n\t\t\t\t\t       \tparam);\n\t\t\t\t/* Resize to the specified number of\n\t\t\t\t * rows. */\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\tterminal->column_count * terminal->char_width +\n                                                                terminal->pvt->inner_border.left +\n                                                                terminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\tparam * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n                                                                terminal->pvt->inner_border.bottom);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "post_patch": "vte_sequence_handler_window_manipulation (VteTerminal *terminal, GValueArray *params)\n{\n\tGdkScreen *gscreen;\n\tVteScreen *screen;\n\tGValue *value;\n\tGtkWidget *widget;\n\tchar buf[128];\n\tlong param, arg1, arg2;\n\tgint width, height;\n\tguint i;\n\tGtkAllocation allocation;\n\n\twidget = &terminal->widget;\n\tscreen = terminal->pvt->screen;\n\n\tfor (i = 0; ((params != NULL) && (i < params->n_values)); i++) {\n\t\targ1 = arg2 = -1;\n\t\tif (i + 1 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 1);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ1 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tif (i + 2 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 2);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ2 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t\tswitch (param) {\n\t\tcase 1:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Deiconifying window.\\n\");\n\t\t\tvte_terminal_emit_deiconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Iconifying window.\\n\");\n\t\t\tvte_terminal_emit_iconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((arg1 != -1) && (arg2 != -2)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Moving window to \"\n\t\t\t\t\t\t\"%ld,%ld.\\n\", arg1, arg2);\n\t\t\t\tvte_terminal_emit_move_window(terminal,\n\t\t\t\t\t\t\t      arg1, arg2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ldx%ld pixels).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Raising window.\\n\");\n\t\t\tvte_terminal_emit_raise_window(terminal);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Lowering window.\\n\");\n\t\t\tvte_terminal_emit_lower_window(terminal);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Refreshing window.\\n\");\n\t\t\t_vte_invalidate_all(terminal);\n\t\t\tvte_terminal_emit_refresh_window(terminal);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ld columns, %ld rows).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 * terminal->char_width +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (arg1) {\n\t\t\tcase 0:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Restoring window.\\n\");\n\t\t\t\tvte_terminal_emit_restore_window(terminal);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Maximizing window.\\n\");\n\t\t\t\tvte_terminal_emit_maximize_window(terminal);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\t/* If we're unmapped, then we're iconified. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%dt\",\n\t\t\t\t   1 + !gtk_widget_get_mapped(widget));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window state %s.\\n\",\n\t\t\t\t\tgtk_widget_get_mapped(widget) ?\n\t\t\t\t\t\"non-iconified\" : \"iconified\");\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t/* Send window location, in pixels. */\n\t\t\tgdk_window_get_origin(gtk_widget_get_window(widget),\n\t\t\t\t\t      &width, &height);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"3;%d;%dt\",\n\t\t\t\t   width + terminal->pvt->inner_border.left,\n                                   height + terminal->pvt->inner_border.top);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window location\"\n\t\t\t\t\t\"(%d++,%d++).\\n\",\n\t\t\t\t\twidth, height);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t/* Send window size, in pixels. */\n\t\t\tgtk_widget_get_allocation(widget, &allocation);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"4;%d;%dt\",\n\t\t\t\t   allocation.height -\n                                       (terminal->pvt->inner_border.top +\n                                        terminal->pvt->inner_border.bottom),\n\t\t\t\t   allocation.width -\n                                       (terminal->pvt->inner_border.left +\n                                        terminal->pvt->inner_border.right));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window size \"\n\t\t\t\t\t\"(%dx%dn\",\n\t\t\t\t\twidth - (terminal->pvt->inner_border.left + terminal->pvt->inner_border.right),\n\t\t\t\t\theight - (terminal->pvt->inner_border.top + terminal->pvt->inner_border.bottom));\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\t/* Send widget size, in cells. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting widget size.\\n\");\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"8;%ld;%ldt\",\n\t\t\t\t   terminal->row_count,\n\t\t\t\t   terminal->column_count);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting screen size.\\n\");\n\t\t\tgscreen = gtk_widget_get_screen(widget);\n\t\t\theight = gdk_screen_get_height(gscreen);\n\t\t\twidth = gdk_screen_get_width(gscreen);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"9;%ld;%ldt\",\n\t\t\t\t   height / terminal->char_height,\n\t\t\t\t   width / terminal->char_width);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t/* Report a static icon title, since the real\n\t\t\t   icon title should NEVER be reported, as it\n\t\t\t   creates a security vulnerability.  See\n\t\t\t   http://marc.info/?l=bugtraq&m=104612710031920&w=2\n\t\t\t   and CVE-2003-0070. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\"Reporting fake icon title.\\n\");\n\t\t\t/* never use terminal->icon_title here! */\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"LTerminal\" _VTE_CAP_ST);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t/* Report a static window title, since the real\n\t\t\t   window title should NEVER be reported, as it\n\t\t\t   creates a security vulnerability.  See\n\t\t\t   http://marc.info/?l=bugtraq&m=104612710031920&w=2\n\t\t\t   and CVE-2003-0070. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting fake window title.\\n\");\n\t\t\t/* never use terminal->window_title here! */\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"lTerminal\" _VTE_CAP_ST);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (param >= 24) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing to %ld rows.\\n\",\n\t\t\t\t\t       \tparam);\n\t\t\t\t/* Resize to the specified number of\n\t\t\t\t * rows. */\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\tterminal->column_count * terminal->char_width +\n                                                                terminal->pvt->inner_border.left +\n                                                                terminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\tparam * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n                                                                terminal->pvt->inner_border.bottom);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "label": 0
    },
    {
        "pre_patch": "int unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix[0] = tab_prefix0;\n    tab_prefix[1] = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n\tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n\t      program_name, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n\tfprintf(stderr,\n\t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n\t\tprogram_name, ifname, maxbits, BITS);\n\texit_code = ERROR;\n\treturn ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n\ttab_suffixof(code) = (char_type)code;\n    }\n    do {\n\tREG1 int i;\n\tint  e;\n\tint  o;\n\n    resetbuf:\n\to = posbits >> 3;\n\te = o <= insize ? insize - o : 0;\n\n\tfor (i = 0 ; i < e ; ++i) {\n\t    inbuf[i] = inbuf[i+o];\n\t}\n\tinsize = e;\n\tposbits = 0;\n\n\tif (insize < INBUF_EXTRA) {\n\t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n\t    if (rsize == -1) {\n\t\tread_error();\n\t    }\n\t    insize += rsize;\n\t    bytes_in += (off_t)rsize;\n\t}\n\tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n\t\t  ((long)insize<<3)-(n_bits-1));\n\n\twhile (inbits > posbits) {\n\t    if (free_ent > maxcode) {\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\t++n_bits;\n\t\tif (n_bits == maxbits) {\n\t\t    maxcode = maxmaxcode;\n\t\t} else {\n\t\t    maxcode = MAXCODE(n_bits)-1;\n\t\t}\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    input(inbuf,posbits,code,n_bits,bitmask);\n\t    Tracev((stderr, \"%d \", code));\n\n\t    if (oldcode == -1) {\n\t\tif (256 <= code)\n\t\t  gzip_error (\"corrupt input.\");\n\t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n\t\tcontinue;\n\t    }\n\t    if (code == CLEAR && block_mode) {\n\t\tclear_tab_prefixof();\n\t\tfree_ent = FIRST - 1;\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    incode = code;\n\t    stackp = de_stack;\n\n\t    if (code >= free_ent) { /* Special case for KwKwK string. */\n\t\tif (code > free_ent) {\n#ifdef DEBUG\n\t\t    char_type *p;\n\n\t\t    posbits -= n_bits;\n\t\t    p = &inbuf[posbits>>3];\n\t\t    fprintf(stderr,\n\t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n\t\t\t    code, free_ent, n_bits, insize);\n\t\t    fprintf(stderr,\n\t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n\t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n#endif\n\t\t    if (!test && outpos > 0) {\n\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\tbytes_out += (off_t)outpos;\n\t\t    }\n\t\t    gzip_error (to_stdout\n\t\t\t\t? \"corrupt input.\"\n\t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n\t\t}\n\t\t*--stackp = (char_type)finchar;\n\t\tcode = oldcode;\n\t    }\n\n\t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n\t\t/* Generate output characters in reverse order */\n\t\t*--stackp = tab_suffixof(code);\n\t\tcode = tab_prefixof(code);\n\t    }\n\t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n\n\t    /* And put them out in forward order */\n\t    {\n\t\tREG1 int\ti;\n\n\t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n\t\t    do {\n\t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n\t\t\tif (i > 0) {\n\t\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t\t    outpos += i;\n\t\t\t}\n\t\t\tif (outpos >= OUTBUFSIZ) {\n\t\t\t    if (!test) {\n\t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\t\tbytes_out += (off_t)outpos;\n\t\t\t    }\n\t\t\t    outpos = 0;\n\t\t\t}\n\t\t\tstackp+= i;\n\t\t    } while ((i = (de_stack-stackp)) > 0);\n\t\t} else {\n\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t    outpos += i;\n\t\t}\n\t    }\n\n\t    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */\n\n\t\ttab_prefixof(code) = (unsigned short)oldcode;\n\t\ttab_suffixof(code) = (char_type)finchar;\n\t\tfree_ent = code+1;\n\t    }\n\t    oldcode = incode;\t/* Remember previous code.\t*/\n\t}\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n\twrite_buf(out, (char*)outbuf, outpos);\n\tbytes_out += (off_t)outpos;\n    }\n    return OK;\n}",
        "post_patch": "int unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix[0] = tab_prefix0;\n    tab_prefix[1] = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n\tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n\t      program_name, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n\tfprintf(stderr,\n\t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n\t\tprogram_name, ifname, maxbits, BITS);\n\texit_code = ERROR;\n\treturn ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n\ttab_suffixof(code) = (char_type)code;\n    }\n    do {\n\tREG1 int i;\n\tint  e;\n\tint  o;\n\n    resetbuf:\n\to = posbits >> 3;\n\te = o <= insize ? insize - o : 0;\n\n\tfor (i = 0 ; i < e ; ++i) {\n\t    inbuf[i] = inbuf[i+o];\n\t}\n\tinsize = e;\n\tposbits = 0;\n\n\tif (insize < INBUF_EXTRA) {\n\t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n\t    if (rsize == -1) {\n\t\tread_error();\n\t    }\n\t    insize += rsize;\n\t    bytes_in += (off_t)rsize;\n\t}\n\tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n\t\t  ((long)insize<<3)-(n_bits-1));\n\n\twhile (inbits > posbits) {\n\t    if (free_ent > maxcode) {\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\t++n_bits;\n\t\tif (n_bits == maxbits) {\n\t\t    maxcode = maxmaxcode;\n\t\t} else {\n\t\t    maxcode = MAXCODE(n_bits)-1;\n\t\t}\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    input(inbuf,posbits,code,n_bits,bitmask);\n\t    Tracev((stderr, \"%d \", code));\n\n\t    if (oldcode == -1) {\n\t\tif (256 <= code)\n\t\t  gzip_error (\"corrupt input.\");\n\t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n\t\tcontinue;\n\t    }\n\t    if (code == CLEAR && block_mode) {\n\t\tclear_tab_prefixof();\n\t\tfree_ent = FIRST - 1;\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    incode = code;\n\t    stackp = de_stack;\n\n\t    if (code >= free_ent) { /* Special case for KwKwK string. */\n\t\tif (code > free_ent) {\n#ifdef DEBUG\n\t\t    char_type *p;\n\n\t\t    posbits -= n_bits;\n\t\t    p = &inbuf[posbits>>3];\n\t\t    fprintf(stderr,\n\t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n\t\t\t    code, free_ent, n_bits, insize);\n\t\t    fprintf(stderr,\n\t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n\t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n#endif\n\t\t    if (!test && outpos > 0) {\n\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\tbytes_out += (off_t)outpos;\n\t\t    }\n\t\t    gzip_error (to_stdout\n\t\t\t\t? \"corrupt input.\"\n\t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n\t\t}\n\t\t*--stackp = (char_type)finchar;\n\t\tcode = oldcode;\n\t    }\n\n\t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n\t\t/* Generate output characters in reverse order */\n\t\t*--stackp = tab_suffixof(code);\n\t\tcode = tab_prefixof(code);\n\t    }\n\t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n\n\t    /* And put them out in forward order */\n\t    {\n\t\tREG1 int\ti;\n\n\t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n\t\t    do {\n\t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n\t\t\tif (i > 0) {\n\t\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t\t    outpos += i;\n\t\t\t}\n\t\t\tif (outpos >= OUTBUFSIZ) {\n\t\t\t    if (!test) {\n\t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\t\tbytes_out += (off_t)outpos;\n\t\t\t    }\n\t\t\t    outpos = 0;\n\t\t\t}\n\t\t\tstackp+= i;\n\t\t    } while ((i = (de_stack-stackp)) > 0);\n\t\t} else {\n\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t    outpos += i;\n\t\t}\n\t    }\n\n\t    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */\n\n\t\ttab_prefixof(code) = (unsigned short)oldcode;\n\t\ttab_suffixof(code) = (char_type)finchar;\n\t\tfree_ent = code+1;\n\t    }\n\t    oldcode = incode;\t/* Remember previous code.\t*/\n\t}\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n\twrite_buf(out, (char*)outbuf, outpos);\n\tbytes_out += (off_t)outpos;\n    }\n    return OK;\n}",
        "label": 0
    },
    {
        "pre_patch": "static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr, *map;\n\n\t\tkaddr = map = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}",
        "post_patch": "static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr, *map;\n\n\t\tkaddr = map = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}",
        "label": 0
    },
    {
        "pre_patch": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}",
        "post_patch": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}",
        "label": 0
    },
    {
        "pre_patch": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tprintk(KERN_ERR \"hfs: catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}",
        "post_patch": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tprintk(KERN_ERR \"hfs: catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}",
        "label": 0
    },
    {
        "pre_patch": "static sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}",
        "post_patch": "static sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[]=\"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}",
        "label": 0
    },
    {
        "pre_patch": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (authkey->sca_keylength > optlen - sizeof(struct sctp_authkey)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "post_patch": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (authkey->sca_keylength > optlen - sizeof(struct sctp_authkey)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "label": 0
    },
    {
        "pre_patch": "void __cpuinit cpu_init (void)\n{\n\tint cpu = stack_smp_processor_id();\n\tstruct tss_struct *t = &per_cpu(init_tss, cpu);\n\tstruct orig_ist *orig_ist = &per_cpu(orig_ist, cpu);\n\tunsigned long v; \n\tchar *estacks = NULL; \n\tstruct task_struct *me;\n\tint i;\n\n\t/* CPU 0 is initialised in head64.c */\n\tif (cpu != 0) {\n\t\tpda_init(cpu);\n\t\tzap_low_mappings(cpu);\n\t} else \n\t\testacks = boot_exception_stacks; \n\n\tme = current;\n\n\tif (cpu_test_and_set(cpu, cpu_initialized))\n\t\tpanic(\"CPU#%d already initialized!\\n\", cpu);\n\n\tprintk(\"Initializing CPU#%d\\n\", cpu);\n\n\tclear_in_cr4(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);\n\n\t/*\n\t * Initialize the per-CPU GDT with the boot GDT,\n\t * and set up the GDT descriptor:\n\t */\n\tif (cpu)\n \t\tmemcpy(cpu_gdt(cpu), cpu_gdt_table, GDT_SIZE);\n\n\tcpu_gdt_descr[cpu].size = GDT_SIZE;\n\tasm volatile(\"lgdt %0\" :: \"m\" (cpu_gdt_descr[cpu]));\n\tasm volatile(\"lidt %0\" :: \"m\" (idt_descr));\n\n\tmemset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);\n\tsyscall_init();\n\n\twrmsrl(MSR_FS_BASE, 0);\n\twrmsrl(MSR_KERNEL_GS_BASE, 0);\n\tbarrier(); \n\n\tcheck_efer();\n\n\t/*\n\t * set up and load the per-CPU TSS\n\t */\n\tfor (v = 0; v < N_EXCEPTION_STACKS; v++) {\n\t\tstatic const unsigned int order[N_EXCEPTION_STACKS] = {\n\t\t\t[0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,\n\t\t\t[DEBUG_STACK - 1] = DEBUG_STACK_ORDER\n\t\t};\n\t\tif (cpu) {\n\t\t\testacks = (char *)__get_free_pages(GFP_ATOMIC, order[v]);\n\t\t\tif (!estacks)\n\t\t\t\tpanic(\"Cannot allocate exception stack %ld %d\\n\",\n\t\t\t\t      v, cpu); \n\t\t}\n\t\testacks += PAGE_SIZE << order[v];\n\t\torig_ist->ist[v] = t->ist[v] = (unsigned long)estacks;\n\t}\n\n\tt->io_bitmap_base = offsetof(struct tss_struct, io_bitmap);\n\t/*\n\t * <= is required because the CPU will access up to\n\t * 8 bits beyond the end of the IO permission bitmap.\n\t */\n\tfor (i = 0; i <= IO_BITMAP_LONGS; i++)\n\t\tt->io_bitmap[i] = ~0UL;\n\n\tatomic_inc(&init_mm.mm_count);\n\tme->active_mm = &init_mm;\n\tif (me->mm)\n\t\tBUG();\n\tenter_lazy_tlb(&init_mm, me);\n\n\tset_tss_desc(cpu, t);\n\tload_TR_desc();\n\tload_LDT(&init_mm.context);\n\n\t/*\n\t * Clear all 6 debug registers:\n\t */\n\n\tset_debugreg(0UL, 0);\n\tset_debugreg(0UL, 1);\n\tset_debugreg(0UL, 2);\n\tset_debugreg(0UL, 3);\n\tset_debugreg(0UL, 6);\n\tset_debugreg(0UL, 7);\n\n\tfpu_init(); \n\n\traw_local_save_flags(kernel_eflags);\n}",
        "post_patch": "void __cpuinit cpu_init (void)\n{\n\tint cpu = stack_smp_processor_id();\n\tstruct tss_struct *t = &per_cpu(init_tss, cpu);\n\tstruct orig_ist *orig_ist = &per_cpu(orig_ist, cpu);\n\tunsigned long v; \n\tchar *estacks = NULL; \n\tstruct task_struct *me;\n\tint i;\n\n\t/* CPU 0 is initialised in head64.c */\n\tif (cpu != 0) {\n\t\tpda_init(cpu);\n\t\tzap_low_mappings(cpu);\n\t} else \n\t\testacks = boot_exception_stacks; \n\n\tme = current;\n\n\tif (cpu_test_and_set(cpu, cpu_initialized))\n\t\tpanic(\"CPU#%d already initialized!\\n\", cpu);\n\n\tprintk(\"Initializing CPU#%d\\n\", cpu);\n\n\tclear_in_cr4(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);\n\n\t/*\n\t * Initialize the per-CPU GDT with the boot GDT,\n\t * and set up the GDT descriptor:\n\t */\n\tif (cpu)\n \t\tmemcpy(cpu_gdt(cpu), cpu_gdt_table, GDT_SIZE);\n\n\tcpu_gdt_descr[cpu].size = GDT_SIZE;\n\tasm volatile(\"lgdt %0\" :: \"m\" (cpu_gdt_descr[cpu]));\n\tasm volatile(\"lidt %0\" :: \"m\" (idt_descr));\n\n\tmemset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);\n\tsyscall_init();\n\n\twrmsrl(MSR_FS_BASE, 0);\n\twrmsrl(MSR_KERNEL_GS_BASE, 0);\n\tbarrier(); \n\n\tcheck_efer();\n\n\t/*\n\t * set up and load the per-CPU TSS\n\t */\n\tfor (v = 0; v < N_EXCEPTION_STACKS; v++) {\n\t\tstatic const unsigned int order[N_EXCEPTION_STACKS] = {\n\t\t\t[0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,\n\t\t\t[DEBUG_STACK - 1] = DEBUG_STACK_ORDER\n\t\t};\n\t\tif (cpu) {\n\t\t\testacks = (char *)__get_free_pages(GFP_ATOMIC, order[v]);\n\t\t\tif (!estacks)\n\t\t\t\tpanic(\"Cannot allocate exception stack %ld %d\\n\",\n\t\t\t\t      v, cpu); \n\t\t}\n\t\testacks += PAGE_SIZE << order[v];\n\t\torig_ist->ist[v] = t->ist[v] = (unsigned long)estacks;\n\t}\n\n\tt->io_bitmap_base = offsetof(struct tss_struct, io_bitmap);\n\t/*\n\t * <= is required because the CPU will access up to\n\t * 8 bits beyond the end of the IO permission bitmap.\n\t */\n\tfor (i = 0; i <= IO_BITMAP_LONGS; i++)\n\t\tt->io_bitmap[i] = ~0UL;\n\n\tatomic_inc(&init_mm.mm_count);\n\tme->active_mm = &init_mm;\n\tif (me->mm)\n\t\tBUG();\n\tenter_lazy_tlb(&init_mm, me);\n\n\tset_tss_desc(cpu, t);\n\tload_TR_desc();\n\tload_LDT(&init_mm.context);\n\n\t/*\n\t * Clear all 6 debug registers:\n\t */\n\n\tset_debugreg(0UL, 0);\n\tset_debugreg(0UL, 1);\n\tset_debugreg(0UL, 2);\n\tset_debugreg(0UL, 3);\n\tset_debugreg(0UL, 6);\n\tset_debugreg(0UL, 7);\n\n\tfpu_init(); \n\n\traw_local_save_flags(kernel_eflags);\n}",
        "label": 0
    },
    {
        "pre_patch": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\tif (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {\n\t\t/*\n\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t * never set\".  So let's cheat and make it one second\n\t\t * instead\n\t\t */\n\t\tnew_rlim.rlim_cur = 1;\n\t}\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
        "post_patch": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\tif (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {\n\t\t/*\n\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t * never set\".  So let's cheat and make it one second\n\t\t * instead\n\t\t */\n\t\tnew_rlim.rlim_cur = 1;\n\t}\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
        "label": 0
    },
    {
        "pre_patch": "unpack_Z_stream(int fd_in, int fd_out)\n{\n\tIF_DESKTOP(long long total_written = 0;)\n\tIF_DESKTOP(long long) int retval = -1;\n\tunsigned char *stackp;\n\tlong code;\n\tint finchar;\n\tlong oldcode;\n\tlong incode;\n\tint inbits;\n\tint posbits;\n\tint outpos;\n\tint insize;\n\tint bitmask;\n\tlong free_ent;\n\tlong maxcode;\n\tlong maxmaxcode;\n\tint n_bits;\n\tint rsize = 0;\n\tunsigned char *inbuf; /* were eating insane amounts of stack - */\n\tunsigned char *outbuf; /* bad for some embedded targets */\n\tunsigned char *htab;\n\tunsigned short *codetab;\n\n\t/* Hmm, these were statics - why?! */\n\t/* user settable max # bits/code */\n\tint maxbits; /* = BITS; */\n\t/* block compress mode -C compatible with 2.0 */\n\tint block_mode; /* = BLOCK_MODE; */\n\n\tinbuf = xzalloc(IBUFSIZ + 64);\n\toutbuf = xzalloc(OBUFSIZ + 2048);\n\thtab = xzalloc(HSIZE);  /* wsn't zeroed out before, maybe can xmalloc? */\n\tcodetab = xzalloc(HSIZE * sizeof(codetab[0]));\n\n\tinsize = 0;\n\n\t/* xread isn't good here, we have to return - caller may want\n\t * to do some cleanup (e.g. delete incomplete unpacked file etc) */\n\tif (full_read(fd_in, inbuf, 1) != 1) {\n\t\tbb_error_msg(\"short read\");\n\t\tgoto err;\n\t}\n\n\tmaxbits = inbuf[0] & BIT_MASK;\n\tblock_mode = inbuf[0] & BLOCK_MODE;\n\tmaxmaxcode = MAXCODE(maxbits);\n\n\tif (maxbits > BITS) {\n\t\tbb_error_msg(\"compressed with %d bits, can only handle \"\n\t\t\t\tBITS_STR\" bits\", maxbits);\n\t\tgoto err;\n\t}\n\n\tn_bits = INIT_BITS;\n\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\tbitmask = (1 << INIT_BITS) - 1;\n\toldcode = -1;\n\tfinchar = 0;\n\toutpos = 0;\n\tposbits = 0 << 3;\n\n\tfree_ent = ((block_mode) ? FIRST : 256);\n\n\t/* As above, initialize the first 256 entries in the table. */\n\t/*clear_tab_prefixof(); - done by xzalloc */\n\n\tfor (code = 255; code >= 0; --code) {\n\t\ttab_suffixof(code) = (unsigned char) code;\n\t}\n\n\tdo {\n resetbuf:\n\t\t{\n\t\t\tint i;\n\t\t\tint e;\n\t\t\tint o;\n\n\t\t\to = posbits >> 3;\n\t\t\te = insize - o;\n\n\t\t\tfor (i = 0; i < e; ++i)\n\t\t\t\tinbuf[i] = inbuf[i + o];\n\n\t\t\tinsize = e;\n\t\t\tposbits = 0;\n\t\t}\n\n\t\tif (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {\n\t\t\trsize = safe_read(fd_in, inbuf + insize, IBUFSIZ);\n\t\t\tif (rsize < 0)\n\t\t\t\tbb_error_msg(bb_msg_read_error);\n\t\t\tinsize += rsize;\n\t\t}\n\n\t\tinbits = ((rsize > 0) ? (insize - insize % n_bits) << 3 :\n\t\t\t\t  (insize << 3) - (n_bits - 1));\n\n\t\twhile (inbits > posbits) {\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == maxbits) {\n\t\t\t\t\tmaxcode = maxmaxcode;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits) - 1;\n\t\t\t\t}\n\t\t\t\tbitmask = (1 << n_bits) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\t\t\t{\n\t\t\t\tunsigned char *p = &inbuf[posbits >> 3];\n\n\t\t\t\tcode = ((((long) (p[0])) | ((long) (p[1]) << 8) |\n\t\t\t\t         ((long) (p[2]) << 16)) >> (posbits & 0x7)) & bitmask;\n\t\t\t}\n\t\t\tposbits += n_bits;\n\n\n\t\t\tif (oldcode == -1) {\n\t\t\t\tif (code >= 256)\n\t\t\t\t\tbb_error_msg_and_die(\"corrupted data\"); /* %ld\", code); */\n\t\t\t\toldcode = code;\n\t\t\t\tfinchar = (int) oldcode;\n\t\t\t\toutbuf[outpos++] = (unsigned char) finchar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (code == CLEAR && block_mode) {\n\t\t\t\tclear_tab_prefixof();\n\t\t\t\tfree_ent = FIRST - 1;\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\tn_bits = INIT_BITS;\n\t\t\t\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\t\t\t\tbitmask = (1 << INIT_BITS) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\n\t\t\tincode = code;\n\t\t\tstackp = de_stack;\n\n\t\t\t/* Special case for KwKwK string. */\n\t\t\tif (code >= free_ent) {\n\t\t\t\tif (code > free_ent) {\n\t\t\t\t\tunsigned char *p;\n\n\t\t\t\t\tposbits -= n_bits;\n\t\t\t\t\tp = &inbuf[posbits >> 3];\n\n\t\t\t\t\tbb_error_msg\n\t\t\t\t\t\t(\"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\",\n\t\t\t\t\t\t insize, posbits, p[-1], p[0], p[1], p[2], p[3],\n\t\t\t\t\t\t (posbits & 07));\n\t\t\t\t\tbb_error_msg(\"corrupted data\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t*--stackp = (unsigned char) finchar;\n\t\t\t\tcode = oldcode;\n\t\t\t}\n\n\t\t\t/* Generate output characters in reverse order */\n\t\t\twhile ((long) code >= (long) 256) {\n\t\t\t\tif (stackp <= &htabof(0))\n\t\t\t\t\tbb_error_msg_and_die(\"corrupted data\");\n\t\t\t\t*--stackp = tab_suffixof(code);\n\t\t\t\tcode = tab_prefixof(code);\n\t\t\t}\n\n\t\t\tfinchar = tab_suffixof(code);\n\t\t\t*--stackp = (unsigned char) finchar;\n\n\t\t\t/* And put them out in forward order */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\ti = de_stack - stackp;\n\t\t\t\tif (outpos + i >= OBUFSIZ) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (i > OBUFSIZ - outpos) {\n\t\t\t\t\t\t\ti = OBUFSIZ - outpos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\t\t\toutpos += i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (outpos >= OBUFSIZ) {\n\t\t\t\t\t\t\txwrite(fd_out, outbuf, outpos);\n\t\t\t\t\t\t\tIF_DESKTOP(total_written += outpos;)\n\t\t\t\t\t\t\toutpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackp += i;\n\t\t\t\t\t\ti = de_stack - stackp;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\toutpos += i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate the new entry. */\n\t\t\tcode = free_ent;\n\t\t\tif (code < maxmaxcode) {\n\t\t\t\ttab_prefixof(code) = (unsigned short) oldcode;\n\t\t\t\ttab_suffixof(code) = (unsigned char) finchar;\n\t\t\t\tfree_ent = code + 1;\n\t\t\t}\n\n\t\t\t/* Remember previous code.  */\n\t\t\toldcode = incode;\n\t\t}\n\n\t} while (rsize > 0);\n\n\tif (outpos > 0) {\n\t\txwrite(fd_out, outbuf, outpos);\n\t\tIF_DESKTOP(total_written += outpos;)\n\t}\n\n\tretval = IF_DESKTOP(total_written) + 0;\n err:\n\tfree(inbuf);\n\tfree(outbuf);\n\tfree(htab);\n\tfree(codetab);\n\treturn retval;\n}",
        "post_patch": "unpack_Z_stream(int fd_in, int fd_out)\n{\n\tIF_DESKTOP(long long total_written = 0;)\n\tIF_DESKTOP(long long) int retval = -1;\n\tunsigned char *stackp;\n\tlong code;\n\tint finchar;\n\tlong oldcode;\n\tlong incode;\n\tint inbits;\n\tint posbits;\n\tint outpos;\n\tint insize;\n\tint bitmask;\n\tlong free_ent;\n\tlong maxcode;\n\tlong maxmaxcode;\n\tint n_bits;\n\tint rsize = 0;\n\tunsigned char *inbuf; /* were eating insane amounts of stack - */\n\tunsigned char *outbuf; /* bad for some embedded targets */\n\tunsigned char *htab;\n\tunsigned short *codetab;\n\n\t/* Hmm, these were statics - why?! */\n\t/* user settable max # bits/code */\n\tint maxbits; /* = BITS; */\n\t/* block compress mode -C compatible with 2.0 */\n\tint block_mode; /* = BLOCK_MODE; */\n\n\tinbuf = xzalloc(IBUFSIZ + 64);\n\toutbuf = xzalloc(OBUFSIZ + 2048);\n\thtab = xzalloc(HSIZE);  /* wsn't zeroed out before, maybe can xmalloc? */\n\tcodetab = xzalloc(HSIZE * sizeof(codetab[0]));\n\n\tinsize = 0;\n\n\t/* xread isn't good here, we have to return - caller may want\n\t * to do some cleanup (e.g. delete incomplete unpacked file etc) */\n\tif (full_read(fd_in, inbuf, 1) != 1) {\n\t\tbb_error_msg(\"short read\");\n\t\tgoto err;\n\t}\n\n\tmaxbits = inbuf[0] & BIT_MASK;\n\tblock_mode = inbuf[0] & BLOCK_MODE;\n\tmaxmaxcode = MAXCODE(maxbits);\n\n\tif (maxbits > BITS) {\n\t\tbb_error_msg(\"compressed with %d bits, can only handle \"\n\t\t\t\tBITS_STR\" bits\", maxbits);\n\t\tgoto err;\n\t}\n\n\tn_bits = INIT_BITS;\n\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\tbitmask = (1 << INIT_BITS) - 1;\n\toldcode = -1;\n\tfinchar = 0;\n\toutpos = 0;\n\tposbits = 0 << 3;\n\n\tfree_ent = ((block_mode) ? FIRST : 256);\n\n\t/* As above, initialize the first 256 entries in the table. */\n\t/*clear_tab_prefixof(); - done by xzalloc */\n\n\tfor (code = 255; code >= 0; --code) {\n\t\ttab_suffixof(code) = (unsigned char) code;\n\t}\n\n\tdo {\n resetbuf:\n\t\t{\n\t\t\tint i;\n\t\t\tint e;\n\t\t\tint o;\n\n\t\t\to = posbits >> 3;\n\t\t\te = insize - o;\n\n\t\t\tfor (i = 0; i < e; ++i)\n\t\t\t\tinbuf[i] = inbuf[i + o];\n\n\t\t\tinsize = e;\n\t\t\tposbits = 0;\n\t\t}\n\n\t\tif (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {\n\t\t\trsize = safe_read(fd_in, inbuf + insize, IBUFSIZ);\n\t\t\tif (rsize < 0)\n\t\t\t\tbb_error_msg(bb_msg_read_error);\n\t\t\tinsize += rsize;\n\t\t}\n\n\t\tinbits = ((rsize > 0) ? (insize - insize % n_bits) << 3 :\n\t\t\t\t  (insize << 3) - (n_bits - 1));\n\n\t\twhile (inbits > posbits) {\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == maxbits) {\n\t\t\t\t\tmaxcode = maxmaxcode;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits) - 1;\n\t\t\t\t}\n\t\t\t\tbitmask = (1 << n_bits) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\t\t\t{\n\t\t\t\tunsigned char *p = &inbuf[posbits >> 3];\n\n\t\t\t\tcode = ((((long) (p[0])) | ((long) (p[1]) << 8) |\n\t\t\t\t         ((long) (p[2]) << 16)) >> (posbits & 0x7)) & bitmask;\n\t\t\t}\n\t\t\tposbits += n_bits;\n\n\n\t\t\tif (oldcode == -1) {\n\t\t\t\tif (code >= 256)\n\t\t\t\t\tbb_error_msg_and_die(\"corrupted data\"); /* %ld\", code); */\n\t\t\t\toldcode = code;\n\t\t\t\tfinchar = (int) oldcode;\n\t\t\t\toutbuf[outpos++] = (unsigned char) finchar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (code == CLEAR && block_mode) {\n\t\t\t\tclear_tab_prefixof();\n\t\t\t\tfree_ent = FIRST - 1;\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\tn_bits = INIT_BITS;\n\t\t\t\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\t\t\t\tbitmask = (1 << INIT_BITS) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\n\t\t\tincode = code;\n\t\t\tstackp = de_stack;\n\n\t\t\t/* Special case for KwKwK string. */\n\t\t\tif (code >= free_ent) {\n\t\t\t\tif (code > free_ent) {\n\t\t\t\t\tunsigned char *p;\n\n\t\t\t\t\tposbits -= n_bits;\n\t\t\t\t\tp = &inbuf[posbits >> 3];\n\n\t\t\t\t\tbb_error_msg\n\t\t\t\t\t\t(\"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\",\n\t\t\t\t\t\t insize, posbits, p[-1], p[0], p[1], p[2], p[3],\n\t\t\t\t\t\t (posbits & 07));\n\t\t\t\t\tbb_error_msg(\"corrupted data\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t*--stackp = (unsigned char) finchar;\n\t\t\t\tcode = oldcode;\n\t\t\t}\n\n\t\t\t/* Generate output characters in reverse order */\n\t\t\twhile ((long) code >= (long) 256) {\n\t\t\t\tif (stackp <= &htabof(0))\n\t\t\t\t\tbb_error_msg_and_die(\"corrupted data\");\n\t\t\t\t*--stackp = tab_suffixof(code);\n\t\t\t\tcode = tab_prefixof(code);\n\t\t\t}\n\n\t\t\tfinchar = tab_suffixof(code);\n\t\t\t*--stackp = (unsigned char) finchar;\n\n\t\t\t/* And put them out in forward order */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\ti = de_stack - stackp;\n\t\t\t\tif (outpos + i >= OBUFSIZ) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (i > OBUFSIZ - outpos) {\n\t\t\t\t\t\t\ti = OBUFSIZ - outpos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\t\t\toutpos += i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (outpos >= OBUFSIZ) {\n\t\t\t\t\t\t\txwrite(fd_out, outbuf, outpos);\n\t\t\t\t\t\t\tIF_DESKTOP(total_written += outpos;)\n\t\t\t\t\t\t\toutpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackp += i;\n\t\t\t\t\t\ti = de_stack - stackp;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\toutpos += i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate the new entry. */\n\t\t\tcode = free_ent;\n\t\t\tif (code < maxmaxcode) {\n\t\t\t\ttab_prefixof(code) = (unsigned short) oldcode;\n\t\t\t\ttab_suffixof(code) = (unsigned char) finchar;\n\t\t\t\tfree_ent = code + 1;\n\t\t\t}\n\n\t\t\t/* Remember previous code.  */\n\t\t\toldcode = incode;\n\t\t}\n\n\t} while (rsize > 0);\n\n\tif (outpos > 0) {\n\t\txwrite(fd_out, outbuf, outpos);\n\t\tIF_DESKTOP(total_written += outpos;)\n\t}\n\n\tretval = IF_DESKTOP(total_written) + 0;\n err:\n\tfree(inbuf);\n\tfree(outbuf);\n\tfree(htab);\n\tfree(codetab);\n\treturn retval;\n}",
        "label": 0
    }
]